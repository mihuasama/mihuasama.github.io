{"meta":{"title":"MiHuA","subtitle":"Blog","description":"Learning record","author":"mihua","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2020-04-17T10:44:41.053Z","updated":"2020-04-14T07:02:09.939Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2020-04-17T10:44:41.055Z","updated":"2020-04-14T11:43:07.572Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-17T10:44:41.054Z","updated":"2020-04-14T11:42:23.779Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"《数据结构与算法之美》 10 红黑树","slug":"DataStructure10","date":"2020-04-29T01:26:58.176Z","updated":"2020-04-29T12:04:24.968Z","comments":true,"path":"2020/04/29/DataStructure10/","link":"","permalink":"http://yoursite.com/2020/04/29/DataStructure10/","excerpt":"","text":"该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。 第21-22课 - - - - - - -红黑树1.2-3查找树。a.定义 2-3树:由2节点和3节点这两种种节点构成的树。 2节点:1key+2child，一个值加两个子节点。类似排序二叉树的节点，左子节点的值小于它，右子节点的值大于它。 3节点:2key+3child,就是通过两个key分为三个范围：range1 &lt; key1 &lt; range2 &lt; key2 &lt; range3其中的三个子节点的取值范围分别在range1,range2和range3中。 b.插入操作第一步，先查找对应的元素应该被插入的位置。第二步，分两种情况操作。如果查找的位置结束于2节点，那么直接插入，形成一个3节点。如果查找的位置结束于3节点，那么需要处理的方式有三种。1).只有一个3节点的树的情况下：这种情况下先将插入数放入3节点构造成一个4节点，然后提取中值(中键)分裂成一个2节点带两个子节点。 2).插入节点为3节点，插入节点的父节点为2节点的情况下： 这种情况下先将插入数放入3节点构造成一个4节点，然后将4节点分裂成两个2节点，并且提取中值(中键)移到父节点，将父节点构造成一个3节点。 3).插入节点为3节点，插入节点的父节点为3节点的情况下： 这种情况下先将插入数放入3节点构造成一个4节点，然后将4节点分裂成两个2节点，并且提取中值(中键)移到父节点，将父节点构造成一个4节点。然后父节点提取中值向上分裂，知道分裂到情况2，处理完成后没有4节点结束。 除了相关的结点和链接之外不必修改或者检查树的其他部分。每次变换中，变更的链接数量不会超过一个很小的常数。所有局部变换都不会影响整棵树的有序性和平衡性。 c.删除操作1.删除的元素是叶子节点并且含有两个元素 2.删除的元素是叶子节点并且只有1个元素的话,但是父节点的右节点函数含有两个元素 3.删除的元素是叶子节点,但是父节点的右节点只有一个元素 4.如果删除的叶子节点的父结点是两个元素的话并且父节点的左右的左结点还可以插入 5.如果删除的是满二叉树6.删除的是非叶子节点并且只有一个元素7.删除的是非叶子节点并且只有两个元素情况1：情况2： d.2-3树的优点 2-3树在最坏情况下仍有较好的性能。每个操作中处理每个结点的时间都不会超过一个很小的常数，且这两个操作都只会访问一条路径上的结点，所以任何查找或者插入的成本都肯定不会超过对数级别。 完美平衡的2-3树要平展的多。例如，含有10亿个结点的一颗2-3树的高度仅在19到30之间。我们最多只需要访问30个结点就能在10亿个键中进行任意查找和插入操作。 e.2-3树的缺点我们需要维护两种不同类型的结点，查找和插入操作的实现需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。平衡一棵树的初衷是为了消除最坏情况，但我们希望这种保障所需的代码能够越少越好。 2.红黑树红黑树其实用红节点标识3节点，黑节点标识2节点的2-3树。 红节点，其实是标识连接到这个节点的边是红色的。红黑树的定义就是满足3个条件的二叉查找树：1.红连接均为左连接。2.没有一个节点同时和两条红连接相连。(因为如果有超过一条红连接，那么3节点就不再是3节点，而是更高)3.该树是完美黑色平衡的，即任意空连接到根节点的路径上的黑链接数量相同。 参考资料:[1] https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf[2] https://blog.csdn.net/yang_yulei/article/details/26066409","categories":[{"name":"读书系列","slug":"读书系列","permalink":"http://yoursite.com/categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构与算法之美","slug":"数据结构与算法之美","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"}]},{"title":"《数据结构与算法之美》 09 二叉树","slug":"DataStructure09","date":"2020-04-27T11:21:41.163Z","updated":"2020-04-29T01:24:55.023Z","comments":true,"path":"2020/04/27/DataStructure09/","link":"","permalink":"http://yoursite.com/2020/04/27/DataStructure09/","excerpt":"","text":"该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。 第19课 - - - - - - -二叉树(上)一、树概念1： A 节点是 B 节点的父节点，B 节点是 A 节点的子节点。 B、C、D 这三 个节点的父节点是同一个节点，所以它们之间互称为兄弟节点。 没有父节点的节点叫 作根节点，也就是图中的节点 E。 没有子节点的节点叫作叶子节点或者叶节点，比如 图中的 G、H、I、J、K、L 都是叶子节点。 概念2： 高度：节点到叶子节点的最长路径(边数)深度：根节点到这个节点所经历的边的个数节点的层数 ： 节点的深度+1树的高度 = 根节点的高度 二、二叉树1.定义二叉树，每个节点最多有两个子节点，分别是左子节点和右子节点。满二叉树：编号 2 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左 右两个子节点。完全二叉树：编号 3 的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除 了最后一层，其他层的节点个数都要达到最大。（主要从存储去看） 2.二叉树的存储a.基于指针或者引用的二叉链式存储法 每个节点有三 个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就 可以通过左右子节点的指针，把整棵树都串起来。 b.基于数组的顺序存储法 把根节点存储在下标 i = 1 的位置，那左子节点 存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。以此类推，B 节点的 左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位 置。 如果不是完全二叉树就会浪费存储空间: 堆其实就是一种完全二叉树，最常用的存储方式 就是数组。 3.二叉树的遍历前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最 后打印它的右子树。中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后 打印它的右子树。后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树， 最后打印这个节点本身。 实际上，二叉树的前、中、后序遍历就是一个递归的过程。 代码实现: 1234567891011121314151617181920212223242526272829303132333435typedef struct Tree_Node &#123; struct Tree_Node * leftChild; struct Tree_Node * rightChild; int data;&#125;Node;//先序遍历void preOrder(Node * root) &#123; if (root == NULL) &#123; return; &#125; printf(\"%d\",root-&gt;data); preOrder(root-&gt;leftChild); preOrder(root-&gt;rightChild);&#125;//中序遍历void intOrder(Node * root) &#123; if (root == NULL) &#123; return; &#125; preOrder(root-&gt;leftChild); printf(\"%d\",root-&gt;data); preOrder(root-&gt;rightChild);&#125;//后序遍历void postOrder(Node * root) &#123; if (root == NULL) &#123; return; &#125; preOrder(root-&gt;leftChild); preOrder(root-&gt;rightChild); printf(\"%d\",root-&gt;data);&#125; 4.二叉树遍历的时间复杂度 从前面画的前、中、后序遍历的顺序图，可以看出来，每个节点最多会被访问两次，所以 遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说二叉树遍历的时间复杂度是 O(n)。 三、完全二叉树适合用数组来存储 二叉树既可以用链式存储，也可以用数组顺序存储。数组顺序存储的方式比较适合完全二叉 树，其他类型的二叉树用数组存储会比较浪费存储空间。 四、二叉树的基础编码1.从数组创建完全二叉树1234567891011121314Node* createNode(int * nums,int size,int index) &#123; if (index &gt;= size) &#123; return NULL; &#125; Node* node = (Node*)malloc(sizeof(Node)); node-&gt;data = nums[index]; node-&gt;leftChild = createNode(nums, size, 2*(index+1)-1); node-&gt;rightChild = createNode(nums, size, 2*(index+1)); return node;&#125;//数组存储的完全二叉树生成链式存储的完全二叉树Node * createBinaryTreeByArray(int * nums,int size) &#123; return createNode(nums, size, 0);&#125; 2.第20课 - - - - - - -二叉树(下)一、二叉查找树1.定义 二叉查找树：在树的任意一个节点，左子树中的每个节点的值都要小于这个节点的值，右子树节点的值都大于这个节点的值。 2.插入操作二叉排序树的插入过程：第一步、先判断当前节点与插入节点的值大小。第二步1、当插入值大于节点值，判断右子树是否为空， 如果右子树为空，则创建右子树节点并赋值。 如果右子树不为空，则去判断右子树节点和插入值大小，回到第一步第二步2、当插入值小于节点值，判断左子树是否为空， 如果左子树为空，则创建左子树节点并赋值。 如果左子树不为空，则去判断左子树节点和插入值大小，回到第一步代码实现 123456789101112131415161718192021222324252627282930313233void BST_insert(Node * root,int data) &#123; if (root == NULL) &#123; return; &#125; Node *p = root; while (p != NULL) &#123; if (data &gt; p-&gt;data) &#123; if (p-&gt;rightChild == NULL) &#123; p-&gt;rightChild = (Node*)malloc(sizeof(Node)); &#123;//初始化 p-&gt;rightChild-&gt;data = data; p-&gt;rightChild-&gt;leftChild = NULL; p-&gt;rightChild-&gt;rightChild = NULL; &#125; return; &#125;else &#123; p = p-&gt;rightChild; &#125; &#125;else &#123; if (p-&gt;leftChild == NULL) &#123; p-&gt;leftChild = (Node*)malloc(sizeof(Node)); &#123;//初始化 p-&gt;leftChild-&gt;data = data; p-&gt;leftChild-&gt;leftChild = NULL; p-&gt;leftChild-&gt;rightChild = NULL; &#125; return; &#125;else &#123; p = p-&gt;leftChild; &#125; &#125; &#125;&#125; 3.二叉查找树的创建二叉查找树的创建过程就是一个个节点的插入过程代码实现 1234567891011Node * createBST(int *nums,int size) &#123; if (nums == NULL || size &lt;= 0) &#123; return NULL; &#125; Node * root = (Node*)malloc(sizeof(Node)); root-&gt;data = nums[0]; for (int i = 1; i &lt; size; i ++) &#123; BST_insert(root, nums[i]); &#125; return root;&#125; 4.查找操作查找过程第一步：先判断当前节点的值是否与查找值相同。如果查找值相同，直接返回节点。如果查找值不相同进入第二步：第二步：判断查找值和当前节点值的大小关系：如果查找值大于当前节点值，就去右节点查找，返回第一步。如果查找值小于当前节点值，就去左节点查找，返回第一步。代码实现 12345678910111213141516Node * findInBST(Node * root,int data) &#123; if (root == NULL) &#123; return NULL; &#125; Node * findP = root; while (findP != NULL) &#123; if (data == findP-&gt;data) &#123; return findP; &#125;else if(data &gt; findP-&gt;data) &#123; findP = findP-&gt;rightChild; &#125;else if(data &lt; findP-&gt;data) &#123; findP = findP-&gt;leftChild; &#125; &#125; return NULL;&#125; 5.删除操作删除的节点有三种情况。第一种，没有子节点，可以直接将其父节点指向它的指针设置为NULL，并且释放它的内存。第二种，有一个子节点，可以将其父节点指向它的指针指向子节点，并且释放它的内存。第三种，有两个子节点，需要找到右子树的最小节点，替换当前节点，并且释放当前节点的内存。编码的过程：先查找到相应的节点，并且记录所在节点的父节点。如果没有找到节点，直接返回。如果找到节点。则判断删除的三种情况。先判断是不是有双子节点的情况。如果是，则找到该节点的右子树的最小节点。将节点的值修改为最小节点的值，然后将找到的几点指针和父指针都指向最小节点。在综合判断有一个子节点还是没有子节点的情况。如果没有子节点，父节指向该节点的指针置空，释放节点内存。如果有子节点，判断是左子节点还是右子节点。将父节点指向相应的子节点，然后释放节点内存。代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Node * BST_delete(Node * root,int data) &#123; Node * p = root; Node * pp = NULL; while (p != NULL) &#123; if (data &gt; p-&gt;data) &#123; pp = p; p = p-&gt;rightChild; &#125;else if (data &lt; p-&gt;data)&#123; pp = p; p = p-&gt;leftChild; &#125;else if (p-&gt;data == data) &#123; break; &#125; &#125; if (p == NULL) &#123; //没找到直接返回 return NULL; &#125; //判断有两个子节点的情况 if (p-&gt;leftChild != NULL &amp;&amp; p-&gt;rightChild != NULL) &#123; Node * minP = p-&gt;rightChild; Node * minPP = p; while (minP-&gt;leftChild != NULL) &#123; //没有左子树的子节点最小 minPP = minP; minP = minP-&gt;leftChild; &#125; p-&gt;data = minP-&gt;data; //把最小值赋值给该删除的节点， p = minP;//然后删除最小值所在位置的节点。 pp = minPP; &#125; //删除的节点是叶子节点，或者只有一个子节点的节点 Node * child; if (p-&gt;leftChild != NULL) &#123; child = p-&gt;leftChild; &#125;else if(p-&gt;rightChild != NULL) &#123; child = p-&gt;rightChild; &#125;else &#123; child = NULL; &#125; if (pp == NULL) &#123; //删除根节点 free(p); return child; &#125;else if(pp-&gt;leftChild == p)&#123; free(p); pp-&gt;leftChild = child; &#125;else if(pp-&gt;rightChild == p)&#123; free(p); pp-&gt;rightChild = child; &#125; return root;&#125; 6.二叉查找树的其他操作a.快速地查找最大节点和最小节点、 最大节点就是最右没有右子树的叶子。最小节点就是最左没有左子树的叶子。 b.前驱节点和后继节点 前驱节点可以通过多加一个指针记录寻找过程。后继节点直接获取。 c.二叉树的高度 待定 7.二叉查找树输出有序数列 中序遍历二叉查找树， 可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。 二、支持重复数据的二叉查找树 当利用对象的某个字段作为键值(key)来构建二叉查找树，对象中的其他字段叫作卫星数据。存储的两个对象键值相同如何解决？ 1.相同数据存在同一个树形节点上通过链表和 支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。 2.把这个新插入的数据当作大于这个节点的值来处理按这种处理情况: 当要查找数据的时候，遇到值相同的节点，并不停止查找操作，而是继续在右子树中查 找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方 法，依次删除。 三、二叉查找树的时间复杂度分析1.时间复杂度不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 O(height)。 2.树的高度完全二叉树的层数小于等于 log(n) + 1，也就是说，完全二叉树的高度小于等于 log(n)。 四、散列表和二叉树对比 1.散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二 叉查找树来说，只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序 列。 2.散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能 不稳定，但是在工程中，平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。 3.笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的 存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈 希函数的耗时，也不一定就比平衡二叉查找树的效率高。 4.散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲 突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题 的解决方案比较成熟、固定。 5.为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲 突的散列表，不然会浪费一定的存储空间。 综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲 突。在实际的开发过程中，需要结合具体的需求来选择使用哪一个。","categories":[{"name":"读书系列","slug":"读书系列","permalink":"http://yoursite.com/categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构与算法之美","slug":"数据结构与算法之美","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"}]},{"title":"《数据结构与算法之美》 08 哈希算法","slug":"DataStructure08","date":"2020-04-25T05:11:16.768Z","updated":"2020-04-27T05:40:40.700Z","comments":true,"path":"2020/04/25/DataStructure08/","link":"","permalink":"http://yoursite.com/2020/04/25/DataStructure08/","excerpt":"","text":"该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。 第17课 - - - - - - -哈希算法(上)一、哈希算法任意长度的二进制串映射为固定长度的二进制串，这个映射的规则就是哈希算法。映射出的固定长度的二进制串就是哈希值。 二、哈希算法的应用(上)1.安全加密通过哈希算法加密以后，很难根据哈希值反向推导出原始数据，可以有效防止原始数据泄露。 鸽巢原理：如果有10个鸽巢，有11只鸽子，那么肯定有一个鸽巢中的鸽子数量多于1。哈希算法之所以无法做到零冲突,是因为需要映射的二进制数据是无穷的，但是有限位的哈希结果却不是无穷的。 2.唯一标识可以通过取整个文件、或者截取部分文件求哈希值，将哈希值作为文件的唯一标识。 例如实现一个图库可以把每个图片都进行处理得到一个唯一标识，将标识和图片在图库中的路径信息存储在散列表中。当插入某个图片是不是在图库中的时候，我们先通过哈希算法对这个图片取唯一标识，然后在散列表中查询是否存在。如果不存在，就说明不在图库中；如果存在，就再通过散列表中存储的文件路径，获取这个已经存在的图片，和插入图片做全量对比，看是否完全一样。如果一样，说明已经存在。如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。 3.数据校验通过BT协议下载的文件。可以通过下面思路实现校验。 服务器通过哈希算法，对100个文件块，分别取哈希值，并且保存在种子文件中。当客户端下载的时候，可以通过相同的哈希算法对下载的文件块进行哈希计算，并且和种子文件保存的哈希值做比对。如果不同，说明这个文件块不完整，或者被篡改了。需要重新从其他宿主机器上下载这个文件块。 4.散列函数用于哈希表进行散列。需要注意散列以后的值，是否能平均分布。以及哈希函数的执行快慢。均匀分布会减少散列冲突。哈希函数执行的快慢直接决定查找删除插入操作的快慢。 三、如何防止数据库中的用户信息被脱库将用户的密码通过加盐的方式组合，增加密码的复杂度，然后拿组合之后的字符串做哈希算法加密。然后保存到数据库中。 即使这样也只是增加破解的难度，增加了攻击的成本。 第18课 - - - - - - -哈希算法(下)一、哈希算法的应用(下)1.负载均衡负载均衡的算法有很多，比如:轮询、随机、加权轮询等。可以通过哈希算法实现一个会话粘滞的负载均衡算法。 会话粘滞(session sticky)：在同一个客户端上，在一次会话中，所有的请求都路由到同一台服务器上。通过哈希算法，对客户端IP地址，或者会话ID计算哈希值。将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该背路由到的服务器编号。 2.数据分片a.如何统计”搜索关键词”出现的次数？(假如有 1T 的日志文件，这里面记录了用户的搜索关键词,想要快速统计出每个关键词被搜索的次数) 可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。 对日志文件进行分片，多台计算机读取分片的日志文件中的搜索关键词。读出搜索关键词后，通过哈希函数计算哈希值，然后对哈希值对n取模，得到应该被分配到处理数据机器编号。（n就是最后进行处理的机器的总数。）这样，哈希值相同的搜索关键词就被分配到了同一个机器上。也就是说，同一个搜索关键词被分配到同一台机器上进行处理。每台机器分别统计关键词出现的次数，最终合并起来就是最终的结果。b.如何快速判断图片是否在图库中?散列表中每个数据单元包含两个信息，哈希值和图片文件的路径。假设通过 MD5 来计 算哈希值，那长度就是 128 比特，也就是 16 字节。文件路径长度的上限是 256 字节，可以假设平均长度是 128 字节。如果用链表法来解决冲突，那还需要存储指针，指 针只占用 8 字节。所以，散列表中每个数据单元就占用 152 字节(这里只是估算，并不准 确)。假设一台机器的内存大小为 2GB，散列表的装载因子为 0.75，那一台机器可以给大约 1000 万(2GB*0.75/152)张图片构建散列表。所以，如果要对 1 亿张图片构建索引，需 要大约十几台机器。在工程中，这种估算还是很重要的，能事先对需要投入的资源、 资金有个大概的了解，能更好地评估解决方案的可行性。实际上，针对这种海量数据的处理问题，都可以采用多机分布式处理。借助这种分片的 思路，可以突破单机内存、CPU 等资源的限制。 3.分布式存储通过一致性哈希算法解决分布式机器扩容后数据迁移问题。 一致性哈希算法假设有 k 个机器，数据的哈希值的范围是 [0, MAX]。将整个范围划分成 m 个小 区间(m 远大于 k)，每个机器负责 m/k 个小区间。当有新机器加入的时候，就将某 几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移 数据，也保持了各个机器上数据数量的均衡。 4.哈希算法在分布式系统中的应用。 在负载均衡应用中，利用哈希算法替代映射表，可以实现一个会话粘滞的负载均衡策略。在 数据分片应用中，通过哈希算法对处理的海量数据进行分片，多机分布式处理，可以突破单 机资源的限制。在分布式存储应用中，利用一致性哈希算法，可以解决缓存等分布式系统的 扩容、缩容导致数据大量搬移的难题。","categories":[{"name":"读书系列","slug":"读书系列","permalink":"http://yoursite.com/categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构与算法之美","slug":"数据结构与算法之美","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"}]},{"title":"H.264 码率","slug":"H264bitrate","date":"2020-04-24T09:12:01.807Z","updated":"2020-04-29T12:08:02.530Z","comments":true,"path":"2020/04/24/H264bitrate/","link":"","permalink":"http://yoursite.com/2020/04/24/H264bitrate/","excerpt":"","text":"压缩率 图像总像素存储体积/压缩后H.264 = 压缩率通常情况下，同一段视频，压缩率越高，解码后的图像画质越差。影响压缩率的因素非常多。压缩率和图像相关：如果是静止画面，压缩率会非常大。画面运动越剧烈，压缩率就越小。画面噪点越多，压缩率越小。画面内部相邻像素相似度越低，压缩率越小。等等。压缩率同时还和编码策略相关。例如：b帧越多，压缩率越大、GOP越大，压缩率越大等等。 那么多大的H.264码率大小是适合的呢1.根据预期的理想比特率共识计算[图像宽度] x [图像高度] x [帧速率] x [运动等级] x 0.07(压缩比系数) = [所需比特率] 根据https://issuu.com/konu/docs/h264_primer这里提供的公式进行计算，1080p30fps的视频在画质和压缩率适配相对较好的情况下为：1920*1080*30*2*0.07 = 8709120 bps = 8505kbps。 2.根据Video Streaming Primer提供的信息。Video Streaming Primer1080p30fps用于电视和广播的码率应该在15Mbps = 1.875MBps。 3.自己计算 YUV420存储一个像素点需要1.5个字节;YUV422存储一个像素点需要2个字节;YUV444存储一个像素点需要3个字节; 一帧包含1080*1920 = 2073600 个像素。iOS采集一般是YUV420格式，所以一个像素点需要1.5个字节存储。即:一帧需要2073600*1.5 = 3110400个字节 = 3037.5kB = 24300kb一秒钟30帧就需要：24300*30 = 729000kbps;如果压缩比为50倍则：729000/50 = 14580kbps;如果压缩比为150倍则：729000/150 = 4860kbps;","categories":[{"name":"个人理解","slug":"个人理解","permalink":"http://yoursite.com/categories/234/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"音视频","slug":"音视频","permalink":"http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"}]},{"title":"《数据结构与算法之美》 07 散列表","slug":"DataStructure07","date":"2020-04-24T06:31:22.298Z","updated":"2020-04-27T12:37:49.553Z","comments":true,"path":"2020/04/24/DataStructure07/","link":"","permalink":"http://yoursite.com/2020/04/24/DataStructure07/","excerpt":"","text":"该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。 第14课 - - - - - - -散列表(上)一、什么是散列表 散列表就是，通过一个函数计算将数据压缩转化为一个数组的下标，并将数据存储在这个数组的该下标所在内存中的数据结构。这个函数就是散列函数，散列表是基于数组的扩展(主要利用数组随机访问时间复杂度为O(1)的优点)。 二、如何构造散列函数 散列函数设计的三个基本要求: 1.散列函数计算得到的散列值是一个非负整数; 散列值用于寻址，作为数组下标当然是从0开始，所以应该大于等于0。 2.如果key1 = key2,那么hash(key1) == hash(key2)； 同样的数据进行散列处理，肯定需要相同的值来保证寻址正确性。 3.如果key1 != key2, 那么hash(key1) != hash(key2)。 这个只能是尽可能的保证两个不同数据进行散列以后的散列值不同,但是几乎无法找到一个无冲突的散列函数。如果相同就会产生散列冲突问题。 三、装载因子装载因子的计算公式:散列表的装载因子 = 填入散列表中的元素个数/散列表的长度 装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。 四、散列冲突1.散列冲突的定义 当存在不同数据进行散列以后得到的散列值相同，这种情况就是散列冲突。 2.解决散列冲突的方法:a.开放寻址法如果出现了散列冲突，我们就重新探测一个空闲位置将其插入。 探测方式： 线性探测:如果某个数据经过散列之后，存储位置已经被占用了，就从被占用位置开始，依次往后查找空闲位置进行插入操作。(如果寻找到数组尾部还没有找到，就从数组头部开始查找空闲位置)。二次探测:和线性探测一样，只是把步长变为原来的二次方。(例如原来的是hash(key) + 1,hash(key+2),就变为hash(key)+1^2,hash(key)+2^2)。双重散列:就是实现一组散列函数。如果前一个散列函数对数据的散列值已经被占用，就启用后一个散列函数。 b.链表法 链表法就是在散列表中，把每个“桶(bucket)”或者“槽(slot)”会对应一条链表，所有散列 值相同的元素我们都放到相同槽位对应的链表中。 插入&amp;删除插入操作:将数据进行散列操作，找到对应的槽位，然后再对应的链表中进行插入操作。时间复杂度为O(1);删除操作:将数据进行散列操作，找到对应的槽位，然后再对应的链表中遍历找到元素进行删除操作。时间复杂度就等于链表中遍历找到元素进行删除操作的时间复杂度。如果链表长度为k那么时间复杂度就为k。然后对于散列比较均匀的散列函数来说，理论上为 k = n / m。n表示散列表中数据个数，m表示散列表中槽的个数。 五、Word 文档中单词拼写检查功能 是如何实现的? 常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB。可以用散列表来存储整个英文单词词典。当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼 写正确;如果没有查到，则说明拼写可能有误，给予提示。 第15课 - - - - - - -散列表(中)一、如何设计散列函数 1.散列函数的设计不能太复杂，过于复杂的散列函数会消耗过多的时间，间接影响散列表的性能。2.散列函数生成的值要尽可能随机并且均匀分布。 散列函数的一些设计方法：数据分析法、直接寻址法、平方取中值法、折叠法、随机数法、等等。 二、装载因子过大的解决办法可以设置一个装载因子的临界值，达到这个临界值以后就对散列表进行动态扩容。可以先申请一个原来散列表大小两倍的空间，这个时候散列表对应的装载因子就为原来的一半，并且重新设计散列函数。如果这时候对所有数据进行搬移，使用均摊法，可以得到时间复杂度为O(n)。 二、避免低效扩容 在动态扩容的过程中，当我们申请了新的内存空间以后，可以先不全部搬移数据。而是把数据搬移的操作穿插在散列表的新数据的普通插入操作中，这个时候，一次性的扩容就被均分到多次普通插入操作中。可以解决扩容时那次操作造成的系统拥堵。这种情况下时间复杂度为O(1)。即，当有新数据插入时，先将新数据插入新散列表，并且从老的散列表中拿一个数据放入到新的散列表中。经过多次这样的操作，老的散列表数据被完全搬移到新散列表以后，释放老散列表的空间。 三、处理散列冲突1.开放寻址法 优点:a.数据都存储在数组中，CPU缓存查查询速度快。b.这种形式的散列表序列化起来比较简单。相对的链表法实现的散列表序列化相对困难。缺点:a.删除节点的时候比较麻烦，需要特殊标记已经删除的数据。b.散列冲突的代价更高。开放寻址法，适合装载因子上限不大的散列表。开放寻址法只适用于转载因子小于1，且当装载因子接近1的时候，就会有大量的散列冲突，导致大量的探测，再散列等，性能下降很多。 当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。 2.链表法 优点a.链表法对内存的利用率比开放寻址法高。即用即申请。b.对装载因子的容忍度比开放寻址法高。c.当数据是大对象的时候，指针的空间消耗，不值一提。 基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列 表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表 四、工业级散列表举例分析《java HashMap》 1. 初始大小 初始大小为16，可以设置。如果事先知道大概数据量，可以设置，避免扩容操作。 2.装载因子和动态扩容 最大装载因子是0.75，超过以后就进行扩容，扩容空间为原来的两倍。 3.散列冲突解决方法 最开始底层采用链表法解决冲突。JDK1.8以后，当链表长度超过8，就转换为用红黑树解决。当红黑树节点少于8个的时候，又转为用链表解决。 4.散列函数123456789101112131415 int hash(Object key) &#123; int h = key.hashCode(); return (h ^ (h &gt;&gt;&gt; 16)) &amp; (capitity -1); //capicity 表示散列表的大小&#125; public int hashCode() &#123; int var1 = this.hash; if(var1 == 0 &amp;&amp; this.value.length &gt; 0) &#123; char[] var2 = this.value; for(int var3 = 0; var3 &lt; this.value.length; ++var3) &#123; var1 = 31 * var1 + var2[var3]; &#125; this.hash = var1; &#125; return var1; &#125; 五、工业级散列表1.特性: a.支持快速的查询、插入、删除操作;b.内存占用合理，不能浪费过多的内存空间; c.性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。 2.实现: a.设计一个合适的散列函数;b.定义装载因子阈值，并且设计动态扩容策略;c.选择合适的散列冲突解决方法。 第16课 - - - - - - -散列表(下)一、LRU缓存淘汰算法 1.设计原理： a.通过散列表法来解决散列冲突。b.这个链表含有两条链1).一条是存储相同hash值的元素的双向链表2).一条是把所有元素串起来的链 1.查找插入删除操作：a.查找数据通过散列表查找，找到对应的槽，然后遍历链表查找，找到以后将数据移动到遍历的起始节点之前。平摊以后时间复杂度为O(1);b.删除数据先通过a查找到数据，然后删除节点，双向链表删除节点的时间复杂度为O(1);c.添加一个数据先查询这个数据是否已经在缓存中，如果已经在缓存中，将其移动到链表遍历的起始节点之前。如果不存在缓存中，就要看缓存是否已满(通过一个缓存计数变量实现)，如果满了，就将双向链表遍历末尾节点删除，将添加的节点放在链表遍历的起始节点之前。如果没满，就直接将添加的节点放在链表遍历的起始节点之前。 二、Redis有序集合1.设计原理： 通过散列表实现；散列冲突通过链表法解决；链表上面两条链，一条双向链表，一条顺序查询链表(这条链表通过跳表实现)。 2.处理问题: 查找通过散列表删除通过散列表，然后看情况决定是否修改跳表插入通过散列表，然后看情况决定是否修改跳表按分区查找通过跳表实现 三、Java LinkedHashMap和上面LRU实现相同。LinkedHashMap 是通过双向链表和散列表这两种数据结构 组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表 法解决散列冲突。； 四、为什么散列表和链表经常一块使用?散列表的插入、删除、查找操作非常高效。但是数据通过哈希函数以后，被打乱了顺序，变得无规律。无法支持按照某种顺序快速的遍历数据。所以把散列表和链表(或者跳表)结合使用，就能实现高效的插入删除查找操作，以及按顺序或者区间遍历数据。","categories":[{"name":"读书系列","slug":"读书系列","permalink":"http://yoursite.com/categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构与算法之美","slug":"数据结构与算法之美","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"}]},{"title":"《数据结构与算法之美》 06 跳表","slug":"DataStructure06","date":"2020-04-23T11:57:54.908Z","updated":"2020-04-24T09:55:38.857Z","comments":true,"path":"2020/04/23/DataStructure06/","link":"","permalink":"http://yoursite.com/2020/04/23/DataStructure06/","excerpt":"","text":"该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。 第13课 - - - - - - -跳表一、跳表的定义 跳表就是链表加多级索引的动态数据结构。 二、跳表查找的时间复杂度 当每两个节点就抽出一个节点作为上级索引节点的情况下。查找一个元素的时间复杂度和二分查找相当，是O(logn)。 三、跳表查找的空间复杂度 当每两个节点就抽出一个节点作为上级索引节点的情况下。每两个元素向上提取一个元素，那么，最后额外需要的空间就是：n/2 + (n/2)^2 + (n/2)^3 + … + 8 + 4 + 2 = n - 2。所以空间复杂度为O(n)。每三个节点抽出一个节点作为上级节点的情况下复杂度为n/2虽然也是O(n)但是实际减少了一半。 四、跳表的动态插入和删除1.插入操作 首先需要找到插入节点的位置，时间复杂度为O(logn)，然后插入操作为O(1)，所以时间复杂度为O(logn)。 2.删除操作 如果需要删除的节点在索引中也出现，我们除了要删除链表里面的节点，还要删除索引中的节点。注意：如果是在单链表中，要删除一个节点首先需要拿到一个节点的前驱节点才能进行删除。 五、跳表的动态更新 当我们不停的往跳表中插入数据的时候，如果我们不添加更新索引，就会导致2个索引节点之间的数据非常多。极端情况下还会退化成单链表。导致查找的效率降低。 作为一种动态数据结构，我们需要某种手段来维护索引和原始链表大小之间的平衡。也就是说，如果链表中的节点多了，索引就相应的增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。我们通过一个随机函数来决定将这个节点插入到哪几层索引中，比如随机函数生成了值k，我们就将这个节点添加到第一级到第k级这k级索引中。 五、为什么 Redis 要用跳表来 实现有序集合，而不是红黑树? 首先，我们来分析下Redis的有序集合支持的操作：1）插入元素2）删除元素3）查找元素4）有序输出所有元素5）查找区间内所有元素其中，前4项红黑树都可以完成，且时间复杂度与跳表一致。但是，最后一项，红黑树的效率就没有跳表高了。在跳表中，要查找区间的元素，我们只要定位到两个区间端点在最低层级的位置，然后按顺序遍历元素就可以了，非常高效。而红黑树只能定位到端点后，再从首位置开始每次都要查找后继节点，相对来说是比较耗时的。此外，跳表实现起来很容易且易读，红黑树实现起来相对困难，所以Redis选择使用跳表来实现有序集合。 六、跳表的实现 后面有时间再补。","categories":[{"name":"读书系列","slug":"读书系列","permalink":"http://yoursite.com/categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构与算法之美","slug":"数据结构与算法之美","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"}]},{"title":"《数据结构与算法之美》 05 二分查找","slug":"DataStructure05","date":"2020-04-23T11:32:24.228Z","updated":"2020-04-24T09:55:35.138Z","comments":true,"path":"2020/04/23/DataStructure05/","link":"","permalink":"http://yoursite.com/2020/04/23/DataStructure05/","excerpt":"","text":"该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。 第11课 - - - - - - - 二分查找(上)一、二分查找思想 二分查找针对的是一个有序的数据集合，查找思想类似分治思想。每次都通过跟区间的中间元素对比，将查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0。 二、二分查找的时间复杂度1.二分查找的时间复杂度推导被查找的区间的大小变化为:n,n/2,n/4,n/8,…,n/(2^k),…由于每次缩小都只比较两个数的大小，所以经过k次区间缩小的操作，当区间为1的时候就是必定找到数据。即n/(2^k) = 1;其中k就是总共缩小的次数，k = logn(以2为底数),所以时间复杂度为O(logn)。 2.二分查找的递归和非递归实现非递归实现 1234567891011121314151617181920int bSearch(int * nums, int size,int value) &#123; if (nums == NULL || size &lt;= 0) &#123; return -1; &#125; int low = 0; int high = size-1; while (low &lt;= high) &#123; int mid = low + (high-low)/2; if (nums[mid] == value) &#123; return mid; &#125;else if(nums[mid] &gt; value)&#123; high = mid - 1; &#125;else if (nums[mid] &lt; value) &#123; low = mid + 1; &#125; &#125; return -1;&#125; 三个需要注意的点a.循环退出条件:low &lt;= highb.mid 取值，为了不超过int的最大值:mid = low + (high-low)/2;还可以优化成:mid = low + ((high-low)&gt;&gt;2)”这里需要注意&gt;&gt;的运算优先级和+一样所以要多加一个括号”;c.low和high的更新:low = mid + 1; high = mid - 1;递归实现 1234567891011121314151617int _bSearch2(int * nums,int low,int high,int value) &#123; if (low &gt; high) &#123; return -1; &#125; int mid = low + ((high - low)&gt;&gt;1); if (nums[mid] == value) &#123; return mid; &#125;else if(nums[mid] &gt; value) &#123; return _bSearch2(nums, low, mid - 1,value); &#125;else if(nums[mid] &lt; value) &#123; return _bSearch2(nums, mid + 1, high, value); &#125;&#125;int bSearch2(int * nums, int size,int value) &#123; return _bSearch2(nums, 0, size-1, value);&#125; 三、二分查找的应用局限性1.依赖于顺序表结构，简单点说就是数组。 二分查找每次查找的时候都依赖下标进行随机访问。数组比较合适。 2.二分查找依赖于有序数据。 如果是无序数据需要先排序，再进行查找。通常是一次排序，多次二分查找。 3.数据量太小不适合二分查找。 数据量太小，使用二分查找或者顺序遍历，查找速度差不多。 4.数据量太大不适合二分查找。 如果数据太多，不能一次性读入到连续的内存空间，就无法查找。关键是需要一片连续的内存空间。 四、如何在 1000 万个整数 中快速查找某个整数?(内存限制100MB) 100 000 000个整数，每个数据大小是8字节，那么如果把全部数据存入内存需要1000000*8/1024/1024大约等于76MB。那么我们可以通过把所有数据读入内存，然后进行二分查找。 如果使用散列表和二叉树，因为需要额外空间，所以不能实现。 五、课后题1.如何求一个数的平方根？要求精确到小数点后6位。1234567891011121314double mySqrt(int x,double t) &#123; double low &#x3D; 0; double high &#x3D; x; double mid &#x3D; high&#x2F;2.; while (high - low &gt; t) &#123; if (mid*mid &gt; x) &#123; high &#x3D; mid; &#125;else &#123; low &#x3D; mid; &#125; mid &#x3D; low + (high-low)&#x2F;2.; &#125; return mid;&#125; 两个数相乘的积去和x做比较,通过2分查找去找近似值。以精度作为结束条件。 2.用链表来存储数据，使用二分查找算法的时间复杂度是多少？ 时间复杂度为O(n)。每次比较都要找到相应的数，找到这个数需要经过的次数为第一次为 n/2第二次为 n/4…第N次为 n/(2^n)那么就是: （n/2 + n/4 + ….+n/(2^n)）/n = 1/2+1/4+….+1/(2^n) 近似n所以时间复杂度为O(n)。 第12课 - - - - - - - 二分查找(下)一、查找第一个值等于给定值的元素1234567891011121314151617181920//查找第一个xint binarySearch1(int * nums,int size,int x) &#123; int low = 0; int high = size - 1; while (low &lt;= high) &#123; int mid = low + ((high-low)&gt;&gt;1); if (x &lt; nums[mid] ) &#123; high = mid -1; &#125;else if (x &gt; nums[mid]) &#123; low = mid + 1; &#125;else if(x == nums[mid]) &#123; if (mid == 0|| nums[mid -1] != x) &#123; //在数组首位说明不存在更前的数。||前一个值不等于x return mid; &#125;else &#123;//前一个值等于x high = mid - 1; &#125; &#125; &#125; return -1;&#125; 二、查找最后一个值等于给定值的元素1234567891011121314151617181920//查找最后一个xint binarySearch2(int * nums,int size,int x) &#123; int low = 0; int high = size - 1; while (low &lt;= high) &#123; int mid = low + ((high - low)&gt;&gt;1); if (x &lt; nums[mid]) &#123; high = mid - 1; &#125;else if(x &gt; nums[mid]) &#123; low = mid + 1; &#125;else if(x == nums[mid]) &#123; if (mid == size -1 || nums[mid+1] != x) &#123; return mid; &#125;else &#123; low = mid + 1; &#125; &#125; &#125; return -1;&#125; 三、查找第一个大于等于给定值123456789101112131415161718//查找第一个大于等于x的值int binarySearch3(int * nums,int size,int x) &#123; int low = 0; int high = size -1; while (low &lt;= high) &#123; int mid = low + (( high - low ) &gt;&gt; 1); if (x &lt;= nums[mid]) &#123; if(mid == 0 || nums[mid -1] &lt; x) &#123; //前面没有更小的值 return mid; &#125;else &#123; high = mid - 1; &#125; &#125;else if(x &gt; nums[mid]) &#123; low = mid + 1; &#125; &#125; return -1;&#125; 四、查找最后一个小于等于给定值123456789101112131415161718//查找最后一个小于等于x的值int binarySearch4(int * nums,int size,int x) &#123; int low = 0; int high = size - 1; while (low &lt;= high) &#123; int mid = low + ((high - low)&gt;&gt;1); if (x &gt;= nums[mid]) &#123; if (mid == size - 1 || nums[mid + 1] &gt; x) &#123; //后一个数大于x return mid; &#125;else &#123; low = mid + 1; &#125; &#125;else if(x &lt; nums[mid]) &#123; high = mid - 1; &#125; &#125; return -1;&#125; 四、如何快速定位一个IP地址的归属地?(假设我 们有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个IP地址的归属地呢?) 第一步,将ip地址进行排序,可以把ip转换为32位的整型数。按照整型值的大小进行从小到大的排序。第二步,查询某个IP，通过二分查找，找到最后一个起始IP小于等于这个IP的IP区间，然后检查这个IP是否在这个IP的区间内，如果在，就取出相应的归属地，进行显示，如果不在就返回未找到。","categories":[{"name":"读书系列","slug":"读书系列","permalink":"http://yoursite.com/categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构与算法之美","slug":"数据结构与算法之美","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"}]},{"title":"《数据结构与算法之美》04 排序","slug":"DataStructure04","date":"2020-04-20T08:01:14.055Z","updated":"2020-04-24T09:55:29.360Z","comments":true,"path":"2020/04/20/DataStructure04/","link":"","permalink":"http://yoursite.com/2020/04/20/DataStructure04/","excerpt":"","text":"该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。 第07课 - - - - - - - 排序(上)一、排序中的一些概念1.原地排序(Sorted in place)不消耗额外的空间，空间复杂度为O(1)； 2.稳定性排序后，相等的元素之间原有的先后顺序不变，叫做稳定的排序算法，反之。 应用场景：按照金额对订单排序，相同金额的订单按照时间排序。 二、冒泡排序1.实现:12345678910111213141516171819void bubbleSort(int * nums, int size) &#123; if (size &lt;= 1) &#123; return; &#125; for (int i = 0; i &lt; size; i ++) &#123; int flag = 0;//通过添加提前退出，如果一轮都没有交换过，说明已经有序 for (int j = i+1; j &lt; size; j ++) &#123; if (nums[i] &gt; nums[j]) &#123; //不添加 = 为稳定排序算法 int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; flag = 1; &#125; &#125; if (flag == 0) &#123; break; &#125; &#125;&#125; 2.冒泡排序法是原地排序算法。 只需要常量级的临时空间，空间复杂度为O(1)，所以是原地排序算法。 3.冒泡排序法的稳定性。 当判断条件为if (nums[i] &gt; nums[j])时为稳定，为if (nums[i] &gt;= nums[j])时，为不稳定。 4.冒泡排序法的时间复杂度。 最好情况是全部有序，需要进行n次比较得出O(n)。最坏情况是倒序排列，需要进行n*(n-1)次比较得出，时间复杂度为O(n²)。 二、有序度、逆序度12//例如int nums[5] = &#123;1,5,2,4,3&#125;; 1.有序度是数组中具有有序关系的元素对个数。 其中有的有序元素对为(1,5),(1,2),(1,4),(1,3),(2,4),(2,3)为6 2.逆序度是数组中具有逆序关系的元素对个数。 其中有的逆序元素对为(5,2),(5,4),(5,3),(4,3)为4 3.完全有序的数组的有序度叫做满有序度。1int nums[5] = &#123;1,2,3,4,5&#125;; 其中有的有序元素对为(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5),为10 4.逆序度 = 满有序度 - 有序度。 类似上面 4 = 10 - 6 三、插入排序1.实现:123456789101112131415161718void insertSort (int* nums,int size) &#123; if (nums == NULL || size &lt;= 1) &#123; return; &#125; for (int i = 1; i &lt; size; i ++) &#123; int indexValue = nums[i]; //后一个位置用来比较的值。 int j = i - 1; //前面的比较队列 for (; j &gt;= 0; j -- ) &#123; if (indexValue &lt; nums[j]) &#123; //前面的数比比较值大就将前面的数向后移动。否则终止。 nums[j+1] = nums[j]; &#125;else &#123; break; &#125; &#125; nums[j+1] = indexValue; //移动以后把比较值放在合适的位置。 &#125;&#125; 2.插入排序是原地排序算法 插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1),是一个原地排序算法。 3.插入排序是稳定的排序算法 判断条件if (indexValue &lt; nums[j])的时候是稳定排序算法。 4.插入排序的时间复杂度 最好情况:当遇到一个完全有序的数据，只需要一次遍历就能完成，时间复杂度为O(n)。最坏情况:当遇到一个完全倒序的数据，每次插入都相当于在数组头插入数据即1+2+…+n所以为(n+1)*n/2即为:O(n²)。 三、选择排序1.实现:1234567891011121314151617void selectSort(int * nums,int size) &#123; if (nums == NULL || size &lt;= 1) &#123; return ; &#125; for (int i = 0; i &lt; size ; i ++) &#123; int min = i; //当前值设为最小。 for (int j = i + 1; j &lt; size; j ++) &#123; if (nums[min] &gt; nums[j]) &#123; //如果有比当前值更小的，就设置为最小 min = j; &#125; &#125; //交换当前值和最小值 int temp = nums[i]; nums[i] = nums[min]; nums[min] = temp; &#125;&#125; 2.选择排序是原地排序算法 插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1),是一个原地排序算法。 3.选择排序是不稳定的排序算法 由于每轮只交换一次，在最前面的数会被交换到后面去，所以是不稳定的排序算法。 4.选择排序的时间复杂度 不论遇到什么样的情况，选择排序中的判断if (nums[min] &gt; nums[j])始终都要执行n*(n-1)次，所以最好和最坏的时间复杂度都是O(n)。 四、冒泡排序和插入排序的时间复杂度都是O(n2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢? 冒泡排序不管怎么优化，元素交换的次数是 一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也 等于原始数据的逆序度。但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序 需要 3 个赋值操作，而插入排序只需要 1 个。所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n2)，但是如果我们希望 把性能优化做到极致，那肯定首选插入排序。 第08课 - - - - - - - 排序(下)归并排序一、实现12345678910111213141516171819202122232425262728293031323334353637383940414243void mergeArray (int * nums,int left,int mid,int right)&#123; int tempArray[right-left]; int tempArrayIndex = 0; int min_left = left; int min_right = mid+1; //两个数组比较小的放入临时数组 while (min_left &lt;= mid &amp;&amp; min_right &lt;= right) &#123; if (nums[min_left] &lt;= nums[min_right]) &#123; //《=先取前面的保证稳定性 tempArray[tempArrayIndex++] = nums[min_left ++]; &#125;else &#123; tempArray[tempArrayIndex++] = nums[min_right ++]; &#125; &#125; //把剩下没放完的放入零式数组 while (min_left &lt;= mid) &#123; tempArray[tempArrayIndex++] = nums[min_left ++]; &#125; while (min_right &lt;= right) &#123; tempArray[tempArrayIndex++] = nums[min_right ++]; &#125; //放回原数组 tempArrayIndex = 0; for (int i = left; i &lt;= right; i ++) &#123; nums[i] = tempArray[tempArrayIndex++]; &#125;&#125;void _mergeSort(int * nums,int left,int right) &#123; if (left &gt;= right) &#123; //当左边等于右边代表只有一个元素有序，需要返回。 return; &#125; //分成两份 int mid = (left+right)/2; printf(\"%d %d %d\\n\",left,mid,right); _mergeSort(nums, left, mid); _mergeSort(nums, mid+1, right); mergeArray(nums,left,mid,right);&#125;void mergeSort(int * nums,int size) &#123; _mergeSort(nums,0,size-1);&#125; 2.归并排序不是原地排序算法 归并排序需要开辟额外空间进行排序。每次开辟空间为:,且cpu运行时，一个线程，同时只有一个函数在运行,所以同一时间只会开辟一个空间。int tempArray[right-left],依次是2,…n/4,n/2,n所以空间复杂度为O(n)。 3.归并排序是稳定的排序算法 在合并数组的方法中if (nums[min_left] &lt;= nums[min_right])这里的&lt;=可以取前面的数组，所以不会造成相同元素的顺序置换，所以是稳定的排序算法。 4.归并排序的时间复杂度 不好分析。。。记得nlogn 快速排序1.实现123456789101112131415161718192021void _quickSort (int* nums,int low,int high) &#123; if (low &gt;= high) &#123; return; &#125; int value = nums[low]; int left = low; int right = high; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; nums[right] &gt;= value) &#123; right --; &#125; nums[left] = nums[right]; while (left &lt; right &amp;&amp; nums[left] &lt;= value) &#123; left++; &#125; nums[right] = nums[left]; &#125; nums[left] = value; _quickSort(nums, low, left); _quickSort(nums, left+1, high);&#125; 2.归并排序和快速排序对比 a.归并排序的处理过程是下到上，先分开然后处理合成。快速排序的处理过程是从上到下，先处理然后分开。b.快速排序按照上面的实现方法是原地排序。而归并排序则不是原地排序。 3.快速排序的性能分析 如果每次分区操作，选择的privot都能正好把数组分成大小接近相等的两个小区间，那么快排的时间复杂度为O(nlogn)。如果选择的privot不合适，每次分区我们平均要扫 描大约 n/2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n2)。(例如倒序排列的数据，每次都选第一个数。) 4.如何通过快排思想在O(n)的时间复杂度内查找第k大元素。实现 1234567891011121314151617181920212223242526272829/* 查找第k大元素。 从大到小排列，比较索引值，只执行在索引值范围内的那部分。*/int _findK(int * nums,int low,int high,int k) &#123; int value = nums[low]; int left = low; int right = high; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; nums[right] &lt;= value) &#123; right--; &#125; nums[left] = nums[right]; while (left &lt; right &amp;&amp; nums[left] &gt;= value) &#123; left++; &#125; nums[right] = nums[left]; &#125; nums[left] = value; if (left == k) &#123; return nums[left]; &#125;else if(left &lt; k) &#123; return _findK(nums, left+1, high, k); &#125;else &#123; return _findK(nums, low, left, k); &#125;&#125;int findK(int * nums,int size,int k) &#123; return _findK(nums, 0,size-1, k-1);&#125; 第09课 - - - - - - - 线性排序一、桶排序1.桶排序定义 将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数 据按照顺序依次取出，组成的序列就是有序的了。2.适用条件 条件苛刻:1.数据容易划分成各个桶;2.各个桶之间分布均匀;3.划分的桶之间有着天然的大小顺序。所以比较适合在外部排序中。 3.桶的划分 按照内存能读取的值，可以对粒度进行仔细划分。按照分布进行桶范围划分。 二、计数排序1.实现12345678910111213141516171819202122232425262728293031323334353637383940414243void countSort(int * nums,int size)&#123; //计算桶最大范围 int max = nums[0]; for (int i = 1; i &lt; size; i ++) &#123; if (max &lt; nums[i]) &#123; max = nums[i]; &#125; &#125; //创建计数桶 并初始化. int countNums[max]; for (int i = 0; i &lt;= max; i ++) &#123; countNums[i] = 0; &#125; //计算每个桶内的元素个数 for (int i = 0; i &lt; size; i ++) &#123; countNums[nums[i]]++; &#125; //生成计数桶 for (int i = 1; i &lt; size; i ++) &#123; countNums[i] = countNums[i] + countNums[i-1]; &#125; //临时桶 int temp[size]; for (int i = 0; i &lt;= size; i ++) &#123; temp[i] = 0; &#125; //排序 for (int i = size-1; i &gt;=0; i --) &#123; int num = nums[i]; //读取的数字 int countNum = countNums[num]; //计数桶中的数字 temp[countNum-1] = num; countNums[num]--; &#125; for (int i = 0; i &lt; size; i ++) &#123; nums[i] = temp[i]; &#125;&#125; 2.时间复杂度计数排序的主体: 123456for (int i = size-1; i &gt;=0; i --) &#123; int num = nums[i]; //读取的数字 int countNum = countNums[num]; //计数桶中的数字 temp[countNum-1] = num; countNums[num]--; &#125; 所以桶排序的时间复杂度为O(n); 3.适用场景 计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。 三、基数排序1.实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void _radixSort(int * nums,int size,int wei) &#123; int k = 1; while (wei &gt; 0) &#123; k *= 10; wei --; &#125; int temp[10][size]; int tempNumIndex[10] ; for (int i = 0; i &lt; 10; i ++) &#123; tempNumIndex[i] = 0; for (int j = 0; j &lt; size; j ++) &#123; temp[i][j] = 0; &#125; &#125; //放入桶中 for (int i = 0; i &lt; size; i ++) &#123; int bucket = nums[i]/k%10; temp[bucket][tempNumIndex[bucket]] = nums[i]; tempNumIndex[bucket] ++; &#125; //进行排序 int tempNums[size]; int index = 0; for (int i = 0; i &lt; 10; i ++) &#123; for (int j = 0; j &lt; tempNumIndex[i]; j ++) &#123; tempNums[index] = temp[i][j]; index ++; &#125; &#125; for (int i = 0; i &lt; size; i ++) &#123; nums[i] = tempNums[i]; &#125;&#125;void radixSort(int * nums,int size) &#123; if (nums == NULL || size &lt;= 1) &#123; return; &#125; //寻找最大值 int max = nums[0]; for (int i = 1 ; i &lt; size; i ++) &#123; if (max &lt; nums[i]) &#123; max = nums[i]; &#125; &#125; //对最大值取位 int numWei = 0; while (max != 0) &#123; max = max/10; numWei ++; &#125; //赋值回去 for (int i = 0; i &lt;= numWei; i ++) &#123; _radixSort(nums,size,i); &#125;&#125; 2.排序思路 a.找数据最大值。b.对最大值处理求出位数。c.从最低位到最高位对数据进行多轮入桶排序。d.桶排序方式：通过位数创建桶。e.对桶进行排序的时候注意保证有序。排到最高位的时候，数据就有序了。 四、如何根据年龄给100万用户排序? 问题主要考虑系统内存消耗。先按照年龄划分1-120个桶，然后遍历数据，将数据放入桶。某些桶可能人太多，可以将桶继续按照月份划分成更新的桶。如果月份还是多久继续划分。知道可以将数据读入内存。然后通过快速排序对各个桶内数据进行排序。那么桶内的数据是有序的，桶之间的元素也是有序的，就可以得到所有用户的有序数据。 第10课 - - - - - - - 排序算法优化一、如何选择合适的排序算法？ 1.对小规模的数据进行排序，可以选择时间复杂度为O(n)的算法。2.如果对大规模的数据进行排序，可以选择时间复杂度为O(nlogn)的算法。3.为了兼容任意规模的数据，一般都会首选时间复杂度是O(nlogn)的算法。4.O(nlogn)的算法中，快排最差情况下的时间复杂度为O(n²)而归并排序最差也是O(nlogn)，但是归并排序需要额外的O(n)的空间复杂度。 二、如何优化快速排序? 导致快速排序出现O(n²)出现的原因，就是因为分区点设置不合理，所以可以在分区点上做文章。尽可能的降低时间复杂度，选择的分区点最好的情况就是被分区点分开的两个区中，数据的数量差不多。 1.三数取中法 从整个区间的头尾和中间取元素，取三元素中大小在中间的数作为分区点。 2.随机法 每次从区间中随机取一个元素,在平均情况下这样分区，可以降低时间复杂度退化为最糟糕的O(n²)的可能性。 三、glibc-&gt;qsort.c的实现1.源码 以下源码分析,来自知乎,作者:丁冬。直达链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271/*首先实现qsort需要有一个swap：*/#define SWAP(a, b, size) do &#123; size_t __size = (size); char *__a = (a), *__b = (b); do &#123; char __tmp = *__a; *__a++ = *__b; *__b++ = __tmp; &#125; while (--__size &gt; 0); &#125; while (0)/*为了阅读方便，我把用于宏定义续行用的\\去掉了，方便看到语法高亮。SWAP的定义很简单，只是以char为单位长度进行交换。实际上，对于足够大的对象，这里还有一定的优化空间，但qsort不能假定你的对象足够大。这也是qsort统计性能不如C++的std::sort的原因之一。所谓qsort并不是单纯的快速排序，当快速排序划分区间小到一定程度时，改用插入排序可以在更少的耗时内完成排序。glibc将这个小区间定义为元素数不超过常数4的区间：*/#define MAX_THRESH 4/*可以认为对每一个小区间的插入排序耗时是不超过一个常数值（即对4个元素进行插入排序的最差情况）的，这样插入排序总耗时也可以认为是线性的，不影响总体时间复杂度。接下来这段不难理解：*/typedef struct &#123; char *lo; char *hi; &#125; stack_node;#define STACK_SIZE (CHAR_BIT * sizeof(size_t))#define PUSH(low, high) ((void) ((top-&gt;lo = (low)), (top-&gt;hi = (high)), ++top))#define POP(low, high) ((void) (--top, (low = top-&gt;lo), (high = top-&gt;hi)))#define STACK_NOT_EMPTY (stack &lt; top)/*这显然是要手动维护栈来模拟递归，避免实际递归的函数调用开销了。题主自己的实现在元素数量过多的时候会崩溃，估计就是递归过深爆栈了。比较值得一提的是STACK_SIZE的选择。由于元素数量是由一个size_t表示的，size_t的最大值应该是2 ^ (CHAR_BIT * sizeof(size_t))，快速排序的理想“递归”深度是对元素总数求对数，所以理想的“递归”深度是CHAR_BIT * sizeof(size_t)。虽然理论上最差情况下“递归”深度会变成2 ^ (CHAR_BIT * sizeof(size_t))，但是一方面我们不需要从头到尾快速排序（区间足够小时改用插入排序），另一方面，我们是在假设元素数量等于size_t的上限...这都把内存给挤满了=_=所以最后glibc决定直接采用理想“递归”深度作为栈大小上限。接下来该进入qsort的正文了：*/void_quicksort (void *const pbase, size_t total_elems, size_t size, __compar_d_fn_t cmp, void *arg)&#123;/*qsort实际上是通过调用这个_quicksort实现的。最后的arg是个workaround，用来搞定qsort_r的。暂且不去理会。下面是一些准备工作：*/ char *base_ptr = (char *) pbase; const size_t max_thresh = MAX_THRESH * size; if (total_elems == 0) return;/*明确了对内存操作是以sizeof(char)为单位的。max_thresh实际上是改用插入排序时，维护当前区间的两个指针（类型均为char*）之间的距离。另外，如果元素数量为0，qsort啥也不干，函数直接返回。*/ if (total_elems &gt; MAX_THRESH) // 如果元素数大于终止区间（4个元素），则进行快速排序 &#123; char *lo = base_ptr; char *hi = &amp;lo[size * (total_elems - 1)]; stack_node stack[STACK_SIZE]; stack_node *top = stack; PUSH (NULL, NULL);/*开始维护“递归”栈*/ while (STACK_NOT_EMPTY) &#123; char *left_ptr; char *right_ptr;/*这里采用的是中值划分，用于降低特定序列导致递归恶化影响。也就是说，对区间里的首元素、中间元素和尾元素先进行排序。排序方式是...呃，是冒泡。反正也就3个元素嘛。*/ char *mid = lo + size * ((hi - lo) / size &gt;&gt; 1); if ((*cmp) ((void *) mid, (void *) lo, arg) &lt; 0) SWAP (mid, lo, size); if ((*cmp) ((void *) hi, (void *) mid, arg) &lt; 0) SWAP (mid, hi, size); else goto jump_over; if ((*cmp) ((void *) mid, (void *) lo, arg) &lt; 0) SWAP (mid, lo, size); jump_over:;/*接下来就要进行快排划分了：*/ left_ptr = lo + size; right_ptr = hi - size; do &#123; while ((*cmp) ((void *) left_ptr, (void *) mid, arg) &lt; 0) left_ptr += size; while ((*cmp) ((void *) mid, (void *) right_ptr, arg) &lt; 0) right_ptr -= size;/*和传统的划分方式不同，首先把中间当作键值在左侧找到一个不小于mid的元素，右侧找到一个不大于mid的元素*/ if (left_ptr &lt; right_ptr) &#123; SWAP (left_ptr, right_ptr, size); if (mid == left_ptr) mid = right_ptr; else if (mid == right_ptr) mid = left_ptr; left_ptr += size; right_ptr -= size; &#125;/*如果左右侧找到的不是同一个元素，那就交换之。如果左右侧任意一侧已经达到mid，就把mid往另一边挪。因为键值已经被“丢”过去了。*/ else if (left_ptr == right_ptr) &#123; left_ptr += size; right_ptr -= size; break; &#125; &#125;/*如果左右侧是同一元素，划分其实已经大功告成了。*/ while (left_ptr &lt;= right_ptr);/*接下来，将划分出来的所有大于的终止区间的区间压入栈准备下一次划分，连这里都会发生丧心病狂的优化...不能浪费已经在栈里的原区间上下界=_=*/ if ((size_t) (right_ptr - lo) &lt;= max_thresh) &#123; if ((size_t) (hi - left_ptr) &lt;= max_thresh) POP (lo, hi); else lo = left_ptr; &#125; else if ((size_t) (hi - left_ptr) &lt;= max_thresh) hi = right_ptr; else if ((right_ptr - lo) &gt; (hi - left_ptr)) &#123; PUSH (lo, right_ptr); lo = left_ptr; &#125; else &#123; PUSH (left_ptr, hi); hi = right_ptr; &#125; &#125; &#125;/*至此快速排序工作结束。*/#define min(x, y) ((x) &lt; (y) ? (x) : (y)) // 头一回学宏“函数”都应该见过这货吧/*接下来是插入排序*/ &#123;/*众所周知，传统的插入排序中每一趟插入（假设是向前插入），我们都会迭代有序区间，如果已经迭代到了区间头部，那就把该元素插在区间首部；否则如果前一个元素不大于待插入元素，则插在该元素之后。这种插入方式会导致每一次迭代要进行两次比较：一次比较当前迭代位置与区间首部，一次比较两个元素大小。但事实上，我们可以用一个小技巧省掉前一次比较————插入排序开始前，先将容器内最小元素放到容器首部，这样就可以保证每趟插入你永远不会迭代到区间首部，因为你总能在中途找到一个不小于自己的元素。注意，如果区间大于终止区间，搜索最小元素时我们不必遍历整个区间，因为快速排序保证最小元素一定被划分到了第一个终止区间，也就是头4个元素之内。*/ char *const end_ptr = &amp;base_ptr[size * (total_elems - 1)]; char *tmp_ptr = base_ptr; char *thresh = min(end_ptr, base_ptr + max_thresh); char *run_ptr; for (run_ptr = tmp_ptr + size; run_ptr &lt;= thresh; run_ptr += size) if ((*cmp) ((void *) run_ptr, (void *) tmp_ptr, arg) &lt; 0) tmp_ptr = run_ptr; if (tmp_ptr != base_ptr) SWAP (tmp_ptr, base_ptr, size);/*准备工作完毕，这下可以放心地干掉迭代位置的比较了。*/ run_ptr = base_ptr + size; while ((run_ptr += size) &lt;= end_ptr) &#123; tmp_ptr = run_ptr - size; while ((*cmp) ((void *) run_ptr, (void *) tmp_ptr, arg) &lt; 0) tmp_ptr -= size; tmp_ptr += size; if (tmp_ptr != run_ptr) &#123; char *trav; trav = run_ptr + size; while (--trav &gt;= run_ptr) &#123; char c = *trav; char *hi, *lo; for (hi = lo = trav; (lo -= size) &gt;= tmp_ptr; hi = lo) *hi = *lo; *hi = c; &#125; &#125; &#125; &#125;&#125;/*至此，qsort工作完成。*/ 2.glibc-&gt;qsort.c内部逻辑 1.先判断元素个数，如果个数大于MAX_THRESH(4)个则进行快速排序，如果小于MAX_THRESH(4)个则进行插入排序。2.快速排序的时候，会手动维护一个递归栈。快排的划分的基准通过中值划分，前中后三个数，通过冒泡排序进行排序，找到中值作为快速排序的划分基准。","categories":[{"name":"读书系列","slug":"读书系列","permalink":"http://yoursite.com/categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构与算法之美","slug":"数据结构与算法之美","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"}]},{"title":"《数据结构与算法之美》03 递归","slug":"DataStructure03","date":"2020-04-20T06:56:17.097Z","updated":"2020-04-24T09:55:21.104Z","comments":true,"path":"2020/04/20/DataStructure03/","link":"","permalink":"http://yoursite.com/2020/04/20/DataStructure03/","excerpt":"","text":"该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。 第06课 - - - - - - - 递归递归 递归就是一个函数在它的函数体内调用它自身。 一、递归需要满足的三个条件1、一个问题的解可以分为几个子问题的解2、这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样3、存在递归终止条件二、如何编写递归代码1.写出递推公式2.找出终止条件三、递归代码要警惕堆栈溢出一般通过改写为非递归来解决堆栈溢出问题。 四、递归代码要警惕重复计算一般通过添加一张散列表来记录已经计算的递归值。 五、怎么将递归代码改写为非递归代码123int f(int n) &#123; return f(x-1) + 1;&#125; 改为 123456int f(int n)&#123; for ret = 1; for (int i = 2; i &lt; n; i ++) &#123; ret = ret + 1; &#125;&#125; 只能一步或者两步，上N层楼梯方式有多少种 12345int f(int n) &#123; if(n == 1) return 1; if(n == 2) return 2; return f(n-1) + f(n-2);&#125; 改为 12345678910111213int f2(int n) &#123; if(n == 1) return 1; if(n == 2) return 2; int ret = 0; int num1 = 1; int num2 = 2; for (int i = 3 ; i &lt;= n ; i ++) &#123; ret = num1 + num2; num1 = num2; num2 = ret; &#125; return ret;&#125; 所有的递归都可以改为迭代循环的非递归写法。但是实际上只是将递归改为手动递归，本质没有改变，还增加了实现的复杂度。 六、如果通过三行代码找到最终推荐人12345long findRootReferrerId(long actorId) &#123; 推荐人id = select 推荐人id = from [table] where 用户id = actorId; if(推荐人id == NULL) return 用户id; return findRootReferrerId（推荐人id）；&#125; 七、其他问题1.如果递归很深，可能会有堆栈溢出问题。 可以通过改写为非递归实现来解决。 2.递归环调用出现环。 添加构造一个set集合或者散列表，通过保存调用记录，来比较新的调用记录是否存在。","categories":[{"name":"读书系列","slug":"读书系列","permalink":"http://yoursite.com/categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构与算法之美","slug":"数据结构与算法之美","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"}]},{"title":"《数据结构与算法之美》02 栈 & 队列","slug":"DataStructure02","date":"2020-04-17T07:54:22.973Z","updated":"2020-04-24T09:55:16.661Z","comments":true,"path":"2020/04/17/DataStructure02/","link":"","permalink":"http://yoursite.com/2020/04/17/DataStructure02/","excerpt":"","text":"该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。 第04课 - - - - - - - 栈栈一、如何理解栈 其实就是FILO，先进后出，”操作受限”的线性表 当某个数据结合只涉及在一端插入和删除数据，并且满足后进先出，先进后出的特性，我们就应该首选”栈”。 二、如何实现栈1.用数组实现栈，叫做顺序栈2.用链表实现的栈，我们叫做链式栈3.支持动态扩容的顺序栈每次栈满之后，扩充栈的存储空间。平均每耗时的操作复杂度也为O(1),使用的方法叫做均摊法。即把所有操作均摊到每次操作上。 三、栈在函数调用中的应用1.函数调用栈2.编译器如何利用栈来实现表达式求值 通过两个栈来实现、一个栈保存操作数，一个栈保存运算符。从左向右遍历表达式，当遇到数字的时候直接压入操作数栈。当遇到运算符，就与运算符栈的栈顶元素进行比较，如果比栈顶元素的运算优先级高，就将当前运算符压入栈；如果比栈顶元素的运算优先级低或者相同，就从运算符栈顶取栈顶运算符，从操作数栈顶取2个操作数，然后进行计算，再把计算结果压入操作数栈。然后继续向右遍历，继续操作，直到结束。 四、栈在括号匹配中的应用 我们利用栈来保存未匹配的左括号，从左到右依次扫描字符串，如果扫描到左括号就进行入栈操作。当扫描到又括号就取出栈顶的左括号进行比较，如果一致就继续向下扫描。如果不一致，或者栈顶没有元素则匹配失败。 五、如何实现网页快进、后退功能 1.用两个栈来实现，一个当前页面来实现。2.一个保存后退页面栈stack_back，一个保存前进页面栈stack_go。3.当相应的栈空时，限制进行前进后退操作。4.当发生后退操作时，将当前页面入栈stack_go,从stack_back取栈顶元素作为当前页面。5.当发生前进操作时，将当前页面入栈stack_back,从stack_go取栈顶元素作为当前页面。 第05课 - - - - - - - 队列队列一、如何理解队列 队列也是操作受限的线性表，限制为：FIFO(先进先出)。队列支持两个基本操作:入队enqueue()向队尾添加一个元素,出队dequeue()从队头取出一个元素。 二、顺序队列和链式队列1.用数组实现的队列叫顺序队列12345678910111213141516171819202122232425262728293031323334S_queue * createQueue(int * nums,int size,int max) &#123; S_queue * squeue = (S_queue*)malloc(sizeof(S_queue)); int * queueArray = (int*)malloc(sizeof(int)*max); memcpy(queueArray,nums,size); squeue-&gt;innerArray = queueArray; squeue-&gt;head = 0; squeue-&gt;tail = size; squeue-&gt;max = max; return squeue;&#125;int enqueue(S_queue * queue,int item) &#123; if (queue-&gt;tail == queue-&gt;max) &#123; if (queue-&gt;head == 0) &#123; return -1; &#125; int max = queue-&gt;tail - queue-&gt;head; for (int i = 0; i &lt; max; i++) &#123; queue-&gt;innerArray[ i ] = queue-&gt;innerArray[ queue-&gt;head + i ]; &#125; queue-&gt;head = 0; queue-&gt;tail = max-1; &#125; queue-&gt;tail ++; *(queue-&gt;innerArray+queue-&gt;tail) = item; return 0;&#125;int dequeue(S_queue* queue,int * item) &#123; if (queue-&gt;head == queue-&gt;tail) &#123; return -1; &#125; * item = *(queue-&gt;innerArray+queue-&gt;head); queue-&gt;head ++; return 0;&#125; 需要注意当列表末尾没有空间，而底层数组有空间的时候，需要进行数据搬移（在入队的时候进行）。 2.用链表实现的队列叫链式队列1234567891011121314151617181920212223242526typedef struct Link_Queue_Node &#123; struct Link_Queue_Node * next; int data;&#125;Node;typedef struct Link_Queue&#123; Node * head; Node * tail;&#125;LQueue;Node * createNode (int data)&#123; Node * node = (Node*)malloc(sizeof(Node)); node-&gt;data = data; return node;&#125;void enqueue(LQueue * queue,int data) &#123; Node * node = createNode(data); queue-&gt;tail-&gt;next = node;&#125;Node * dequeue(LQueue * queue, int data) &#123; Node * node = queue-&gt;head; queue-&gt;head = queue-&gt;head-&gt;next; return node;&#125; 三、循环队列当用数组来实现队列，tail == n的时候，会有数据搬移操作，这样入队操作性能会受到影响。可以通过循环队列来避免数据搬移。 1234567891011121314151617int enqueue(S_queue * queue,int item) &#123; if ((queue-&gt;tail + 1) % queue-&gt;max == queue-&gt;head) &#123; return -1; &#125; *(queue-&gt;innerArray+queue-&gt;tail) = item; queue-&gt;tail = (queue-&gt;tail+1)%queue-&gt;max; return 0;&#125;int dequeue(S_queue * queue , int * item) &#123; if (queue-&gt;head == queue-&gt;tail) &#123; return -1; &#125; *item = *(queue-&gt;innerArray+queue-&gt;head); queue-&gt;head = (queue-&gt;head + 1)%queue-&gt;max; return 0;&#125; 四、阻塞队列和并发队列1.阻塞队列就是在队列的基础上增加了阻塞操作。 当队列为空的时候，取数据操作，会被阻塞。当队列满的时候，插入数据操作会被阻塞。这就是一个”生产者-消费者模型“。 2.并发队列就是线程安全的队列。 a.最简单的实现方式就是在enqueue()和dequeue()操作上面加锁。b.基于数组的循环队列，利用CAS(Compare And Swap)原子操作，可以实现非常高效的并发队列。(这也是循环队列比链式队列应用更加广泛的原因) 引申:CAS，即比较内存地址的当前值和期望值保证了交换操作基于最新值。如果其他线程修改了内存地址的值并且与期望值不同则造成CAS操作失败。 12345678//C代码描述 CASint compare_and_swap (int* reg, intoldval, intnewval)&#123; int old_reg_val = *reg; if(old_reg_val == oldval) *reg = newval; return -1;&#125; 五、线程池没有空闲线程时，新的任务请求资源时，线程该如何处理？一般有两种处理策略: 1.非阻塞方式处理。通过直接拒绝任务请求进行处理。2.阻塞方式处理。讲请求进行排队，等有空闲的时候，取出排队的线程处理。 a.基于链表实现的方式，可以实现一个支持无线排队的无界队列，但是可能会导致过多的请求排队等待，请求处理的响应时间过长。针对时间比较敏感的应用，该中方法不合适。b.基于数组实现的方式，可以实现一个有界队列。队列的大小有限，所以线程池中排队的请求多于队列大小的时候，接下来的请求就会被拒绝。这种方式适合时间敏感的应用。设置队列的大小，会产生不同效果。队列太大，导致等待请求太多，响应不及时，队列太小导致无法充分利用系统资源，发挥最大性能。","categories":[{"name":"读书系列","slug":"读书系列","permalink":"http://yoursite.com/categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构与算法之美","slug":"数据结构与算法之美","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"}]},{"title":"《数据结构与算法之美》01 数组 & 链表","slug":"DataStructure01","date":"2020-04-16T01:39:05.640Z","updated":"2020-04-25T01:09:47.173Z","comments":true,"path":"2020/04/16/DataStructure01/","link":"","permalink":"http://yoursite.com/2020/04/16/DataStructure01/","excerpt":"","text":"该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。 第01课 - - - - - - - 数组 数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 特点：1、数据排成像一条线一样的结构，属于线性表。(线性表中除了数组还有队列、栈、链表等。与之相对的概念就是非线性表，比如二叉树、堆、图等。) 2、连续的内存空间和相同的数据类型。(因为有这两个限制，所以可以实现通过下表就能访问元素的随机访问机制。) 3、高效的随机访问。随机访问第k个元素，可以通过数组下标直接访问，时间复杂度为O(1)。 4、低效的插入删除操作(在某个位置插入和删除一个元素、则需要将这个位置之后的元素都向后或者向前移动一位。普通插入和删除操作的时间复杂度为：(1+2+…+n)/n = O(n)。插入操作如果是无序的应用场景下，可以通过给某个位置的元素赋值，并把这个元素添加到数组末尾，这种情况下时间复杂度为O(1);删除操作如果在不追求数据的连续性应用场景下，可以通过标记已经删除的数据，把多次删除的操作集中在内存空间不足的时候一起执行，可以提高删除效率。 警惕数组访问越界例子12345678int main(int argc,char* argv[])&#123; int i = 0; int arr[3] = &#123;0&#125;; for( ; i &lt;= 3; i++ )&#123; arr[i] = 0; printf(\"hello world\\n\"); &#125;&#125; 在这个例子中，arr[3]对应的地址和i一样，所以对相当于i = 0；所以会无限循环。 原理：在C语言函数调用的时候，栈帧存储的时候，C语言会对其进行优化，提高CPU访问数据的效率，如果保证8字节对齐，那么就可以用一个存储器操作来读或者写值。在题目中一个int占用4个字节和占用12字节arr数组外加一个int i合起来就是2个8字节，实现了字节对齐。先分配了数组的内存空间，接着分配了i的内存空间，所以i分配的内存地址刚好是arr[3]; 容器能代替数组吗写业务可以牺牲一点性能，直接使用容器，优势是不需要处理扩容等问题。写底层，使用数组会得到更高的性能。 为什么数组下标从0开始?因为当数组arr下标从0开始的时候第x个元素的时候，传入arr+xsizeof(type)就可以访问到。因为当数组arr下标从1开始的时候第x个元素的时候，传入arr+(x-1)sizeof(type)就可以访问到。cpu会减少一次-1操作。 第02课 - - - - - - - 链表(上)一、链表相关概念1、链表链表是通过指针将一组零散的内存块串联起来使用。根据指针多少和指向可以分为:单链表、双向链表和循环链表等。 2、链表组成被串联的内存块称为“节点”,习惯性的把第一个节点叫做“头结点”,把最后一个节点叫做“尾结点”，记录上个节点地址的指针叫做“前驱指针prev”,记录下个节点地址的指针叫做“后继指针next”。 3、链表插入删除操作时间复杂度链表插入一个节点，删除一个节点所需操作的时间复杂度为O(1); 4、链表随机访问时间复杂度链表随机访问第k个元素，就需要通过遍历才能访问到，所以时间复杂度为O(n)。 5、循环链表循环链表就是尾结点的next指针指向头结点的单链表。当处理的数据具有环形结构特点的时候，特别适合采用循环链表。例如约瑟夫问题。 6、双向链表双向链表的每个节点都具有两个指针，分别指向前驱节点和后继节点。带来了存储空间浪费，但是支持双向遍历。为操作带来了灵活性。可以在O(1)的时间复杂度下找到前驱节点。双向链表的优势场景:a、当已经拿到了某节点，要删除该节点，或者增加前驱节点的时候，双向链表可以直接删除或者增加，但是单向链表需要先遍历找到前驱节点才能进行删除和增加。b、在一个有序链表中，可以通过记录上一次查找的位置，然后根据值比较的关系，决定向前查找还是向后查找，平均只需要查找一半的数据。实际上，链表通过空间换时间的设计思想，提高了某些情况下的操作时间复杂度。 7、双向循环链表就是双向链表的头节点前驱指针prev指向尾节点。尾节点的后继指针next指向头结点。 8、链表和数组性能分析数组适合随机访问，时间复杂度为O(1)，插入删除操作的时间复杂度为O(n)。链表适合插入删除，时间复杂度为O(1)，随机访问操作的时间复杂度为O(n)。我们再实际开发中针对不同项目要具体分析用什么数据结构。 二、如何实现LRU缓存淘汰算法缓存淘汰策略，常见的有三种:先进先出策略FIFO(First In,First Out)、最少使用策略LFU(Least Frequently Used)、最近最少使用策略LRU(Least Recently Used)。 使用链表实现LRU步骤： 1.维护一个有序的单链表，越靠近链表尾部的节点就是越早之前访问的。当有一个新的数据被访问的时候，我们从链表头开始顺序遍历离链表。2.如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的节点，并将其原来的位置删除，然后再插入到链表头部。3.如果此数据没有再缓存链表中，又可以分为两种情况:1).如果此时缓存未满，则将此节点直接插入到链表的头部；2).如果此时缓存已满，则删除链表的尾节点，然后将新的数据节点插入链表的头部。 实现代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758typedef struct Lru_Cache_Node &#123; struct Lru_Cache_Node* next; void* data;&#125;Lru_Node;typedef struct Lru_Cache_List &#123; Lru_Node * header; //头结点 int currentSize; //当前缓存大小 int maxSize; //最大缓存大小&#125;Lru_List;int accessData(void* access_data,Lru_List * list,uint size) &#123; // 判断是否可以进行操作。 if (access_data == NULL || list == NULL || list-&gt;header == NULL || list-&gt;header-&gt;data == NULL) &#123; return -1; &#125; // 如果操作的缓存为头结点则直接缓存 if (list-&gt;header-&gt;data == access_data) &#123; return 0; &#125; // 遍历寻找链表 Lru_Node * node = list-&gt;header; int find_flag =0; Lru_Node * findNode_pre = node; node = node-&gt;next; do &#123; if (node-&gt;data == access_data) &#123; break; &#125; findNode_pre = node; node = node-&gt;next; find_flag ++; &#125; while (node != NULL); //找到对应节点 if (find_flag &lt; list-&gt;currentSize) &#123; findNode_pre-&gt;next = node-&gt;next; //删除节点 node-&gt;next = list-&gt;header; //添加头结点 list-&gt;header = node; node-&gt;data = access_data; return 0; &#125; // 未找到对应节点 // 缓存未满 if (list-&gt;currentSize &lt; list-&gt;maxSize) &#123; Lru_Node * newNode = (Lru_Node *)malloc(sizeof(Lru_Node)); newNode-&gt;next = list-&gt;header; list-&gt;header = newNode; newNode-&gt;data = access_data; return 0; &#125; // 缓存已满 node-&gt;next = list-&gt;header; // node节点就是遍历到最后的尾节点，直接赋值为头结点。 list-&gt;header = node-&gt;next; node-&gt;data = access_data; findNode_pre-&gt;next = NULL; // 删除尾节点。 return 0;&#125; 三、使用数组实现LRU缓存淘汰策略方式一：首位置保存最新访问数据，末尾位置优先清理 当访问的数据未存在于缓存的数组中时，直接将数据插入数组第一个元素位置，此时数组所有元素需要向后移动1个位置，时间复杂度为O(n)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入数组的第一个位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉末尾的数据，时间复杂度为O(1)。 方式二：首位置优先清理，末尾位置保存最新访问数据 当访问的数据未存在于缓存的数组中时，直接将数据添加进数组作为当前最有一个元素时间复杂度为O(1)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入当前数组最后一个元素的位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉数组首位置的元素，且剩余数组元素需整体前移一位，时间复杂度为O(n)。（优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。） 四、使用单链表判断回文字符串 1.使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步2.在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。3.最后比较中点两侧的链表是否相等 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758typedef struct Link_Node &#123; struct Link_Node*next; char data;&#125;Node;typedef struct Link_List &#123; Node * header;&#125;List;void deallocList (List * list)&#123; Node * node = NULL; while (list-&gt;header != NULL) &#123; node = list-&gt;header; list-&gt;header = list-&gt;header-&gt;next; free(node); &#125;&#125;int isPalindrome(char * string) &#123; if (string == NULL || sizeof(string) &lt;= 1) &#123; return -1; &#125; List list; Node * lastNode = NULL; for (int i = 0; i &lt; strlen(string); i ++) &#123; Node * node = (Node*)malloc(sizeof(Node)); node-&gt;data = string[i]; if (list.header == NULL) &#123; list.header = node; &#125;else &#123; lastNode-&gt;next = node; &#125; lastNode = node; &#125; Node * fast = list.header; Node * slow = list.header; Node * slowPre = NULL; while ( fast != NULL &amp;&amp; fast-&gt;next != NULL ) &#123; fast = fast-&gt;next-&gt;next; Node * tempNode = slow-&gt;next; slow-&gt;next = slowPre; slowPre = slow; slow = tempNode; &#125; //单数个 if (fast != NULL) &#123; slow = slow-&gt;next; &#125; //偶数个 while (slow != NULL) &#123; if (slow-&gt;data != slowPre-&gt;data) &#123; deallocList(&amp;list); return -2; &#125; slow = slow-&gt;next; slowPre = slowPre-&gt;next; &#125; deallocList(&amp;list); return 0;&#125; 第03课 - - - - - - - 链表(下)一、正确理解指针 指针就是一个特别一点的变量，其值为一个内存地址。 二、警惕指针丢失和内存泄漏 插入结点时，一定要注意操作的顺序。删除链表结点时，也一定要记得手动释放内存空间 三、利用哨兵简化实现难度1.当执行插入操作的时候，如果是一个空链表，需要执行的操作为:123if (head == NULL) &#123; head = new_node;&#125; 2.当执行删除操作的时候，如果是一个删除最后一个节点，需要执行的操作为:123if (head-&gt;next == NULL) &#123; head = NULL;&#125; 针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。遇到这两种情况的时候，可以通过引入哨兵节点，来让这两种情况都和普通节点有相同的处理方法。 3.解决问题可以通过对链表添加一个具有空数据的哨兵节点，在任何时候，不管链表是不是空，head都会一直指向这个哨兵节点。这种链表就叫带头链表。 四、重点留意边界条件处理 检查逻辑:1.如果链表为空时，代码是否能正常工作?2.如果链表只包含一个结点时，代码是否能正常工作?3.如果链表只包含两个结点时，代码是否能正常工作?4.代码逻辑在处理头结点和尾结点的时候，是否能正常工作? 五、举例画图，辅助思考六、多写多练，其义自见以下链表需要熟练掌握，可以直接死记硬背，手写: 基础结构体12345678typedef struct Link_Node &#123; struct Link_Node * next; int data;&#125;Node;typedef struct Link_List &#123; Node * head;&#125;List; 1.单链表反转123456789101112131415161718//翻转列表void reverseList (List * list) &#123; if (list == NULL || list-&gt;head == NULL) &#123; return; &#125; Node * currentHead = NULL; //反转多出来的列表的头。 while (list-&gt;head != NULL) &#123; //保存新头 Node * newHead = list-&gt;head-&gt;next; //反转 list-&gt;head-&gt;next = currentHead; //赋值多出来的列表头 currentHead = list-&gt;head; //赋值新头 list-&gt;head = newHead; &#125; list-&gt;head = currentHead;&#125; 2.链表中环的检测123456789101112131415int hasCycleInList(List * list) &#123; if (list == NULL || list-&gt;head == NULL) &#123; return -1; &#125; Node * fast = list-&gt;head;//快指针 Node * slow = list-&gt;head;//慢指针 while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) &#123; return 0; &#125; &#125; return -2;&#125; 3.两个有序的链表合并123456789101112131415161718192021222324252627List * mergeList(List *la,List *lb) &#123; List * resultList = (List*)malloc(sizeof(List)); resultList-&gt;head = (Node*)malloc(sizeof(Node)); Node * node_a = la-&gt;head; Node * node_b = lb-&gt;head; Node * offsetNode = resultList-&gt;head; while (node_a != NULL &amp;&amp; node_b != NULL) &#123; if (node_a-&gt;data &lt; node_b-&gt;data) &#123; offsetNode-&gt;next = node_a; node_a = node_a-&gt;next; &#125;else &#123; offsetNode-&gt;next = node_b; node_b = node_b-&gt;next; &#125; offsetNode = offsetNode-&gt;next; &#125; if (node_a != NULL) &#123; offsetNode-&gt;next = node_a; &#125; if (node_b != NULL) &#123; offsetNode-&gt;next = node_b; &#125; resultList-&gt;head = resultList-&gt;head-&gt;next; return resultList;&#125; 4.删除链表倒数第 n 个结点123456789101112131415161718192021int deleteNode(List * list,int n) &#123; if (list == NULL) &#123; return -1; &#125; Node * fast = list-&gt;head; while (n-- &amp;&amp; fast != NULL) &#123; fast = fast-&gt;next; &#125; if (fast == NULL) &#123; return -2; &#125; Node * low = list-&gt;head; while (fast-&gt;next != NULL) &#123; fast = fast-&gt;next; low = low-&gt;next; &#125; Node * deleteNode = low-&gt;next; low-&gt;next = low-&gt;next-&gt;next; free(deleteNode); return 0;&#125; 5.求链表的中间结点123456789101112Node * findMiddleNode( List * list ) &#123; if (list == NULL ||list-&gt;head == NULL) &#123; return NULL; &#125; Node * fast = list-&gt;head; Node * slow = list-&gt;head; while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; return slow;&#125;","categories":[{"name":"读书系列","slug":"读书系列","permalink":"http://yoursite.com/categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构与算法之美","slug":"数据结构与算法之美","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"}]},{"title":"排序算法总结","slug":"Sort","date":"2020-04-15T01:44:48.053Z","updated":"2020-04-24T09:56:21.153Z","comments":true,"path":"2020/04/15/Sort/","link":"","permalink":"http://yoursite.com/2020/04/15/Sort/","excerpt":"","text":"排序算法分类 1.基于比较来划分排序算法可以将算法分为两大类：比较和非比较。由于任何通过比较来排序算法至少要进行n*logn次才能排完，并且理论上不存在更快的比较排序算法。所以也用非线性时间比较排序来命名，另一类就是线性的非比较排序。2.在非线性时间比较排序算法中，又通过比较后对数据处理操作的不同分为：交换排序、插入排序、选择排序、归并排序。3.在线性时间非比较排序算法中，可以分为计数排序、桶排序、基数排序。 十大排序算法分类 十大排序算法时间复杂度 冒泡排序 先看一个物理现象：水沸腾时，在水的底部形成的气泡上升，上升过程中体积逐渐变大，到水面破裂开，里面的水蒸气散发到空气中。从这个物理现象可以抽象为气泡从水底上升，过程中提及逐渐变大。两个相邻的数互相比较，如果前一个数大于后一个数，就交换两个数位置，然后继续比较后面两个数的位置。经过一轮比较得到一个最大值，再将剩下的数进行一轮轮比较，就能得到一个有序数列。这个排序的过程一轮就像一次冒泡一样，于是命名了冒泡排序法。 代码实现123456789for i in 0 ... array_num.count-1 &#123; //运行N轮 for j in 0 ..&lt; array_num.count-1-i &#123; //每轮比较N-1次 if (array_num[j] &gt; array_num[j+1]) &#123; //每次前面的数比后面的大交换位置 比较n*(n-1)次 let temp = array_num[j] array_num[j] = array_num[j+1] array_num[j+1] = temp &#125; &#125;&#125; 快速排序","categories":[{"name":"算法总结","slug":"算法总结","permalink":"http://yoursite.com/categories/234/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"H.264码流 MP4封装格式的理解","slug":"H264-MP4","date":"2020-04-14T12:58:51.363Z","updated":"2020-04-15T09:28:13.350Z","comments":true,"path":"2020/04/14/H264-MP4/","link":"","permalink":"http://yoursite.com/2020/04/14/H264-MP4/","excerpt":"","text":"H.264 H.264，又称为MPEG-4第10部分，高级视频编码是一种面向块，基于运动补偿的视频编码标准。H.264/AVC项目的目的是为了创建一个更佳的视频压缩标准，在更低的比特率的情况下依然能够提供良好视频质量的标准。 MP4 MP4或称MPEG-4第14部分是一种标准的数字多媒体容器格式。MPEG-4第14部分的扩展名为.mp4，以存储数字音频及数字视频为主，但也可以存储字幕和静止图像。因其可容纳支持比特流的视频流（如高级视频编码），MP4可以在网络传输时使用流式传输。 MP4封装MP4视频其实就是一系列的画面，通过压缩算法压缩以后，通过MP4封装协议打包成一个整体的文件（其后缀名为.mp4）。 MP4的封装打包类似于收纳盒。一个个的box，其中存储不同的数据。大盒子装小盒子，可以多层嵌套。通过MP4解析网站对MP4视频的盒子进行逐个分析：可以将整个MP4文件理解为最大的盒子，其中第一层打开以后有四个盒子：分别是ftype、moov、free、mdat。 一、ftyp其中的具体存储数据为: 12000000206674797069736f6d00000200 69736f6d69736f32617663316d703431....ftypisom....isomiso2avc1mp41 具体就是:ftyp，每个MP4文件只有一个。其中Box type就是盒子的类型，Major brand、Minor version 以及compatible brands都是这个MP4文件的封装信息。他们共同描述了MP4文件使用了什么样的封装子格式。 二、moovmoov即Movie Box，每个MP4文件也只有一个，一般都跟在ftyp之后。moov包含4个box，分别是:mvhd、trak、trak、udta。 1、mvhdmvhd：即Movie Header Box，包含了视频媒体信息，视频时长、创建时间等。 2、traktrak: 即Track Box，包含三个box，分别是tkhd、edts、mdia 2.1、tkhdtkhd:即track header box，包含了track信息，track id、如果是视频track包含视频宽高，如果是音频track则包含音频流长度、等信息。 2.2、edtsedts:内部包含一个elst盒子:用来使track的时间戳产生偏移。是一个可选存在与否的盒子。 2.3、mdiamdia:即Media Box，包含track的sample信息。media包含三个box：分别是mdhd、hdlr、minf。 mdhdmdhd:mdhd即为media header box。 hdlrhdlr:hdlr即为Handler Reference Box。 minfhdlr:hdlr即为Handler Reference Box。 3、udtaudta:即User Data Box,用于存放用户自定义的信息。 三、freefree:和视频音频的解码无关。 四、mdatmdat:即Media Data,保存了视频和音频的数据。 MP4解封装先放MP4文件架构图:那么很明显了。解封装的流程就是先读取trak盒子的Track信息，然后按照Track信息去mdat读取相应的数据。","categories":[{"name":"个人理解","slug":"个人理解","permalink":"http://yoursite.com/categories/234/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"音视频","slug":"音视频","permalink":"http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"}]},{"title":"FFmpeg 学习 03 h264_MP4视频-视频流解码","slug":"FFmpeg02","date":"2020-04-14T10:38:46.855Z","updated":"2020-04-15T06:28:48.037Z","comments":true,"path":"2020/04/14/FFmpeg02/","link":"","permalink":"http://yoursite.com/2020/04/14/FFmpeg02/","excerpt":"","text":"FFmpeg 4.2 iOS 解码流程：1.读取文件，从中获得文件的编码信息。1234567891011121314151617181920212223242526272829303132333435363738394041424344//读取流信息- (int)_readfile &#123; //获取文件地址 NSString * filePath = [[NSBundle mainBundle] pathForResource:@\"GalGadot\" ofType:@\".mp4\"]; //通过ffmpeg接口读取文件 if ( avformat_open_input(&amp;fmt_ctx,filePath.UTF8String, NULL, NULL) &lt; 0 ) &#123; NSLog(@\"avformat_open_input error !\"); avformat_free_context(fmt_ctx); return -1; &#125; //从文件中读取流信息 if ( avformat_find_stream_info(fmt_ctx, NULL) &lt; 0 ) &#123; NSLog(@\"avformat_find_stream_info error !\"); avformat_close_input(&amp;fmt_ctx); avformat_free_context(fmt_ctx); return -2; &#125; //获取所需要的流 video_track_index = -1; for (int i = 0; i &lt; fmt_ctx-&gt;nb_streams; ++i) &#123; AVCodecParameters * code_params = fmt_ctx-&gt;streams[i]-&gt;codecpar; //读取到视频track if ( code_params-&gt;codec_type == AVMEDIA_TYPE_VIDEO ) &#123; NSLog(@\"stream:%d code_type:AVMEDIA_TYPE_VIDEO\",i); video_track_index = i; video_Codec = avcodec_find_decoder(code_params-&gt;codec_id); video_Codec_params = code_params; break; &#125; &#125; if (video_track_index &gt; -1 ) &#123; //打印流信息 av_dump_format(fmt_ctx, 0, filePath.UTF8String, 0); return 0; &#125; NSLog(@\"未读取到视频流\"); avformat_close_input(&amp;fmt_ctx); avformat_free_context(fmt_ctx); return -3;&#125; 2.设置相应的解码器。12345678910111213141516171819//编码器设置- (int)_videoCodecSetup &#123; //创建解码器上下文 video_Codec_Ctx = avcodec_alloc_context3(video_Codec); ///将解码器信息传入解码器上下文保存 if ( avcodec_parameters_to_context(video_Codec_Ctx, video_Codec_params) != 0) &#123; avcodec_free_context(&amp;video_Codec_Ctx); NSLog(@\"avcodec_parameters_to_context error!\"); return -1; &#125; //打开解码器 if (avcodec_open2(video_Codec_Ctx, video_Codec, NULL) != 0) &#123; avcodec_free_context(&amp;video_Codec_Ctx); NSLog(@\"avcodec_parameters_to_context error!\"); return -2; &#125; NSLog(@\"解码器设置成功\"); return 0;&#125; 3.读取数据传入解码器，解码器解码，接收解码好的数据。12345678910111213141516171819202122232425262728293031323334353637383940- (void)_handleDecode &#123; //创建一个包，用来读取未解码的数据 AVPacket * video_packet = av_packet_alloc(); av_init_packet(video_packet); //创建一个frame，用来接收解码的数据 AVFrame * video_frame = av_frame_alloc(); //循环的读取需要解码的数据包 while (av_read_frame(fmt_ctx, video_packet) == 0) &#123; //过滤，只处理视频包 if (video_packet-&gt;stream_index == video_track_index) &#123; //将视频解码数据送进解码器 int ret = avcodec_send_packet(video_Codec_Ctx, video_packet); if (ret == 0) &#123; NSLog(@\"avcodec_send_packet success\"); &#125;else &#123; NSLog(@\"avcodec_send_packet error %d\",ret); &#125; //接收解码数据 ret = avcodec_receive_frame(video_Codec_Ctx, video_frame); if (ret == 0) &#123; //解码成功 NSLog(@\"width:%d height:%d\",video_frame-&gt;width,video_frame-&gt;height); NSLog(@\"m_frame size :%d\",video_frame-&gt;pkt_size); NSLog(@\"format:%d\",video_frame-&gt;format); //只看一帧，然后返回。 av_packet_free(&amp;video_packet); av_frame_free(&amp;video_frame); return; &#125;else &#123; NSLog(@\"avcodec_receive_frame error %d\",ret); &#125; &#125; av_packet_unref(video_packet); &#125; av_packet_free(&amp;video_packet); av_frame_free(&amp;video_frame);&#125;","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://yoursite.com/categories/234/FFmpeg/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://yoursite.com/tags/FFmpeg/"},{"name":"音视频","slug":"音视频","permalink":"http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"ios","slug":"ios","permalink":"http://yoursite.com/tags/ios/"}]},{"title":"FFmpeg 学习 02 h264_MP4视频-iOS项目使用FFmpeg库","slug":"FFmpeg01","date":"2020-04-13T06:19:36.075Z","updated":"2020-04-15T06:28:29.378Z","comments":true,"path":"2020/04/13/FFmpeg01/","link":"","permalink":"http://yoursite.com/2020/04/13/FFmpeg01/","excerpt":"","text":"FFmpeg 4.2 iOS 添加过程1.直接将编译好的framework拖进工程 2.添加依赖 打开工程设置Build Phases在Link Binary With Libraries中添加ffmpeg依赖的库 3.设置头文件路径(可不做) 打开工程设置Build Settings在search栏中输出 header s就可以找到Header Search Paths,设置头文件路径。设置为对应的目录: 4.测试是否引入成功 头文件引入#import &quot;avformat.h&quot; 然后添加以下内容，并编译xcode工程。 12NSString * filePath = [[NSBundle mainBundle] pathForResource:@\"GalGadot\" ofType:@\"mp4\"];avformat_open_input(&amp;fmt_ctx,filePath.UTF8String, NULL, NULL); 如果编译成功，则表示运行正确。","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://yoursite.com/categories/234/FFmpeg/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://yoursite.com/tags/FFmpeg/"},{"name":"音视频","slug":"音视频","permalink":"http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"ios","slug":"ios","permalink":"http://yoursite.com/tags/ios/"}]},{"title":"FFmpeg 学习 01 编译源码","slug":"FFmpeg00","date":"2020-04-13T06:19:36.075Z","updated":"2020-04-14T07:35:01.704Z","comments":true,"path":"2020/04/13/FFmpeg00/","link":"","permalink":"http://yoursite.com/2020/04/13/FFmpeg00/","excerpt":"","text":"编译步骤 1.安装Command Line Tools，默认已经安装Xcode就忽略这步。2.预处理文件安装：2.1 下载文件gas-preprocessor.pl;2.1 解压文件，并放到/usr/local/bin目录下;2.1 添加文件权限: chmod 777 xxx/gas-preprocessor.pl 3.编译：3.1这里为了方便编译下载一键脚本:3.2直接执行对应脚本 ./build-ffmpeg-iOS-framework.sh 4.编译结果: FFmpeg.framework 就是我们需要的库以及头文件。","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://yoursite.com/categories/234/FFmpeg/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://yoursite.com/tags/FFmpeg/"},{"name":"音视频","slug":"音视频","permalink":"http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"ios","slug":"ios","permalink":"http://yoursite.com/tags/ios/"}]}],"categories":[{"name":"读书系列","slug":"读书系列","permalink":"http://yoursite.com/categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"},{"name":"个人理解","slug":"个人理解","permalink":"http://yoursite.com/categories/234/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"},{"name":"算法总结","slug":"算法总结","permalink":"http://yoursite.com/categories/234/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://yoursite.com/categories/234/FFmpeg/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构与算法之美","slug":"数据结构与算法之美","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"},{"name":"音视频","slug":"音视频","permalink":"http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://yoursite.com/tags/FFmpeg/"},{"name":"ios","slug":"ios","permalink":"http://yoursite.com/tags/ios/"}]}