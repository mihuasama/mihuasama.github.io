<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MiHuA</title>
  
  <subtitle>Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-08T02:14:19.441Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>mihua</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《数据结构与算法之美》 21 动态规划</title>
    <link href="http://yoursite.com/2020/05/08/DataStructure21/"/>
    <id>http://yoursite.com/2020/05/08/DataStructure21/</id>
    <published>2020-05-08T01:40:09.136Z</published>
    <updated>2020-05-08T02:14:19.441Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 20 回溯算法</title>
    <link href="http://yoursite.com/2020/05/08/DataStructure20/"/>
    <id>http://yoursite.com/2020/05/08/DataStructure20/</id>
    <published>2020-05-08T01:40:01.230Z</published>
    <updated>2020-05-08T02:14:06.761Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 19 分治算法</title>
    <link href="http://yoursite.com/2020/05/08/DataStructure19/"/>
    <id>http://yoursite.com/2020/05/08/DataStructure19/</id>
    <published>2020-05-08T01:39:53.421Z</published>
    <updated>2020-05-08T02:26:29.739Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 18 贪心算法</title>
    <link href="http://yoursite.com/2020/05/08/DataStructure18/"/>
    <id>http://yoursite.com/2020/05/08/DataStructure18/</id>
    <published>2020-05-08T01:39:49.537Z</published>
    <updated>2020-05-08T02:26:29.747Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 17 AC自动机</title>
    <link href="http://yoursite.com/2020/05/08/DataStructure17/"/>
    <id>http://yoursite.com/2020/05/08/DataStructure17/</id>
    <published>2020-05-08T01:39:42.461Z</published>
    <updated>2020-05-08T02:26:29.761Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 16 Trie树</title>
    <link href="http://yoursite.com/2020/05/08/DataStructure16/"/>
    <id>http://yoursite.com/2020/05/08/DataStructure16/</id>
    <published>2020-05-08T01:39:38.395Z</published>
    <updated>2020-05-08T02:26:29.753Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 15 字符串</title>
    <link href="http://yoursite.com/2020/05/08/DataStructure15/"/>
    <id>http://yoursite.com/2020/05/08/DataStructure15/</id>
    <published>2020-05-08T01:39:24.152Z</published>
    <updated>2020-05-08T02:26:29.767Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 14 BFS&amp;DFS</title>
    <link href="http://yoursite.com/2020/05/08/DataStructure14/"/>
    <id>http://yoursite.com/2020/05/08/DataStructure14/</id>
    <published>2020-05-08T01:39:17.856Z</published>
    <updated>2020-05-09T10:50:34.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、广度优先搜索-BFS"><a href="#一、广度优先搜索-BFS" class="headerlink" title="一、广度优先搜索(BFS)"></a>一、广度优先搜索(BFS)</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>广度优先搜索(Breadth-First-Search)，我们平常都把简称为 BFS。直观地讲，它其实就 是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次 往外搜索。理解起来并不难，所以我画了一张示意图，你可以看下。<br><img src="/2020/05/08/DataStructure14/bfs.png" alt></p><blockquote><p>通过BFS搜索到的路径，就是最短路径。</p></blockquote><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p><strong>额外存储空间:</strong><br>一个哈希表，存储该顶点是否被访问过。(当入栈的时候，就表示被访问过)。记为Visited。<br>一个哈希表，存储该顶点的前置顶点。 记为prev。<br>一个队列，用来存储即将访问的顶点的集合。记为queue。<br><strong>流程</strong><br>首先从图中取出需要访问的顶点S，将其入队。<br>然后while判断，当queue为不空的时候一直循环。<br>在循环中，从queue中取出顶点，依次判断顶点的<strong>邻接顶点</strong>是否被访问过，如果被访问过就直接跳过该顶点。<br>如果没有被访问过，就查看该顶点的值，是否为要寻找的顶点D。<br>如果不是访问的顶点D，那么就把该顶点的入队queue。<br>如果是访问的顶点D，那么利用prev[d]依次寻找，直到D，这条路径就是找到的路径的逆序。<br><strong>代码实现</strong></p><blockquote><p>该代码的图，由二维数组转换位邻接表的方式存储。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_struct</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">graph_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Node * node;</span><br><span class="line">&#125;Graph;</span><br></pre></td></tr></table></figure><p>通过二维数组定义图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  graphArray[<span class="number">8</span>][<span class="number">8</span>] =&#123;</span><br><span class="line">    &#123; <span class="number">0</span>  ,  <span class="number">1</span>  ,  <span class="number">0</span>  ,  <span class="number">1</span>  ,  <span class="number">0</span>  ,  <span class="number">0</span>  ,  <span class="number">0</span>  ,  <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="number">1</span>  ,  <span class="number">0</span>  ,  <span class="number">1</span>  ,  <span class="number">0</span>  ,  <span class="number">1</span>  ,  <span class="number">0</span>  ,  <span class="number">0</span>   , <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>  ,  <span class="number">1</span>  ,  <span class="number">0</span>  ,  <span class="number">0</span>  ,  <span class="number">0</span>  ,  <span class="number">1</span> ,   <span class="number">0</span>  ,  <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="number">1</span>  ,  <span class="number">0</span>  ,  <span class="number">0</span>  ,  <span class="number">0</span>  ,  <span class="number">1</span>  ,  <span class="number">0</span>  ,  <span class="number">0</span>  ,  <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>  ,  <span class="number">1</span>  ,  <span class="number">0</span>  ,  <span class="number">1</span>  ,  <span class="number">0</span>  ,  <span class="number">1</span>  ,  <span class="number">1</span>  ,  <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>  ,  <span class="number">0</span>  ,  <span class="number">1</span>  ,  <span class="number">0</span>  ,  <span class="number">1</span>  ,  <span class="number">0</span>  ,  <span class="number">0</span>  ,  <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>  ,  <span class="number">0</span>  ,  <span class="number">0</span>  ,  <span class="number">0</span>  ,  <span class="number">1</span>  ,  <span class="number">0</span>  ,  <span class="number">0</span>  ,  <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>  ,  <span class="number">0</span>  ,  <span class="number">0</span>  ,  <span class="number">0</span>  ,  <span class="number">0</span>  ,  <span class="number">1</span>  ,  <span class="number">1</span>  ,  <span class="number">0</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将二维数组转化为邻接表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Graph* <span class="title">createGraph</span><span class="params">(<span class="keyword">int</span> (*graphArray)[<span class="number">8</span>])</span> </span>&#123;</span><br><span class="line">    Graph* graph = (Graph*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Graph));</span><br><span class="line">    graph-&gt;v = <span class="number">8</span>;</span><br><span class="line">    Node * node = (Node*)<span class="built_in">malloc</span>(graph-&gt;v*<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    Node * tempNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; graph-&gt;v; i ++) &#123;</span><br><span class="line">        tempNode-&gt;data = <span class="built_in">array</span>[i];</span><br><span class="line">        tempNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)(node + i),(<span class="keyword">const</span> <span class="keyword">void</span>*)tempNode,<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(tempNode);</span><br><span class="line">    graph-&gt;node = node;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;v; i ++) &#123;</span><br><span class="line">        Node * preNode = graph-&gt;node+i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph-&gt;v; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graphArray[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                Node * tempNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">                tempNode-&gt;data = j;</span><br><span class="line">                tempNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                preNode-&gt;next = tempNode;</span><br><span class="line">                preNode = tempNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印测试邻接表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printGraph</span><span class="params">(Graph * graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;v; i ++) &#123;</span><br><span class="line">        Node * preNode = graph-&gt;node+i;</span><br><span class="line">        <span class="keyword">while</span> (preNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d  "</span>,preNode-&gt;data);</span><br><span class="line">            preNode = preNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所需要的队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">num_queue</span> &#123;</span></span><br><span class="line">    Node * <span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">int</span> nums;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue* <span class="title">createQueue</span> <span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    Queue * <span class="built_in">queue</span> = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    Node * queueArray = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)*<span class="built_in">size</span>);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;<span class="built_in">queue</span> = queueArray;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;nums = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">_Bool</span> <span class="title">enQueue</span><span class="params">(Queue*<span class="built_in">queue</span>,Node * data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;head == <span class="number">0</span> &amp;&amp; <span class="built_in">queue</span>-&gt;tail == <span class="built_in">queue</span>-&gt;<span class="built_in">size</span><span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;tail == <span class="built_in">queue</span>-&gt;<span class="built_in">size</span> - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="built_in">queue</span>-&gt;head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= <span class="built_in">queue</span>-&gt;tail - <span class="built_in">queue</span>-&gt;head; i ++) &#123;</span><br><span class="line">            <span class="built_in">queue</span>-&gt;<span class="built_in">queue</span>[i] = <span class="built_in">queue</span>-&gt;<span class="built_in">queue</span>[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;head = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;tail = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail ++;</span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="built_in">queue</span>-&gt;<span class="built_in">queue</span>+<span class="built_in">queue</span>-&gt;tail, data, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;nums ++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">deQueue</span><span class="params">(Queue*<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;tail &lt; <span class="built_in">queue</span>-&gt;head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* ret = &amp;(<span class="built_in">queue</span>-&gt;<span class="built_in">queue</span>[<span class="built_in">queue</span>-&gt;head++]);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;nums --;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>广度优先搜索具体实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Graph * graph,<span class="keyword">int</span> s,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">_Bool</span> visited[graph-&gt;v];</span><br><span class="line">    <span class="keyword">int</span> prev[graph-&gt;v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;v; i ++) &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">        prev[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue * <span class="built_in">queue</span> = createQueue(graph-&gt;v);</span><br><span class="line">    enQueue(<span class="built_in">queue</span>, graph-&gt;node);<span class="comment">//初始元素入队</span></span><br><span class="line">    visited[graph-&gt;node-&gt;data] = <span class="number">1</span>; <span class="comment">//入队了，就表示已经被访问过.</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">queue</span>-&gt;nums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node * node = deQueue(<span class="built_in">queue</span>);; <span class="comment">//出队</span></span><br><span class="line">        <span class="keyword">int</span> prevTemp = node-&gt;data;<span class="comment">//记录前驱节点</span></span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[node-&gt;data] == <span class="number">1</span>) &#123; <span class="comment">//访问过的节点直接过滤</span></span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev[node-&gt;data] = prevTemp; <span class="comment">//记录当前节点的前驱节点</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, prevTemp,node-&gt;data);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;data == d) &#123;</span><br><span class="line">                <span class="comment">//找到了</span></span><br><span class="line">                <span class="keyword">int</span> index = d;</span><br><span class="line">                <span class="keyword">while</span> (index != s) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d "</span>,index);</span><br><span class="line">                    index = prev[index];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//没找到，该顶点入队,入队的顶点需要有下级节点的信息，所以应该从图中取出</span></span><br><span class="line">                Node * tempNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;v; i ++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (graph-&gt;node[i].data == node-&gt;data) &#123;</span><br><span class="line">                        <span class="built_in">memcpy</span>(tempNode, graph-&gt;node+i, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                enQueue(<span class="built_in">queue</span>, tempNode);</span><br><span class="line">                visited[tempNode-&gt;data] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">free</span>(tempNode);</span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Graph * graph = createGraph(graphArray);</span><br><span class="line">     bfs(graph, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、广度优先搜索-BFS&quot;&gt;&lt;a href=&quot;#一、广度优先搜索-BFS&quot; class=&quot;headerlink&quot; title=&quot;一、广度优先搜索(BFS)&quot;&gt;&lt;/a&gt;一、广度优先搜索(BFS)&lt;/h2&gt;&lt;h3 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; c
      
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 13 图</title>
    <link href="http://yoursite.com/2020/05/07/DataStructure13/"/>
    <id>http://yoursite.com/2020/05/07/DataStructure13/</id>
    <published>2020-05-07T09:16:35.157Z</published>
    <updated>2020-05-07T10:33:36.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第26课-图的表示"><a href="#第26课-图的表示" class="headerlink" title="第26课 - - - - - - -图的表示"></a>第26课 - - - - - - -图的表示</h2><h3 id="一、图的相关概念"><a href="#一、图的相关概念" class="headerlink" title="一、图的相关概念"></a>一、图的相关概念</h3><p><img src="/2020/05/07/DataStructure13/graph1.png" alt><br>1.<strong>顶点</strong><br>图中的元素，叫做“顶点”。<br>2.<strong>边</strong><br>图中两个元素相连的线，叫做“边”。<br>3.<strong>度</strong><br>元素的边的数量，是“度”。<br><img src="/2020/05/07/DataStructure13/graph2.png" alt><br>4.<strong>有向图、无向图</strong><br>边不带方向的叫，做“无向图”。<br>边带方向的叫，做“有向图”。<br>5.<strong>出度、入度</strong><br>在有向图中。<br>元素所有指向别的元素的边的数量，叫做“出度”。<br>所有指向元素的边的数量，叫做“入度”。<br><img src="/2020/05/07/DataStructure13/graph3.png" alt><br>6.<strong>带权图</strong><br>边带有权重的图，叫做“带权图”。</p><h3 id="二、图的存储"><a href="#二、图的存储" class="headerlink" title="二、图的存储"></a>二、图的存储</h3><h4 id="1-邻接矩阵存储"><a href="#1-邻接矩阵存储" class="headerlink" title="1.邻接矩阵存储"></a>1.邻接矩阵存储</h4><p><img src="/2020/05/07/DataStructure13/graph4.png" alt><br>矩阵用二维数组表示。</p><blockquote><p>对于无向图来说，<br>如果顶点 i 与顶点 j 之间有边，我们 就将 A[i][j] 和 A[j][i] 标记为 1;<br>对于有向图来说，<br>如果顶点 i 到顶点 j 之间，有一条箭头从 顶点 i 指向顶点 j 的边，那我们就将 A[i][j] 标记为 1。<br>如果有一条箭头从顶点 j 指向 顶点 i 的边，我们就将 A[j][i] 标记为 1。</p></blockquote><p><strong>优点:</strong><br>读取某两个元素之间的关系，时间复杂度为O(1)；<br>图的运算可以转换为矩阵运算。<br><strong>缺点：</strong><br>对于无向图和稀疏图，浪费存储空间。<br>无向图直接浪费了一半的存储空间。</p><h4 id="2-邻接表存储方法"><a href="#2-邻接表存储方法" class="headerlink" title="2.邻接表存储方法"></a>2.邻接表存储方法</h4><p><img src="/2020/05/07/DataStructure13/graph5.png" alt></p><blockquote><p>每个顶点对 应一条链表，链表中存储的是与这个顶点相连接的其他顶点。</p></blockquote><p><strong>优点:</strong><br>节省空间。<br><strong>缺点:</strong><br>当某个顶点的度很大的时候，查找关系需要遍历，耗时。</p><blockquote><p><strong>改进</strong>：通过将存储的链表优化为跳表，散列表等方式，可以提高查找的性能。</p></blockquote><h3 id="三、微博如何存储用户关系"><a href="#三、微博如何存储用户关系" class="headerlink" title="三、微博如何存储用户关系"></a>三、微博如何存储用户关系</h3><p><img src="/2020/05/07/DataStructure13/graph6.png" alt><br>微博用户关系，可以用有向图来表示。<br>使用两个表来互相的关系，<br>邻接表来存储用户关注的人，逆邻接表来存储关注用户的人。<br>可以通过邻接表快速找到用户关注的人，通过逆邻接表快速查找到粉丝。</p><p>当数据量变得非常大，内存存不下的时候。<br>需要通过哈希分片，将数据分片到不同机器上存储。<br><img src="/2020/05/07/DataStructure13/graph7.png" alt></p><h3 id="四、微信如何存储用户关系"><a href="#四、微信如何存储用户关系" class="headerlink" title="四、微信如何存储用户关系"></a>四、微信如何存储用户关系</h3><p>微信用户关系，可以用无向图来表示。<br>使用邻接表的方式存储用户的关系，为了快速的查找，可以使用红黑树来替换普通链表存储好友列表。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第26课-图的表示&quot;&gt;&lt;a href=&quot;#第26课-图的表示&quot; class=&quot;headerlink&quot; title=&quot;第26课 - - - - - - -图的表示&quot;&gt;&lt;/a&gt;第26课 - - - - - - -图的表示&lt;/h2&gt;&lt;h3 id=&quot;一、图的相关概念&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 12 堆</title>
    <link href="http://yoursite.com/2020/05/07/DataStructure12/"/>
    <id>http://yoursite.com/2020/05/07/DataStructure12/</id>
    <published>2020-05-07T02:29:04.063Z</published>
    <updated>2020-05-07T09:16:02.165Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。</p></blockquote><h2 id="第24课-堆和堆排序"><a href="#第24课-堆和堆排序" class="headerlink" title="第24课 - - - - - - -堆和堆排序"></a>第24课 - - - - - - -堆和堆排序</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><p>堆是满足父节点和子节点大小关系的完全二叉树。</p></blockquote><h4 id="大顶堆、小顶堆"><a href="#大顶堆、小顶堆" class="headerlink" title="大顶堆、小顶堆"></a>大顶堆、小顶堆</h4><blockquote><p>大顶堆：父节点大于子节点的堆。<br>小顶堆：父节点小于子节点的堆。</p></blockquote><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>通过数组存储完全二叉树。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><strong>步骤</strong></h4><p>第一步:创建堆。<br>第二步:从数组顶部开始，将堆的根节点移交换到未排序的数组尾部。每次交换以后，再对数组尾部之前的二叉树进行堆化。<br><strong>升序使用大顶堆，降序使用小顶堆</strong></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>每次都能通过交换堆顶元素获得堆的最大值或者最小值。依次存入数组底部就能让数组有序。</p><h4 id="堆排序不是一个稳定排序算法"><a href="#堆排序不是一个稳定排序算法" class="headerlink" title="堆排序不是一个稳定排序算法"></a>堆排序不是一个稳定排序算法</h4><p>因为当数移动到堆顶,再将堆顶元素移动到最后，会改变相同数字的相对位置。</p><h4 id="堆排序是原地排序"><a href="#堆排序是原地排序" class="headerlink" title="堆排序是原地排序"></a>堆排序是原地排序</h4><p>堆排序在数组中进行，不需要额外的存储空间，所以是原地排序算法。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>1.创建一个堆的时间复杂度为O(logn)。<br>2.排序需要1+2+….+n = (n+1)次，其中都需要对堆进行调整。<br>所以大约的时间复杂度为O(n*logn)。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="创建堆的实现"><a href="#创建堆的实现" class="headerlink" title="创建堆的实现"></a>创建堆的实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> * a,<span class="keyword">int</span> * b)</span></span>&#123;</span><br><span class="line">    *a = *a ^ *b;</span><br><span class="line">    *b = *a ^ *b;</span><br><span class="line">    *a = *a ^ *b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">(<span class="keyword">int</span> *heap, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        <span class="keyword">int</span> leftIndex = <span class="number">2</span>*i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightIndex = <span class="number">2</span>*i + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftIndex &lt; len &amp;&amp; heap[i] &lt; heap[leftIndex]) &#123;</span><br><span class="line">            swap(heap+i,heap+leftIndex);</span><br><span class="line">            <span class="keyword">int</span> newLeftIndex = <span class="number">2</span> * leftIndex + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> newRightIndex = <span class="number">2</span> * leftIndex + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((newLeftIndex &lt; len &amp;&amp; heap[leftIndex] &lt; heap[newLeftIndex]) ||</span><br><span class="line">                (newRightIndex &lt; len &amp;&amp; heap[rightIndex] &lt; heap[newRightIndex])) &#123;</span><br><span class="line">                createHeap(heap,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightIndex &lt; len &amp;&amp; heap[i] &lt; heap[rightIndex]) &#123;</span><br><span class="line">            swap(heap + i, heap + rightIndex);</span><br><span class="line">            <span class="keyword">int</span> newLeftIndex = <span class="number">2</span> * rightIndex + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> newRightIndex = <span class="number">2</span> * rightIndex + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((newLeftIndex &lt; len &amp;&amp; heap[leftIndex] &lt; heap[newLeftIndex]) ||</span><br><span class="line">                (newRightIndex &lt; len &amp;&amp; heap[rightIndex] &lt; heap[newRightIndex])) &#123;</span><br><span class="line">                createHeap(heap,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="堆排序实现"><a href="#堆排序实现" class="headerlink" title="堆排序实现"></a>堆排序实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">( <span class="keyword">int</span> * nums, <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">size</span> <span class="number">-1</span>; i &gt; <span class="number">0</span>; i --) &#123;</span><br><span class="line">        createHeap(nums, i+<span class="number">1</span>);</span><br><span class="line">        swap(nums, nums+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么快速排序比堆排排序性能好"><a href="#为什么快速排序比堆排排序性能好" class="headerlink" title="为什么快速排序比堆排排序性能好"></a>为什么快速排序比堆排排序性能好</h3><blockquote><p>1.数据访问方式没有快速排序友好。<br>对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。 这样对CPU缓存是不友好的。<br>2.对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。<br>对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换(或移动)。快速排序数据交换的次数不会比逆序度多。<br>堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有 序度降低。</p></blockquote><h2 id="第25课-堆的应用"><a href="#第25课-堆的应用" class="headerlink" title="第25课 - - - - - - -堆的应用"></a>第25课 - - - - - - -堆的应用</h2><h3 id="一、优先级队列"><a href="#一、优先级队列" class="headerlink" title="一、优先级队列"></a>一、优先级队列</h3><blockquote><p>优先级队列：被限制的队列，元素入队以后，出队的的顺序由优先级决定。</p></blockquote><p>队列可以通过数组实现，而数组又可以是堆的载体。<br>所以存储在数组的堆是一个天然的优先级队列。</p><h4 id="1-合并有序小文件"><a href="#1-合并有序小文件" class="headerlink" title="1.合并有序小文件"></a>1.合并有序小文件</h4><p>假设我们有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。我们希望将这些 100 个小文件合并成一个有序的大文件。</p><blockquote><p>1.从每个小文件中拿出一个字符串，然后做一次小顶堆。<br>2.然后将小顶堆放入大文件。再从该小顶堆的文件中拿一个字符串放在顶堆的位置，做一次堆化操作。<br>然后循环2.知道所有小文件中都没有字符串为止。</p></blockquote><h4 id="2-高性能定时器"><a href="#2-高性能定时器" class="headerlink" title="2.高性能定时器"></a>2.高性能定时器</h4><p>普通的定时器，过去单位时间以后，去遍历任务列表，然后执行。当列表很长的时候，花费很高。<br>可以通过优先级队列优化掉遍历方式。通过优先级队列来实现执行完以后，直接从优先级队列拿任务进行处理。</p><h3 id="二、利用堆求Top-k"><a href="#二、利用堆求Top-k" class="headerlink" title="二、利用堆求Top k"></a>二、利用堆求Top k</h3><p>每一次堆化都能拿到该堆的最大或者最小元素。<br>第k大或小，只需要经过k次堆化就能拿到相应的值。<br>时间复杂度k*(logn)。</p><h3 id="三、利用堆求中位数"><a href="#三、利用堆求中位数" class="headerlink" title="三、利用堆求中位数"></a>三、利用堆求中位数</h3><h4 id="中位数："><a href="#中位数：" class="headerlink" title="中位数："></a>中位数：</h4><p>把数据分为两部分<br>一部分建立大顶堆，一部分建立小顶堆。小顶堆的数都比大顶堆的数大。<br>当大顶堆和小顶堆的元素个数相同的时候：两个堆顶的元素都是中位数。<br>当一个堆的元素个数比另一个堆的元素个数多一个的时候：元素个数多的堆的堆顶元素，就是中位数。</p><h4 id="第百分比数："><a href="#第百分比数：" class="headerlink" title="第百分比数："></a>第百分比数：</h4><p>其实就是将中位数不按中分，而是按照数据百分比建立两个堆。</p><h3 id="四、快速获取到Top10最热门的搜索关键词"><a href="#四、快速获取到Top10最热门的搜索关键词" class="headerlink" title="四、快速获取到Top10最热门的搜索关键词"></a>四、快速获取到Top10最热门的搜索关键词</h3><p>假设现在 我们有一个包含 10 亿个搜索关键词的日志文件，如何快速获取到Top10最热门的搜索关键词?</p><blockquote><p>依次扫描日志文件，将搜索词的次数通过哈希表的方式进行计数。<br>然后对哈希表里的数据进行堆化。<br>时间复杂度就是10<em>(logn)。n为搜索词的数量。<br>*</em>如果哈希表太大，内存存不下，可以通过先将日志文件的关键词哈希散列到小文件中**，分别对每个文件的关键词，使用哈希表统计计数。<br>再对统计计数结果使用堆取top10。然后再对各个小文件的top10和在一起以后取top10.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第24课-堆和堆排序&quot;&gt;&lt;a href=&quot;#第24课-堆和堆排序&quot; class=&quot;headerlink&quot; title=&quot;第24课 - 
      
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>从零刷题记录</title>
    <link href="http://yoursite.com/2020/05/06/LeetCode/"/>
    <id>http://yoursite.com/2020/05/06/LeetCode/</id>
    <published>2020-05-06T01:44:36.948Z</published>
    <updated>2020-05-06T07:11:54.282Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、两数之和"><a href="#1、两数之和" class="headerlink" title="#1、两数之和"></a>#1、两数之和</h3><blockquote><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br><strong>示例:</strong><br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p></blockquote><p><strong>解题思路:</strong><br>方法1.两层循环，依次相加暴力破解。<br>方法2.hash表存储已经遍历过的值，用target-当前值的结果去哈希表查找是否存在值。</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Hash_Entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Hash_Entry</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hashMap</span> &#123;</span></span><br><span class="line">    Entry * hashMap;</span><br><span class="line">&#125;HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tableSize = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建hash表</span></span><br><span class="line"><span class="function">HashMap * <span class="title">createMap</span><span class="params">(<span class="keyword">int</span> tableSize)</span> </span>&#123;</span><br><span class="line">    HashMap * <span class="built_in">map</span> = (HashMap*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashMap));</span><br><span class="line">    <span class="built_in">map</span>-&gt;hashMap = (Entry *)<span class="built_in">malloc</span>(<span class="number">2</span>*tableSize*<span class="keyword">sizeof</span>(Entry));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;hashMap == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">map</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>*tableSize; i ++) &#123;</span><br><span class="line">        Entry * entry =  &amp;<span class="built_in">map</span>-&gt;hashMap[i];</span><br><span class="line">        entry-&gt;key = <span class="number">-1</span>;</span><br><span class="line">        entry-&gt;value = <span class="number">-1</span>;</span><br><span class="line">        entry-&gt;<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">        entry-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁hash表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryMap</span> <span class="params">(HashMap * <span class="built_in">map</span>,<span class="keyword">int</span> tableSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>*tableSize; i ++) &#123;</span><br><span class="line">        Entry * entry =  &amp;<span class="built_in">map</span>-&gt;hashMap[i];</span><br><span class="line">        entry = entry-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (entry != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Entry* freeEntry = entry;</span><br><span class="line">            entry = entry-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(freeEntry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">map</span>-&gt;hashMap);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">map</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashKey</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(key)%tableSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setValueForKey</span><span class="params">(HashMap * <span class="built_in">map</span>,<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    Entry * entry = &amp;<span class="built_in">map</span>-&gt;hashMap[hashKey(key)];</span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;value == <span class="number">-1</span>) &#123;</span><br><span class="line">        entry-&gt;value = value;</span><br><span class="line">        entry-&gt;key = key;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        Entry * temp = entry;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry * next =  (Entry *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Entry));</span><br><span class="line">        next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        next-&gt;value = value;</span><br><span class="line">        next-&gt;key = key;</span><br><span class="line">        temp-&gt;next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    entry-&gt;<span class="built_in">size</span> ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找值</span></span><br><span class="line"><span class="function">Entry * <span class="title">getValueForKey</span><span class="params">(HashMap * <span class="built_in">map</span>,<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    Entry * entry = &amp;<span class="built_in">map</span>-&gt;hashMap[hashKey(key)];</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    HashMap *<span class="built_in">map</span> = createMap(tableSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> key = nums[i];</span><br><span class="line">        <span class="keyword">int</span> target_sub = target - key;</span><br><span class="line">        Entry * entry = getValueForKey(<span class="built_in">map</span>, target_sub);</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;<span class="built_in">size</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (entry-&gt;key != target_sub &amp;&amp; entry-&gt;next != <span class="literal">NULL</span>) &#123; <span class="comment">//冲突</span></span><br><span class="line">                entry = entry-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;key == target_sub) &#123;</span><br><span class="line">                <span class="keyword">int</span> * ret = <span class="built_in">malloc</span>(<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">                      ret[<span class="number">0</span>] = entry-&gt;value;</span><br><span class="line">                      ret[<span class="number">1</span>] = i;</span><br><span class="line">                      *returnSize = <span class="number">2</span>;</span><br><span class="line">                      destoryMap(<span class="built_in">map</span>, tableSize);</span><br><span class="line">                      <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setValueForKey(<span class="built_in">map</span>, key, i);</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    destoryMap(<span class="built_in">map</span>, tableSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="#5. 最长回文子串"></a>#5. 最长回文子串</h3><blockquote><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br><strong>示例:</strong><br>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p></blockquote><p><strong>解题思路:</strong><br>方法1.暴力破解，遍历元素，记录最大回文子串。回文串通过左右两个指针寻找。<br>回文串寻找:先找相同元素，再找对称元素。<br>方法2.</p><figure class="highlight c"><figcaption><span>//暴力破解</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">longestPalindrome</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = <span class="number">0</span>,<span class="built_in">max</span> = <span class="number">0</span>; <span class="keyword">int</span> max_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span> ; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//先找到与中间相同的元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span>  &amp;&amp;  s[left] == s[i]) &#123;</span><br><span class="line">            left --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; <span class="built_in">size</span> &amp;&amp; s[right] == s[i]) &#123;</span><br><span class="line">             right ++;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">//如果是左边或者右边到了边界，说明只有相同元素是回文</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">0</span> || right &gt;= <span class="built_in">size</span>) &#123;</span><br><span class="line">            left ++;</span><br><span class="line">            right --;</span><br><span class="line">            <span class="keyword">if</span> (max_size &lt; right - left) &#123;</span><br><span class="line">                <span class="built_in">max</span> = right;</span><br><span class="line">                <span class="built_in">min</span> = left;</span><br><span class="line">                max_size = <span class="built_in">max</span>-<span class="built_in">min</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有找到边界分别按照左右各加1来找回文</span></span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span>  &amp;&amp; right &lt; <span class="built_in">size</span> &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">//找到边界的话或者不相等的数据缩减一位</span></span><br><span class="line">        left ++;</span><br><span class="line">        right --;</span><br><span class="line">        <span class="keyword">if</span> (max_size &lt; right - left) &#123;</span><br><span class="line">            <span class="built_in">max</span> = right;</span><br><span class="line">            <span class="built_in">min</span> = left;</span><br><span class="line">            max_size = <span class="built_in">max</span> - <span class="built_in">min</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//字符串结尾为字符\0</span></span><br><span class="line">      *(s+<span class="built_in">max</span>+<span class="number">1</span>) = <span class="string">'\0'</span>;</span><br><span class="line">      <span class="keyword">return</span> s+<span class="built_in">min</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="#206. 反转链表"></a>#206. 反转链表</h3><blockquote><p>反转一个单链表。<br><strong>示例:</strong><br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></blockquote><p><strong>解题思路:</strong><br>方法1.两个变量，一个用来记录新头，一个记录旧头，新头从NULL开始，旧头从head开始。head向前一个next，旧头的next指向新头，新头等于旧头，旧头等于当前head。一个循环完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">NewHead</span> = <span class="title">NULL</span>, *<span class="title">temp</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        temp-&gt;next = NewHead;</span><br><span class="line">        NewHead = temp;</span><br><span class="line">        temp = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> NewHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、两数之和&quot;&gt;&lt;a href=&quot;#1、两数之和&quot; class=&quot;headerlink&quot; title=&quot;#1、两数之和&quot;&gt;&lt;/a&gt;#1、两数之和&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为
      
    
    </summary>
    
    
      <category term="刷题记录" scheme="http://yoursite.com//categories/234/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 11 递归树</title>
    <link href="http://yoursite.com/2020/05/05/DataStructure11/"/>
    <id>http://yoursite.com/2020/05/05/DataStructure11/</id>
    <published>2020-05-05T01:02:13.993Z</published>
    <updated>2020-05-07T02:28:43.376Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。</p></blockquote><h2 id="第23课-递归树"><a href="#第23课-递归树" class="headerlink" title="第23课 - - - - - - -递归树"></a>第23课 - - - - - - -递归树</h2><h3 id="通过递归树来分析递归算法的时间复杂度。"><a href="#通过递归树来分析递归算法的时间复杂度。" class="headerlink" title="通过递归树来分析递归算法的时间复杂度。"></a>通过递归树来分析递归算法的时间复杂度。</h3><h4 id="一、分析归并排序的时间复杂度"><a href="#一、分析归并排序的时间复杂度" class="headerlink" title="一、分析归并排序的时间复杂度"></a>一、分析归并排序的时间复杂度</h4><p><strong>排序过程：</strong><br>先一分为二，然后合并数组。<br>分解数组的操作消耗时间复杂度很低，主要的耗时操作在合并数组上。<br>而且合并操作和数组内元素个数相关。<br><img src="/2020/05/05/DataStructure11/tree1.png" alt><br>计算每一层的合并操作数合在一起都是n，<br>所以只需要计算出整棵树的高度就可以算出时间复杂度h*n;</p><blockquote><p>从归并排序的原理和递归树，可以看出来，归并排序递归树是一棵满二叉树。满二叉树的高度大约是 logn，所以，归并排序递归实现的时间复杂度就是 O(n*logn)</p></blockquote><h4 id="二、分析快速排序的时间复杂度"><a href="#二、分析快速排序的时间复杂度" class="headerlink" title="二、分析快速排序的时间复杂度"></a>二、分析快速排序的时间复杂度</h4><p><strong>排序过程：</strong><br>先将数组分为相对有序的两边，然后再继续分，直到每个子数组都有序。<br>没有合并操作，主要的耗时操作分为两边相对有序。<br>分开两边和选取的数字分开的区间大小有关系。<br>递归树为：<br><img src="/2020/05/05/DataStructure11/tree2.png" alt><br>分开两边：</p><blockquote><p>正好一分为2的情况下是 O(n*logn)。</p></blockquote><p>最坏的情况按照1:9分：<br><img src="/2020/05/05/DataStructure11/tree3.png" alt></p><blockquote><p>就是n<em>路径，底数比较复杂分别是10和10/9，这种情况下也统一写为logn所以当分区大小比例是1 : 9时，时间复杂度为O(n</em>logn)。</p></blockquote><h4 id="三、分析斐波那契数列的时间复杂度"><a href="#三、分析斐波那契数列的时间复杂度" class="headerlink" title="三、分析斐波那契数列的时间复杂度"></a>三、分析斐波那契数列的时间复杂度</h4><p><strong>代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">return</span> f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>斐波那契递归树:<br><img src="/2020/05/05/DataStructure11/tree4.png" alt></p><p>f(n)分解为f(n-1)和f(n-2)，每次数据规模都是-1或者-2，叶子节点的数据规模是1或者2。所以，从根节点走到叶子节点，每条路径是长短不一的。如果每次都是-1<br>，那最长路径大约就是n;如果每次都是-2，那最短路径大约就是n/2。<br>如果路径长度都为n，那这个总和就是(2^n)-1。<br><img src="/2020/05/05/DataStructure11/tree5.png" alt><br>如果路径长度都为n/2，那这个总和就是(2^n/2)-1。<br><img src="/2020/05/05/DataStructure11/tree6.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第23课-递归树&quot;&gt;&lt;a href=&quot;#第23课-递归树&quot; class=&quot;headerlink&quot; title=&quot;第23课 - - - 
      
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《Re:从零开始的异世界》手游抽卡实现</title>
    <link href="http://yoursite.com/2020/04/30/LotteryDraw/"/>
    <id>http://yoursite.com/2020/04/30/LotteryDraw/</id>
    <published>2020-04-30T05:28:36.101Z</published>
    <updated>2020-05-08T02:38:27.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h1><blockquote><p>基于2020-04-30版本分析，<br>现在5星角色爱蜜莉雅·朦胧的睡意以及怠情疯狂的信仰概率提升。<br>现在5星装备卡鬼族的末裔以及遵守的契约概率提升。</p></blockquote><h3 id="1、不同的抽奖卡类型"><a href="#1、不同的抽奖卡类型" class="headerlink" title="1、不同的抽奖卡类型"></a>1、不同的抽奖卡类型</h3><blockquote><p>首先拥有两种不同的卡类型<br>分别是人物卡、装备卡<br>人物卡和装备卡均分别有三星四星和五星。</p></blockquote><h3 id="2、不同的抽奖卡类型概率统计"><a href="#2、不同的抽奖卡类型概率统计" class="headerlink" title="2、不同的抽奖卡类型概率统计"></a>2、不同的抽奖卡类型概率统计</h3><table><thead><tr><th>类型</th><th>概率</th><th>卡数量</th><th>单个概率</th></tr></thead><tbody><tr><td><center>五星角色卡</center></td><td><center>1.5%</center></td><td><center>10</center></td><td><center> 0.15%</center></td></tr><tr><td><center>四星角色卡</center></td><td><center>8.0%</center></td><td><center>12</center></td><td><center>0.67%</center></td></tr><tr><td><center>三星角色卡</center></td><td><center>40%</center></td><td><center>14</center></td><td><center>2.86%</center></td></tr><tr><td><center>五星装备卡</center></td><td><center>2.5%</center></td><td><center>10</center></td><td><center> 0.25%</center></td></tr><tr><td><center>四星装备卡</center></td><td><center>8.0%</center></td><td><center>12</center></td><td><center>0.67%</center></td></tr><tr><td><center>三星装备卡</center></td><td><center>40%</center></td><td><center>12</center></td><td><center> 3.33%</center></td></tr><tr><td><center>总概率</center></td><td><center>100%</center></td><td><center>\</center></td><td><center>\</center></td></tr></tbody></table><h3 id="3、活动时的五星角色获取概率提升"><a href="#3、活动时的五星角色获取概率提升" class="headerlink" title="3、活动时的五星角色获取概率提升"></a>3、活动时的五星角色获取概率提升</h3><p>当前版本：<br>现在五星角色爱蜜莉雅·朦胧的睡意以及怠情疯狂的信仰概率分别占五星卡的35%。<br>现在五星装备卡鬼族的末裔以及遵守的契约概率分别占五星卡的35%。</p><h3 id="4、连抽不中五星卡概率提升"><a href="#4、连抽不中五星卡概率提升" class="headerlink" title="4、连抽不中五星卡概率提升"></a>4、连抽不中五星卡概率提升</h3><p>如果连续30次召唤没有获得五星角色卡，则下次抽牌概率增加0.5%。不中依次增加，抽中五星角色卡后回归初始状态。</p><h1 id="二、编码设计"><a href="#二、编码设计" class="headerlink" title="二、编码设计"></a>二、编码设计</h1><h3 id="1、活动时，五星角色获取概率提升的只是在五星卡中的占比，所以没有影响五星卡的获取概率。"><a href="#1、活动时，五星角色获取概率提升的只是在五星卡中的占比，所以没有影响五星卡的获取概率。" class="headerlink" title="1、活动时，五星角色获取概率提升的只是在五星卡中的占比，所以没有影响五星卡的获取概率。"></a>1、活动时，五星角色获取概率提升的只是在五星卡中的占比，所以没有影响五星卡的获取概率。</h3><h3 id="2、连续不中五星卡概率提升，提升的是整个五星卡的概率，不影响五星卡角色在五星卡中的占比。"><a href="#2、连续不中五星卡概率提升，提升的是整个五星卡的概率，不影响五星卡角色在五星卡中的占比。" class="headerlink" title="2、连续不中五星卡概率提升，提升的是整个五星卡的概率，不影响五星卡角色在五星卡中的占比。"></a>2、连续不中五星卡概率提升，提升的是整个五星卡的概率，不影响五星卡角色在五星卡中的占比。</h3><blockquote><p>所以、抽奖分为两个步骤：<br>1.抽出具体属于哪一类卡。该步骤受连续不中影响。<br>2.抽出具体卡后，再在具体的卡类型中进行一次抽取。</p></blockquote><h1 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;time.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max_Random 32768</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> increase_single 0.005</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//各级中奖概率</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r_5_p 0.015</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r_4_p 0.080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r_3_p 0.400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> e_5_p 0.025</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> e_4_p 0.080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> e_3_p 0.400</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//角色卡数量</span></span><br><span class="line"><span class="keyword">int</span> CardNums[<span class="number">6</span>] = &#123;<span class="number">11</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> remainder_rw = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//角色卡类型</span></span><br><span class="line"><span class="keyword">enum</span> Type_Card</span><br><span class="line">&#123;</span><br><span class="line">    Type_Card_Role5 = <span class="number">0</span>,</span><br><span class="line">    Type_Card_Role4,</span><br><span class="line">    Type_Card_Role3,</span><br><span class="line">    Type_Card_EQP5,</span><br><span class="line">    Type_Card_EQP4,</span><br><span class="line">    Type_Card_EQP3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * Card_Pool_role5[] = &#123;</span><br><span class="line">    <span class="string">"阿尼莱尼·银莲一现"</span>,</span><br><span class="line">    <span class="string">"特蕾希雅·无垢青鸟"</span>,</span><br><span class="line">    <span class="string">"艾尔莎·诱惑回眸"</span>,</span><br><span class="line">    <span class="string">"怠情·疯狂的信仰"</span>,</span><br><span class="line">    <span class="string">"莱茵哈鲁特·工作闲暇"</span>,</span><br><span class="line">    <span class="string">"爱蜜莉雅·朦胧的睡意"</span>,</span><br><span class="line">    <span class="string">"青年威尔海姆·挥剑练习"</span>,</span><br><span class="line">    <span class="string">"罗兹瓦尔·夜阑已至"</span>,</span><br><span class="line">    <span class="string">"尤里乌斯·王国之剑"</span>,</span><br><span class="line">    <span class="string">"蕾姆·失控的鬼"</span>,</span><br><span class="line">    <span class="string">"特蕾希雅·漫天黄花"</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> * Card_Pool_role4[] = &#123;<span class="string">"安娜塔西亚·交涉时刻"</span>,<span class="string">"菲鲁特·不习惯的礼服"</span>,<span class="string">"菲克丽丝·彼岸花开"</span>,<span class="string">"菲莉丝·猫与猫"</span>,<span class="string">"普莉西亚·傲慢的凝视"</span>,<span class="string">"库珥修·铠甲的英姿"</span>,<span class="string">"威尔海姆·心愿终结"</span>,<span class="string">"爱蜜莉雅·晨间微风"</span>,<span class="string">"碧翠丝·和哥哥一起"</span>,<span class="string">"拉姆窗外的风景"</span>,<span class="string">"蕾姆·饮茗赏花"</span>,<span class="string">"库珥修·公务缠身"</span>,<span class="string">"青年威尔海姆·恋诗追忆"</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> * Card_Pool_role3[] = &#123;<span class="string">"堤比·擦拭眼睛"</span>,<span class="string">"奥托·慌乱的一天"</span>,<span class="string">"阿尔迪巴兰·侍从"</span>,<span class="string">"马可仕·团长的威严"</span>,<span class="string">"蜜蜜·好朋友莱卡"</span>,<span class="string">"库乌德·出征的夙愿"</span>,<span class="string">"黑塔洛·精疲力尽"</span>,<span class="string">"阿顿·打劫"</span>,<span class="string">"阿汉·敲诈"</span>,<span class="string">"菲鲁特·偷窃徽章"</span>,<span class="string">"理卡德·激战"</span>,<span class="string">"罗姆爷·野蛮的做法"</span>,<span class="string">"阿珍·恐吓"</span>,<span class="string">"拉塞尔·商人的秘诀"</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> * Card_Pool_eqp5[] = &#123;<span class="string">"青空下的誓言"</span>,<span class="string">"遵守契约"</span>,<span class="string">"狮子的意志"</span>,<span class="string">"最喜欢的菜肴"</span>,<span class="string">"信任的约定"</span>,<span class="string">"剑圣的名义"</span>,<span class="string">"精灵的祝福"</span>,<span class="string">"渺小的梦想"</span>,<span class="string">"沙提拉传说"</span>,<span class="string">"鬼族的末裔"</span>,<span class="string">"王选之局"</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> * Card_Pool_eqp4[] = &#123;<span class="string">"真实的名字"</span>,<span class="string">"品酒的夜晚"</span>,<span class="string">"挥剑的意义"</span>,<span class="string">"阵营联盟"</span>,<span class="string">"从识字开始"</span>,<span class="string">"满分的笑容"</span>,<span class="string">"待客的红茶"</span>,<span class="string">"孩童送行"</span>,<span class="string">"Victory!"</span>,<span class="string">"喜欢书房的两个人"</span>,<span class="string">"实现的火花"</span>,<span class="string">"亲切的待客之道"</span>,<span class="string">"胜利的清晨"</span>,<span class="string">"骑士对决"</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> * Card_Pool_eqp3[] = &#123;<span class="string">"一秒六连拍"</span>,<span class="string">"厨房的技巧"</span>,<span class="string">"美味的早餐"</span>,<span class="string">"锁链的声响"</span>,<span class="string">"梦幻的手艺"</span>,<span class="string">"龙的故事"</span>,<span class="string">"善心的回报"</span>,<span class="string">"水魔法治疗"</span>,<span class="string">"硬币的魔法"</span>,<span class="string">"平静的一天"</span>,<span class="string">"最后的赏月"</span>,<span class="string">"菲鲁特的住所"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">char</span> ** CardPool[] = &#123;Card_Pool_role5,Card_Pool_role4,Card_Pool_role3,Card_Pool_eqp5,Card_Pool_eqp4,Card_Pool_eqp3&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//未抽中五星前抽奖次数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> lotteryDrawNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//活动概率提升</span></span><br><span class="line"><span class="keyword">char</span> p_role5_increase = <span class="number">0.35</span>;</span><br><span class="line"><span class="keyword">char</span> p_role4_increase = <span class="number">0.35</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机函数种子</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> next = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//线性同余伪随机数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rw_rand</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next = next*<span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(next/<span class="number">65536</span>) % <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rw_srand</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next = seed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    usleep(<span class="number">10</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">t_val</span>;</span></span><br><span class="line">    gettimeofday(&amp;t_val, <span class="literal">NULL</span>);</span><br><span class="line">    rw_srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(t_val.tv_usec*t_val.tv_usec+t_val.tv_usec));</span><br><span class="line">    <span class="keyword">int</span> ret = rw_rand();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 抽奖第一层</span></span><br><span class="line"><span class="comment"> RETURN int :</span></span><br><span class="line"><span class="comment"> -1 err</span></span><br><span class="line"><span class="comment"> 5，4，3 =&gt; 角色卡五四三</span></span><br><span class="line"><span class="comment"> 50,40,30 =&gt; 装备卡五四三</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lotteryDraw_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = getRandom()%remainder_rw;</span><br><span class="line">    <span class="keyword">float</span> ret_1 = (<span class="keyword">float</span>)(ret) / (<span class="keyword">float</span>)(remainder_rw);</span><br><span class="line">    <span class="comment">//    printf("随机数 %d ret_1:%f\n",ret,ret_1);</span></span><br><span class="line">    <span class="comment">/*划分抽奖区间:</span></span><br><span class="line"><span class="comment">     五星角色卡区间为 0 - p_r_5_index</span></span><br><span class="line"><span class="comment">     四星角色卡区间为 p_r_5_index - p_r_4_index</span></span><br><span class="line"><span class="comment">     三星角色卡区间为 p_r_4_index - p_r_3_index</span></span><br><span class="line"><span class="comment">     五星装备卡区间为 p_r_3_index - p_e_5_index</span></span><br><span class="line"><span class="comment">     四星装备卡区间为 p_e_5_index - p_e_4_index</span></span><br><span class="line"><span class="comment">     三星装备卡区间为 p_e_4_index - 1.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">float</span> p_r_5_index , p_r_4_index , p_r_3_index , p_e_5_index , p_e_4_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> p_r_5_increase = lotteryDrawNum &gt; <span class="number">30</span> ? (lotteryDrawNum - <span class="number">30</span>) * increase_single : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> p_r_5_increase_sub = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p_r_5_increase != <span class="number">0</span>) &#123;</span><br><span class="line">        p_r_5_increase_sub = p_r_5_increase/<span class="number">5.</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p_r_5_index = r_5_p + p_r_5_increase;</span><br><span class="line">    p_r_4_index = p_r_5_index + r_4_p - p_r_5_increase_sub;</span><br><span class="line">    p_r_3_index = p_r_4_index + r_3_p - p_r_5_increase_sub;</span><br><span class="line">    p_e_5_index = p_r_3_index + e_5_p - p_r_5_increase_sub;</span><br><span class="line">    p_e_4_index = p_e_5_index + e_4_p - p_r_5_increase_sub;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"num:%d inc:%f other:%f %f %f %f %f %f\n"</span>,lotteryDrawNum,p_r_5_increase,p_r_5_index,p_r_4_index-p_r_5_index,p_r_3_index-p_r_4_index,p_e_5_index-p_r_3_index,p_e_4_index-p_e_5_index,<span class="number">1.0</span>-p_e_4_index);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查找区间2分思想</span></span><br><span class="line">    <span class="keyword">int</span> flag_class = <span class="number">0</span>; <span class="comment">//0位角色卡，1为装备卡</span></span><br><span class="line">    <span class="keyword">if</span> (ret_1 &gt; p_r_3_index) &#123;</span><br><span class="line">        flag_class = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (flag_class == <span class="number">0</span> &amp;&amp; ret_1 &lt; p_r_5_index) &#123; <span class="comment">//5星角色卡</span></span><br><span class="line">        <span class="keyword">return</span> Type_Card_Role5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag_class == <span class="number">0</span> &amp;&amp; ret_1 &lt; p_r_4_index) &#123;<span class="comment">//4星角色卡</span></span><br><span class="line">        <span class="keyword">return</span> Type_Card_Role4;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag_class == <span class="number">0</span> &amp;&amp; ret_1 &lt; p_r_3_index) &#123;<span class="comment">//3星角色卡</span></span><br><span class="line">        <span class="keyword">return</span> Type_Card_Role3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag_class == <span class="number">1</span> &amp;&amp; ret_1 &gt;= p_e_4_index) &#123;<span class="comment">//3星装备卡</span></span><br><span class="line">        <span class="keyword">return</span> Type_Card_EQP3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag_class == <span class="number">1</span> &amp;&amp; ret_1 &gt;= p_e_5_index) &#123;<span class="comment">//4星装备卡</span></span><br><span class="line">        <span class="keyword">return</span> Type_Card_EQP4;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Type_Card_EQP5;<span class="comment">//5星装备卡</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//五星卡处理</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lotteryDraw_2</span><span class="params">(<span class="keyword">enum</span> Type_Card card,<span class="keyword">float</span> activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = getRandom();</span><br><span class="line">    ret = ret % remainder_rw;</span><br><span class="line">    <span class="keyword">float</span> random_num = (<span class="keyword">float</span>)(ret) / (<span class="keyword">float</span>)(remainder_rw);</span><br><span class="line">    <span class="keyword">int</span> num = CardNums[card];</span><br><span class="line">    <span class="keyword">float</span> p = (<span class="number">1.0</span>-activity)/(<span class="keyword">float</span>)num;</span><br><span class="line">    <span class="keyword">int</span> random_index = (<span class="keyword">int</span>)(random_num/p); <span class="comment">//哈希函数</span></span><br><span class="line">    <span class="keyword">if</span> (random_index &gt;= num) &#123;<span class="comment">//特殊卡</span></span><br><span class="line">        random_index -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"恭喜抽中 "</span>);</span><br><span class="line">    <span class="keyword">if</span> (card == Type_Card_Role5) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"5☆☆☆☆☆   角色卡"</span>);</span><br><span class="line">        lotteryDrawNum = <span class="number">0</span>;<span class="comment">//抽中五星角色之后归零重新开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (card == Type_Card_Role4) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"4☆☆☆☆    角色卡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (card == Type_Card_Role3) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"3☆☆☆     角色卡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (card == Type_Card_EQP5) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"5☆☆☆☆☆   星之器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (card == Type_Card_EQP4) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"4☆☆☆☆    星之器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (card == Type_Card_EQP3) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"3☆☆☆     星之器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> * cardName = CardPool[card][random_index];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"     %s\n"</span>,cardName);</span><br><span class="line">    <span class="keyword">return</span> random_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽一次</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lotteryDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lotteryDrawNum ++; <span class="comment">//抽奖次数喜加一</span></span><br><span class="line">    <span class="keyword">int</span> ret_1 = lotteryDraw_1();</span><br><span class="line">    <span class="comment">//    printf("\nrandom - %f\n",random_num);</span></span><br><span class="line">    <span class="keyword">enum</span> Type_Card card = Type_Card_Role3;</span><br><span class="line">    <span class="keyword">float</span> activity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (ret_1) &#123;</span><br><span class="line">        <span class="keyword">case</span> Type_Card_Role5:</span><br><span class="line">        &#123;</span><br><span class="line">            activity = p_role5_increase;</span><br><span class="line">            card = Type_Card_Role5;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Type_Card_Role4:</span><br><span class="line">        &#123;</span><br><span class="line">            activity = p_role4_increase;</span><br><span class="line">            card = Type_Card_Role4;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Type_Card_Role3:</span><br><span class="line">        &#123;</span><br><span class="line">            card = Type_Card_Role3;<span class="comment">//可以不写</span></span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Type_Card_EQP5:</span><br><span class="line">        &#123;</span><br><span class="line">            card = Type_Card_EQP5;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Type_Card_EQP4:</span><br><span class="line">        &#123;</span><br><span class="line">            card = Type_Card_EQP4;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Type_Card_EQP3:</span><br><span class="line">        &#123;</span><br><span class="line">            card = Type_Card_EQP3;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> detail_index = lotteryDraw_2(card, activity);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> card;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dataInit</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="keyword">sizeof</span>(<span class="keyword">char</span>*);</span><br><span class="line">    CardNums[Type_Card_Role5] = <span class="keyword">sizeof</span>(Card_Pool_role5)/<span class="built_in">size</span>;</span><br><span class="line">    CardNums[Type_Card_Role4] = <span class="keyword">sizeof</span>(Card_Pool_role4)/<span class="built_in">size</span>;</span><br><span class="line">    CardNums[Type_Card_Role3] = <span class="keyword">sizeof</span>(Card_Pool_role3)/<span class="built_in">size</span>;</span><br><span class="line">    CardNums[Type_Card_EQP5] = <span class="keyword">sizeof</span>(Card_Pool_eqp5)/<span class="built_in">size</span>;</span><br><span class="line">    CardNums[Type_Card_EQP4] = <span class="keyword">sizeof</span>(Card_Pool_eqp4)/<span class="built_in">size</span>;</span><br><span class="line">    CardNums[Type_Card_EQP3] = <span class="keyword">sizeof</span>(Card_Pool_eqp3)/<span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    dataInit();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> nums = <span class="number">1000000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cardNum[<span class="number">6</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i ++) &#123;</span><br><span class="line">        cardNum[lotteryDraw()]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n抽取：%d 次：\n"</span>,nums);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"五星角色卡 %d 张\n"</span>,cardNum[Type_Card_Role5]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"四星角色卡 %d 张\n"</span>,cardNum[Type_Card_Role4]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"三星角色卡 %d 张\n"</span>,cardNum[Type_Card_Role3]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"五星星之卡 %d 张\n"</span>,cardNum[Type_Card_EQP5]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"四星星之卡 %d 张\n"</span>,cardNum[Type_Card_EQP4]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"三星星之卡 %d 张\n"</span>,cardNum[Type_Card_EQP3]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、需求分析&quot;&gt;&lt;a href=&quot;#一、需求分析&quot; class=&quot;headerlink&quot; title=&quot;一、需求分析&quot;&gt;&lt;/a&gt;一、需求分析&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;基于2020-04-30版本分析，&lt;br&gt;现在5星角色爱蜜莉雅·朦胧的睡意以及怠情
      
    
    </summary>
    
    
      <category term="个人理解" scheme="http://yoursite.com//categories/234/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="杂谈" scheme="http://yoursite.com//tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 10 红黑树</title>
    <link href="http://yoursite.com/2020/04/29/DataStructure10/"/>
    <id>http://yoursite.com/2020/04/29/DataStructure10/</id>
    <published>2020-04-29T01:26:58.176Z</published>
    <updated>2020-04-30T03:09:53.542Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。</p></blockquote><h2 id="第21-22课-红黑树"><a href="#第21-22课-红黑树" class="headerlink" title="第21-22课 - - - - - - -红黑树"></a>第21-22课 - - - - - - -红黑树</h2><h3 id="1-2-3查找树。"><a href="#1-2-3查找树。" class="headerlink" title="1.2-3查找树。"></a>1.2-3查找树。</h3><h4 id="a-定义"><a href="#a-定义" class="headerlink" title="a.定义"></a>a.定义</h4><blockquote><p><strong>2-3树</strong>:由2节点和3节点这两种种节点构成的树。</p></blockquote><blockquote><p><strong>2节点</strong>:1key+2child，一个值加两个子节点。类似排序二叉树的节点，左子节点的值小于它，右子节点的值大于它。<br><img src="/2020/04/29/DataStructure10/23tree1.png" alt></p></blockquote><blockquote><p><strong>3节点</strong>:2key+3child,就是通过两个key分为三个范围：<br>range1 &lt; key1 &lt; range2 &lt; key2 &lt; range3<br>其中的三个子节点的取值范围分别在range1,range2和range3中。<br><img src="/2020/04/29/DataStructure10/23tree2.png" alt></p></blockquote><h4 id="b-插入操作"><a href="#b-插入操作" class="headerlink" title="b.插入操作"></a>b.插入操作</h4><p>第一步，先查找对应的元素应该被插入的位置。<br>第二步，分两种情况操作。<br>如果查找的位置结束于2节点，那么直接插入，形成一个3节点。<br>如果查找的位置结束于3节点，那么需要处理的方式有三种。<br>1).只有一个3节点的树的情况下：<br><img src="/2020/04/29/DataStructure10/23tree3.png" alt><br>这种情况下先将插入数放入3节点构造成一个4节点，然后提取中值(中键)分裂成一个2节点带两个子节点。</p><p>2).插入节点为3节点，插入节点的父节点为2节点的情况下：<br> <img src="/2020/04/29/DataStructure10/23tree4.png" alt><br>这种情况下先将插入数放入3节点构造成一个4节点，然后将4节点分裂成两个2节点，并且提取中值(中键)移到父节点，将父节点构造成一个3节点。</p><p>3).插入节点为3节点，插入节点的父节点为3节点的情况下：<br> <img src="/2020/04/29/DataStructure10/23tree5.png" alt><br>这种情况下先将插入数放入3节点构造成一个4节点，然后将4节点分裂成两个2节点，并且提取中值(中键)移到父节点，将父节点构造成一个4节点。然后父节点提取中值向上分裂，知道分裂到情况2，处理完成后没有4节点结束。</p><blockquote><p>除了相关的结点和链接之外不必修改或者检查树的其他部分。每次变换中，变更的链接数量不会超过一个很小的常数。所有局部变换都不会影响整棵树的有序性和平衡性。</p></blockquote><h4 id="c-删除操作"><a href="#c-删除操作" class="headerlink" title="c.删除操作"></a>c.删除操作</h4><p>1.删除的元素是叶子节点并且含有两个元素<br> <img src="/2020/04/29/DataStructure10/23tree6.png" alt><br>2.删除的元素是叶子节点并且只有1个元素的话,但是父节点的右节点函数含有两个元素<br> <img src="/2020/04/29/DataStructure10/23tree7.png" alt><br> 3.删除的元素是叶子节点,但是父节点的右节点只有一个元素<br>  <img src="/2020/04/29/DataStructure10/23tree8.png" alt><br>4.如果删除的叶子节点的父结点是两个元素的话并且父节点的左右的左结点还可以插入<br>  <img src="/2020/04/29/DataStructure10/23tree9.png" alt><br>5.如果删除的是满二叉树<br><img src="/2020/04/29/DataStructure10/23tree10.png" alt><br>6.删除的是非叶子节点并且只有一个元素<br><img src="/2020/04/29/DataStructure10/23tree11.png" alt><br>7.删除的是非叶子节点并且只有两个元素<br>情况1：<br><img src="/2020/04/29/DataStructure10/23tree12.png" alt><br>情况2：<br><img src="/2020/04/29/DataStructure10/23tree13.png" alt></p><h4 id="d-2-3树的优点"><a href="#d-2-3树的优点" class="headerlink" title="d.2-3树的优点"></a>d.2-3树的优点</h4><blockquote><p>2-3树在最坏情况下仍有较好的性能。每个操作中处理每个结点的时间都不会超过一个很小的常数，且这两个操作都只会访问一条路径上的结点，所以任何查找或者插入的成本都肯定不会超过对数级别。</p></blockquote><p>完美平衡的2-3树要平展的多。例如，含有10亿个结点的一颗2-3树的高度仅在19到30之间。我们最多只需要访问30个结点就能在10亿个键中进行任意查找和插入操作。</p><h4 id="e-2-3树的缺点"><a href="#e-2-3树的缺点" class="headerlink" title="e.2-3树的缺点"></a>e.2-3树的缺点</h4><p>我们需要维护两种不同类型的结点，查找和插入操作的实现需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。<br>平衡一棵树的初衷是为了消除最坏情况，但我们希望这种保障所需的代码能够越少越好。</p><h3 id="2-红黑树"><a href="#2-红黑树" class="headerlink" title="2.红黑树"></a>2.红黑树</h3><p>红黑树其实用红节点标识3节点，黑节点标识2节点的2-3树。</p><blockquote><p>红节点，其实是标识连接到这个节点的边是红色的。<br>红黑树的定义就是满足3个条件的二叉查找树：<br>1.红连接均为左连接。<br>2.没有一个节点同时和两条红连接相连。(因为如果有超过一条红连接，那么3节点就不再是3节点，而是更高)<br>3.该树是完美黑色平衡的，即任意空连接到根节点的路径上的黑链接数量相同。</p></blockquote><blockquote><p><strong>红黑树正统官方定义</strong>:<br>1.红黑树是一棵排序二叉树。<br>2.节点是红色或黑色。<br>根是黑色。<br>所有叶子都是黑色（叶子是NIL节点）。<br>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）<br>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</p></blockquote><blockquote><p>参考资料:<br>[1]  <a href="https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf" target="_blank" rel="noopener">https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf</a><br>[2]  <a href="https://blog.csdn.net/yang_yulei/article/details/26066409" target="_blank" rel="noopener">https://blog.csdn.net/yang_yulei/article/details/26066409</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第21-22课-红黑树&quot;&gt;&lt;a href=&quot;#第21-22课-红黑树&quot; class=&quot;headerlink&quot; title=&quot;第21-2
      
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 09 二叉树</title>
    <link href="http://yoursite.com/2020/04/27/DataStructure09/"/>
    <id>http://yoursite.com/2020/04/27/DataStructure09/</id>
    <published>2020-04-27T11:21:41.163Z</published>
    <updated>2020-04-29T01:24:55.023Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。</p></blockquote><h2 id="第19课-二叉树-上"><a href="#第19课-二叉树-上" class="headerlink" title="第19课 - - - - - - -二叉树(上)"></a>第19课 - - - - - - -二叉树(上)</h2><h3 id="一、树"><a href="#一、树" class="headerlink" title="一、树"></a>一、树</h3><h4 id="概念1："><a href="#概念1：" class="headerlink" title="概念1："></a>概念1：</h4><p><img src="/2020/04/27/DataStructure09/binaryTree1.png" alt></p><blockquote><p>A 节点是 B 节点的<strong>父节点</strong>，B 节点是 A 节点的<strong>子节点</strong>。<br> B、C、D 这三 个节点的父节点是同一个节点，所以它们之间互称为<strong>兄弟节点</strong>。<br> 没有父节点的节点叫 作<strong>根节点</strong>，也就是图中的节点 E。<br> 没有子节点的节点叫作<strong>叶子节点</strong>或者<strong>叶节点</strong>，比如 图中的 G、H、I、J、K、L 都是叶子节点。</p></blockquote><h4 id="概念2："><a href="#概念2：" class="headerlink" title="概念2："></a>概念2：</h4><p><img src="/2020/04/27/DataStructure09/binaryTree2.png" alt></p><blockquote><p><strong>高度</strong>：节点到叶子节点的最长路径(边数)<br><strong>深度</strong>：根节点到这个节点所经历的边的个数<br><strong>节点的层数</strong> ： 节点的深度+1<br><strong>树的高度</strong> = 根节点的高度</p></blockquote><h3 id="二、二叉树"><a href="#二、二叉树" class="headerlink" title="二、二叉树"></a>二、二叉树</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><p><strong>二叉树</strong>，每个节点最多有两个子节点，分别是<strong>左子节点</strong>和<strong>右子节点</strong>。<br><img src="/2020/04/27/DataStructure09/binaryTree3.png" alt><br><strong>满二叉树</strong>：编号 2 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左 右两个子节点。<br><strong>完全二叉树</strong>：编号 3 的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除 了最后一层，其他层的节点个数都要达到最大。（主要从存储去看）</p><h4 id="2-二叉树的存储"><a href="#2-二叉树的存储" class="headerlink" title="2.二叉树的存储"></a>2.二叉树的存储</h4><p><strong>a.基于指针或者引用的二叉链式存储法</strong><br><img src="/2020/04/27/DataStructure09/binaryTree4.png" alt></p><blockquote><p>每个节点有三 个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就 可以通过左右子节点的指针，把整棵树都串起来。</p></blockquote><p><strong>b.基于数组的顺序存储法</strong><br><img src="/2020/04/27/DataStructure09/binaryTree5.png" alt></p><blockquote><p>把根节点存储在下标 i = 1 的位置，那左子节点 存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。以此类推，B 节点的 左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位 置。</p></blockquote><p>如果不是完全二叉树就会浪费存储空间:<br><img src="/2020/04/27/DataStructure09/binaryTree6.png" alt></p><blockquote><p><strong>堆其实就是一种完全二叉树，最常用的存储方式 就是数组。</strong></p></blockquote><h4 id="3-二叉树的遍历"><a href="#3-二叉树的遍历" class="headerlink" title="3.二叉树的遍历"></a>3.二叉树的遍历</h4><p><img src="/2020/04/27/DataStructure09/binaryTree7.png" alt><br>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最 后打印它的右子树。<br>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后 打印它的右子树。<br>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树， 最后打印这个节点本身。</p><blockquote><p><strong>实际上，二叉树的前、中、后序遍历就是一个递归的过程。</strong></p></blockquote><p>代码实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree_Node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tree_Node</span> * <span class="title">leftChild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tree_Node</span> * <span class="title">rightChild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node * root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,root-&gt;data);</span><br><span class="line">    preOrder(root-&gt;leftChild);</span><br><span class="line">    preOrder(root-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intOrder</span><span class="params">(Node * root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(root-&gt;leftChild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,root-&gt;data);</span><br><span class="line">    preOrder(root-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node * root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(root-&gt;leftChild);</span><br><span class="line">    preOrder(root-&gt;rightChild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,root-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-二叉树遍历的时间复杂度"><a href="#4-二叉树遍历的时间复杂度" class="headerlink" title="4.二叉树遍历的时间复杂度"></a>4.二叉树遍历的时间复杂度</h4><blockquote><p>从前面画的前、中、后序遍历的顺序图，可以看出来，每个节点最多会被访问两次，所以 遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说二叉树遍历的时间复杂度是 O(n)。</p></blockquote><h3 id="三、完全二叉树适合用数组来存储"><a href="#三、完全二叉树适合用数组来存储" class="headerlink" title="三、完全二叉树适合用数组来存储"></a>三、完全二叉树适合用数组来存储</h3><blockquote><p>二叉树既可以用链式存储，也可以用数组顺序存储。数组顺序存储的方式比较适合完全二叉 树，其他类型的二叉树用数组存储会比较浪费存储空间。</p></blockquote><h3 id="四、二叉树的基础编码"><a href="#四、二叉树的基础编码" class="headerlink" title="四、二叉树的基础编码"></a>四、二叉树的基础编码</h3><h4 id="1-从数组创建完全二叉树"><a href="#1-从数组创建完全二叉树" class="headerlink" title="1.从数组创建完全二叉树"></a>1.从数组创建完全二叉树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">createNode</span><span class="params">(<span class="keyword">int</span> * nums,<span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="built_in">size</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = nums[index];</span><br><span class="line">    node-&gt;leftChild = createNode(nums, <span class="built_in">size</span>, <span class="number">2</span>*(index+<span class="number">1</span>)<span class="number">-1</span>);</span><br><span class="line">    node-&gt;rightChild = createNode(nums, <span class="built_in">size</span>, <span class="number">2</span>*(index+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组存储的完全二叉树生成链式存储的完全二叉树</span></span><br><span class="line"><span class="function">Node * <span class="title">createBinaryTreeByArray</span><span class="params">(<span class="keyword">int</span> * nums,<span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createNode(nums, <span class="built_in">size</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><h2 id="第20课-二叉树-下"><a href="#第20课-二叉树-下" class="headerlink" title="第20课 - - - - - - -二叉树(下)"></a>第20课 - - - - - - -二叉树(下)</h2><h3 id="一、二叉查找树"><a href="#一、二叉查找树" class="headerlink" title="一、二叉查找树"></a>一、二叉查找树</h3><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h4><blockquote><p><strong>二叉查找树</strong>：在树的任意一个节点，左子树中的每个节点的值都要小于这个节点的值，右子树节点的值都大于这个节点的值。</p></blockquote><h4 id="2-插入操作"><a href="#2-插入操作" class="headerlink" title="2.插入操作"></a>2.插入操作</h4><p>二叉排序树的插入过程：<br>第一步、先判断当前节点与插入节点的值大小。<br>第二步1、当插入值大于节点值，判断右子树是否为空，<br>    如果右子树为空，则创建右子树节点并赋值。<br>    如果右子树不为空，则去判断右子树节点和插入值大小，回到第一步<br>第二步2、当插入值小于节点值，判断左子树是否为空，<br>    如果左子树为空，则创建左子树节点并赋值。<br>    如果左子树不为空，则去判断左子树节点和插入值大小，回到第一步<br><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST_insert</span><span class="params">(Node * root,<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data &gt; p-&gt;data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rightChild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                p-&gt;rightChild = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">                &#123;<span class="comment">//初始化</span></span><br><span class="line">                    p-&gt;rightChild-&gt;data = data;</span><br><span class="line">                    p-&gt;rightChild-&gt;leftChild = <span class="literal">NULL</span>;</span><br><span class="line">                    p-&gt;rightChild-&gt;rightChild = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p = p-&gt;rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;leftChild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                p-&gt;leftChild = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">                &#123;<span class="comment">//初始化</span></span><br><span class="line">                    p-&gt;leftChild-&gt;data = data;</span><br><span class="line">                    p-&gt;leftChild-&gt;leftChild = <span class="literal">NULL</span>;</span><br><span class="line">                    p-&gt;leftChild-&gt;rightChild = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p = p-&gt;leftChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-二叉查找树的创建"><a href="#3-二叉查找树的创建" class="headerlink" title="3.二叉查找树的创建"></a>3.二叉查找树的创建</h4><p>二叉查找树的创建过程就是一个个节点的插入过程<br><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *  <span class="title">createBST</span><span class="params">(<span class="keyword">int</span> *nums,<span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">NULL</span> || <span class="built_in">size</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * root = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    root-&gt;data = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span>; i ++) &#123;</span><br><span class="line">        BST_insert(root, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-查找操作"><a href="#4-查找操作" class="headerlink" title="4.查找操作"></a>4.查找操作</h4><p>查找过程<br>第一步：先判断当前节点的值是否与查找值相同。<br>如果查找值相同，直接返回节点。<br>如果查找值不相同进入第二步：<br>第二步：判断查找值和当前节点值的大小关系：<br>如果查找值大于当前节点值，就去右节点查找，返回第一步。<br>如果查找值小于当前节点值，就去左节点查找，返回第一步。<br><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">findInBST</span><span class="params">(Node * root,<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * findP = root;</span><br><span class="line">    <span class="keyword">while</span> (findP != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == findP-&gt;data) &#123;</span><br><span class="line">            <span class="keyword">return</span> findP;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data &gt; findP-&gt;data) &#123;</span><br><span class="line">            findP = findP-&gt;rightChild;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data &lt; findP-&gt;data) &#123;</span><br><span class="line">            findP =  findP-&gt;leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-删除操作"><a href="#5-删除操作" class="headerlink" title="5.删除操作"></a>5.删除操作</h4><p>删除的节点有三种情况。<br>第一种，没有子节点，可以直接将其父节点指向它的指针设置为NULL，并且释放它的内存。<br>第二种，有一个子节点，可以将其父节点指向它的指针指向子节点，并且释放它的内存。<br>第三种，有两个子节点，需要找到右子树的最小节点，替换当前节点，并且释放当前节点的内存。<br>编码的过程：<br>先查找到相应的节点，并且记录所在节点的父节点。<br>如果没有找到节点，直接返回。<br>如果找到节点。则判断删除的三种情况。<br>先判断是不是有双子节点的情况。<br>如果是，则找到该节点的右子树的最小节点。将节点的值修改为最小节点的值，然后将找到的几点指针和父指针都指向最小节点。<br>在综合判断有一个子节点还是没有子节点的情况。如果没有子节点，父节指向该节点的指针置空，释放节点内存。<br>如果有子节点，判断是左子节点还是右子节点。将父节点指向相应的子节点，然后释放节点内存。<br><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *  <span class="title">BST_delete</span><span class="params">(Node * root,<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node * p = root;</span><br><span class="line">    Node * pp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data &gt; p-&gt;data) &#123;</span><br><span class="line">            pp = p;</span><br><span class="line">            p = p-&gt;rightChild;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (data &lt; p-&gt;data)&#123;</span><br><span class="line">            pp = p;</span><br><span class="line">            p = p-&gt;leftChild;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;data == data) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123; <span class="comment">//没找到直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断有两个子节点的情况</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;leftChild != <span class="literal">NULL</span> &amp;&amp; p-&gt;rightChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Node * minP = p-&gt;rightChild;</span><br><span class="line">        Node * minPP = p;</span><br><span class="line">        <span class="keyword">while</span> (minP-&gt;leftChild != <span class="literal">NULL</span>) &#123;  <span class="comment">//没有左子树的子节点最小</span></span><br><span class="line">            minPP = minP;</span><br><span class="line">            minP = minP-&gt;leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data = minP-&gt;data; <span class="comment">//把最小值赋值给该删除的节点，</span></span><br><span class="line">        p = minP;<span class="comment">//然后删除最小值所在位置的节点。</span></span><br><span class="line">        pp = minPP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除的节点是叶子节点，或者只有一个子节点的节点</span></span><br><span class="line">    Node * child;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;leftChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        child = p-&gt;leftChild;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;rightChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        child = p-&gt;rightChild;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        child = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pp == <span class="literal">NULL</span>) &#123; <span class="comment">//删除根节点</span></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pp-&gt;leftChild == p)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        pp-&gt;leftChild = child;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pp-&gt;rightChild == p)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        pp-&gt;rightChild = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-二叉查找树的其他操作"><a href="#6-二叉查找树的其他操作" class="headerlink" title="6.二叉查找树的其他操作"></a>6.二叉查找树的其他操作</h4><h5 id="a-快速地查找最大节点和最小节点、"><a href="#a-快速地查找最大节点和最小节点、" class="headerlink" title="a.快速地查找最大节点和最小节点、"></a>a.快速地查找最大节点和最小节点、</h5><blockquote><p>最大节点就是最右没有右子树的叶子。<br>最小节点就是最左没有左子树的叶子。</p></blockquote><h5 id="b-前驱节点和后继节点"><a href="#b-前驱节点和后继节点" class="headerlink" title="b.前驱节点和后继节点"></a>b.前驱节点和后继节点</h5><blockquote><p>前驱节点可以通过多加一个指针记录寻找过程。<br>后继节点直接获取。</p></blockquote><h5 id="c-二叉树的高度"><a href="#c-二叉树的高度" class="headerlink" title="c.二叉树的高度"></a>c.二叉树的高度</h5><blockquote><blockquote><p>待定</p></blockquote></blockquote><h4 id="7-二叉查找树输出有序数列"><a href="#7-二叉查找树输出有序数列" class="headerlink" title="7.二叉查找树输出有序数列"></a>7.二叉查找树输出有序数列</h4><blockquote><p>中序遍历二叉查找树， 可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。</p></blockquote><h3 id="二、支持重复数据的二叉查找树"><a href="#二、支持重复数据的二叉查找树" class="headerlink" title="二、支持重复数据的二叉查找树"></a>二、支持重复数据的二叉查找树</h3><blockquote><p>当利用对象的某个字段作为键值(key)来构建二叉查找树，对象中的其他字段叫作卫星数据。<br><strong>存储的两个对象键值相同</strong>如何解决？</p></blockquote><h4 id="1-相同数据存在同一个树形节点上"><a href="#1-相同数据存在同一个树形节点上" class="headerlink" title="1.相同数据存在同一个树形节点上"></a>1.相同数据存在同一个树形节点上</h4><p>通过链表和 支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p><h4 id="2-把这个新插入的数据当作大于这个节点的值来处理"><a href="#2-把这个新插入的数据当作大于这个节点的值来处理" class="headerlink" title="2.把这个新插入的数据当作大于这个节点的值来处理"></a>2.把这个新插入的数据当作大于这个节点的值来处理</h4><p>按这种处理情况:</p><blockquote><p>当要查找数据的时候，遇到值相同的节点，并不停止查找操作，而是继续在右子树中查 找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。<br>对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方 法，依次删除。</p></blockquote><h3 id="三、二叉查找树的时间复杂度分析"><a href="#三、二叉查找树的时间复杂度分析" class="headerlink" title="三、二叉查找树的时间复杂度分析"></a>三、二叉查找树的时间复杂度分析</h3><h4 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1.时间复杂度"></a>1.时间复杂度</h4><p>不管操作是插入、删除还是查找，<strong>时间复杂度其实都跟树的高度成正比，也就是 O(height)</strong>。</p><h4 id="2-树的高度"><a href="#2-树的高度" class="headerlink" title="2.树的高度"></a>2.树的高度</h4><p>完全二叉树的层数小于等于 log(n) + 1，也就是说，完全二叉树的高度小于等于 log(n)。</p><h3 id="四、散列表和二叉树对比"><a href="#四、散列表和二叉树对比" class="headerlink" title="四、散列表和二叉树对比"></a>四、散列表和二叉树对比</h3><blockquote><p>1.散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二 叉查找树来说，只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序 列。</p></blockquote><blockquote><p>2.散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能 不稳定，但是在工程中，平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</p></blockquote><blockquote><p>3.笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的 存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈 希函数的耗时，也不一定就比平衡二叉查找树的效率高。</p></blockquote><blockquote><p>4.散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲 突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题 的解决方案比较成熟、固定。</p></blockquote><blockquote><p>5.为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲 突的散列表，不然会浪费一定的存储空间。</p></blockquote><p>综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲 突。在实际的开发过程中，需要结合具体的需求来选择使用哪一个。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第19课-二叉树-上&quot;&gt;&lt;a href=&quot;#第19课-二叉树-上&quot; class=&quot;headerlink&quot; title=&quot;第19课 - 
      
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 08 哈希算法</title>
    <link href="http://yoursite.com/2020/04/25/DataStructure08/"/>
    <id>http://yoursite.com/2020/04/25/DataStructure08/</id>
    <published>2020-04-25T05:11:16.768Z</published>
    <updated>2020-04-27T05:40:40.700Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。</p></blockquote><h2 id="第17课-哈希算法-上"><a href="#第17课-哈希算法-上" class="headerlink" title="第17课 - - - - - - -哈希算法(上)"></a>第17课 - - - - - - -哈希算法(上)</h2><h3 id="一、哈希算法"><a href="#一、哈希算法" class="headerlink" title="一、哈希算法"></a>一、哈希算法</h3><p>任意长度的二进制串映射为固定长度的二进制串，这个映射的规则就是<strong>哈希算法</strong>。<br>映射出的固定长度的二进制串就是<strong>哈希值</strong>。</p><h3 id="二、哈希算法的应用-上"><a href="#二、哈希算法的应用-上" class="headerlink" title="二、哈希算法的应用(上)"></a>二、哈希算法的应用(上)</h3><h4 id="1-安全加密"><a href="#1-安全加密" class="headerlink" title="1.安全加密"></a>1.安全加密</h4><p>通过哈希算法加密以后，很难根据哈希值反向推导出原始数据，可以有效防止原始数据泄露。</p><blockquote><p>鸽巢原理：如果有10个鸽巢，有11只鸽子，那么肯定有一个鸽巢中的鸽子数量多于1。<br>哈希算法之所以无法做到零冲突,是因为需要映射的二进制数据是无穷的，但是有限位的哈希结果却不是无穷的。</p></blockquote><h4 id="2-唯一标识"><a href="#2-唯一标识" class="headerlink" title="2.唯一标识"></a>2.唯一标识</h4><p>可以通过取整个文件、或者截取部分文件求哈希值，将哈希值作为文件的唯一标识。</p><blockquote><p>例如实现一个图库<br>可以把每个图片都进行处理得到一个唯一标识，将标识和图片在图库中的路径信息存储在散列表中。<br>当插入某个图片是不是在图库中的时候，我们先通过哈希算法对这个图片取唯一标识，然后在散列表中查询是否存在。<br>如果不存在，就说明不在图库中；<br>如果存在，就再通过散列表中存储的文件路径，获取这个已经存在的图片，和插入图片做全量对比，看是否完全一样。<br>如果一样，说明已经存在。<br>如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。</p></blockquote><h4 id="3-数据校验"><a href="#3-数据校验" class="headerlink" title="3.数据校验"></a>3.数据校验</h4><p>通过BT协议下载的文件。可以通过下面思路实现校验。</p><blockquote><p>服务器通过哈希算法，对100个文件块，分别取哈希值，并且保存在种子文件中。<br>当客户端下载的时候，可以通过相同的哈希算法对下载的文件块进行哈希计算，并且和种子文件保存的哈希值做比对。<br>如果不同，说明这个文件块不完整，或者被篡改了。需要重新从其他宿主机器上下载这个文件块。</p></blockquote><h4 id="4-散列函数"><a href="#4-散列函数" class="headerlink" title="4.散列函数"></a>4.散列函数</h4><p>用于哈希表进行散列。<br>需要注意散列以后的值，是否能平均分布。以及哈希函数的执行快慢。<br>均匀分布会减少散列冲突。哈希函数执行的快慢直接决定查找删除插入操作的快慢。</p><h3 id="三、如何防止数据库中的用户信息被脱库"><a href="#三、如何防止数据库中的用户信息被脱库" class="headerlink" title="三、如何防止数据库中的用户信息被脱库"></a>三、如何防止数据库中的用户信息被脱库</h3><p>将用户的密码通过加盐的方式组合，增加密码的复杂度，然后拿组合之后的字符串做哈希算法加密。然后保存到数据库中。</p><blockquote><p>即使这样也只是增加破解的难度，增加了攻击的成本。</p></blockquote><h2 id="第18课-哈希算法-下"><a href="#第18课-哈希算法-下" class="headerlink" title="第18课 - - - - - - -哈希算法(下)"></a>第18课 - - - - - - -哈希算法(下)</h2><h3 id="一、哈希算法的应用-下"><a href="#一、哈希算法的应用-下" class="headerlink" title="一、哈希算法的应用(下)"></a>一、哈希算法的应用(下)</h3><h4 id="1-负载均衡"><a href="#1-负载均衡" class="headerlink" title="1.负载均衡"></a>1.负载均衡</h4><p>负载均衡的算法有很多，比如:轮询、随机、加权轮询等。<br>可以通过哈希算法实现一个会话粘滞的负载均衡算法。</p><blockquote><p>会话粘滞(session sticky)：在同一个客户端上，在一次会话中，所有的请求都路由到同一台服务器上。<br>通过哈希算法，对客户端IP地址，或者会话ID计算哈希值。将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该背路由到的服务器编号。</p></blockquote><h4 id="2-数据分片"><a href="#2-数据分片" class="headerlink" title="2.数据分片"></a>2.数据分片</h4><p><strong>a.如何统计”搜索关键词”出现的次数？</strong><br>(假如有 1T 的日志文件，这里面记录了用户的搜索关键词,想要快速统计出每个关键词被搜索的次数)</p><blockquote><p>可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。</p></blockquote><p>对日志文件进行分片，多台计算机读取分片的日志文件中的搜索关键词。<br>读出搜索关键词后，通过哈希函数计算哈希值，然后对哈希值对n取模，得到应该被分配到处理数据机器编号。（n就是最后进行处理的机器的总数。）<br>这样，哈希值相同的搜索关键词就被分配到了同一个机器上。也就是说，同一个搜索关键词被分配到同一台机器上进行处理。每台机器分别统计关键词出现的次数，最终合并起来就是最终的结果。<br><strong>b.如何快速判断图片是否在图库中?</strong><br>散列表中每个数据单元包含两个信息，哈希值和图片文件的路径。假设通过 MD5 来计 算哈希值，那长度就是 128 比特，也就是 16 字节。文件路径长度的上限是 256 字节，可以假设平均长度是 128 字节。如果用链表法来解决冲突，那还需要存储指针，指 针只占用 8 字节。所以，散列表中每个数据单元就占用 152 字节(这里只是估算，并不准 确)。<br>假设一台机器的内存大小为 2GB，散列表的装载因子为 0.75，那一台机器可以给大约 1000 万(2GB*0.75/152)张图片构建散列表。所以，如果要对 1 亿张图片构建索引，需 要大约十几台机器。在工程中，这种估算还是很重要的，能事先对需要投入的资源、 资金有个大概的了解，能更好地评估解决方案的可行性。<br>实际上，针对这种海量数据的处理问题，都可以采用多机分布式处理。借助这种分片的 思路，可以突破单机内存、CPU 等资源的限制。</p><h4 id="3-分布式存储"><a href="#3-分布式存储" class="headerlink" title="3.分布式存储"></a>3.分布式存储</h4><p>通过<strong>一致性哈希算法</strong>解决分布式机器扩容后数据迁移问题。</p><blockquote><p>一致性哈希算法<br>假设有 k 个机器，数据的哈希值的范围是 [0, MAX]。将整个范围划分成 m 个小 区间(m 远大于 k)，每个机器负责 m/k 个小区间。当有新机器加入的时候，就将某 几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移 数据，也保持了各个机器上数据数量的均衡。</p></blockquote><h4 id="4-哈希算法在分布式系统中的应用。"><a href="#4-哈希算法在分布式系统中的应用。" class="headerlink" title="4.哈希算法在分布式系统中的应用。"></a>4.哈希算法在分布式系统中的应用。</h4><blockquote><p>在负载均衡应用中，利用哈希算法替代映射表，可以实现一个会话粘滞的负载均衡策略。在 数据分片应用中，通过哈希算法对处理的海量数据进行分片，多机分布式处理，可以突破单 机资源的限制。在分布式存储应用中，利用一致性哈希算法，可以解决缓存等分布式系统的 扩容、缩容导致数据大量搬移的难题。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第17课-哈希算法-上&quot;&gt;&lt;a href=&quot;#第17课-哈希算法-上&quot; class=&quot;headerlink&quot; title=&quot;第17课 
      
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>H.264 码率</title>
    <link href="http://yoursite.com/2020/04/24/H264bitrate/"/>
    <id>http://yoursite.com/2020/04/24/H264bitrate/</id>
    <published>2020-04-24T09:12:01.807Z</published>
    <updated>2020-04-30T01:18:27.769Z</updated>
    
    <content type="html"><![CDATA[<h3 id="压缩率"><a href="#压缩率" class="headerlink" title="压缩率"></a>压缩率</h3><blockquote><p>图像总像素存储体积/压缩后H.264 = 压缩率<br>通常情况下，同一段视频，压缩率越高，解码后的图像画质越差。<br>影响压缩率的因素非常多。<br>压缩率和图像相关：如果是静止画面，压缩率会非常大。画面运动越剧烈，压缩率就越小。画面噪点越多，压缩率越小。画面内部相邻像素相似度越低，压缩率越小。等等。<br>压缩率同时还和编码策略相关。例如：b帧越多，压缩率越大、GOP越大，压缩率越大等等。</p></blockquote><h3 id="那么多大的H-264码率是合适的呢"><a href="#那么多大的H-264码率是合适的呢" class="headerlink" title="那么多大的H.264码率是合适的呢"></a>那么多大的H.264码率是合适的呢</h3><h4 id="1-根据预期的理想比特率共识计算"><a href="#1-根据预期的理想比特率共识计算" class="headerlink" title="1.根据预期的理想比特率共识计算"></a>1.根据预期的理想比特率共识计算</h4><p><strong>[图像宽度] x [图像高度] x [帧速率] x [运动等级] x 0.07(压缩比系数) = [所需比特率]</strong></p><blockquote><p>根据<font color="blue"><a href="https://issuu.com/konu/docs/h264_primer" target="_blank" rel="noopener">https://issuu.com/konu/docs/h264_primer</a></font>这里提供的公式进行计算，<br>1080p30fps的视频在画质和压缩率适配相对较好的情况下为：<br><strong>1920*1080*30*2*0.07 = 8709120 bps = 8505kbps。</strong></p></blockquote><h4 id="2-根据Video-Streaming-Primer提供的信息。"><a href="#2-根据Video-Streaming-Primer提供的信息。" class="headerlink" title="2.根据Video Streaming Primer提供的信息。"></a>2.根据Video Streaming Primer提供的信息。</h4><p><font color="blue"><a href="https://www.bogotobogo.com/VideoStreaming/Files/Video_streaming_etc/Video%20Streaming%201.12.pdf" target="_blank" rel="noopener">Video Streaming Primer</a></font><br>1080p30fps用于电视和广播的码率应该在15Mbps = 1.875MBps。</p><h4 id="3-自己计算"><a href="#3-自己计算" class="headerlink" title="3.自己计算"></a>3.自己计算</h4><blockquote><p>YUV420存储一个像素点需要1.5个字节;<br>YUV422存储一个像素点需要2个字节;<br>YUV444存储一个像素点需要3个字节;</p></blockquote><p>一帧包含<strong>1080*1920 = 2073600</strong> 个像素。<br>iOS采集一般是YUV420格式，所以一个像素点需要1.5个字节存储。<br>即:一帧需要<strong>2073600*1.5 = 3110400个字节 = 3037.5kB = 24300kb</strong><br>一秒钟30帧就需要：<strong>24300*30 = 729000kbps</strong>;<br>如果压缩比为50倍则：<strong>729000/50 = 14580kbps</strong>;<br>如果压缩比为150倍则：<strong>729000/150 = 4860kbps</strong>;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;压缩率&quot;&gt;&lt;a href=&quot;#压缩率&quot; class=&quot;headerlink&quot; title=&quot;压缩率&quot;&gt;&lt;/a&gt;压缩率&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;图像总像素存储体积/压缩后H.264 = 压缩率&lt;br&gt;通常情况下，同一段视频，压缩率越高，解码后的图像画
      
    
    </summary>
    
    
      <category term="个人理解" scheme="http://yoursite.com//categories/234/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com//tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 07 散列表</title>
    <link href="http://yoursite.com/2020/04/24/DataStructure07/"/>
    <id>http://yoursite.com/2020/04/24/DataStructure07/</id>
    <published>2020-04-24T06:31:22.298Z</published>
    <updated>2020-04-30T01:19:01.093Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。</p></blockquote><h2 id="第14课-散列表-上"><a href="#第14课-散列表-上" class="headerlink" title="第14课 - - - - - - -散列表(上)"></a>第14课 - - - - - - -散列表(上)</h2><h3 id="一、什么是散列表"><a href="#一、什么是散列表" class="headerlink" title="一、什么是散列表"></a>一、什么是散列表</h3><blockquote><p>散列表就是，通过一个函数计算将数据压缩转化为一个数组的下标，并将数据存储在这个数组的该下标所在内存中的数据结构。这个函数就是<strong>散列函数</strong>，散列表是基于数组的扩展(主要利用数组随机访问时间复杂度为O(1)的优点)。</p></blockquote><h3 id="二、如何构造散列函数"><a href="#二、如何构造散列函数" class="headerlink" title="二、如何构造散列函数"></a>二、如何构造散列函数</h3><blockquote><p>散列函数设计的三个基本要求:</p></blockquote><h4 id="1-散列函数计算得到的散列值是一个非负整数"><a href="#1-散列函数计算得到的散列值是一个非负整数" class="headerlink" title="1.散列函数计算得到的散列值是一个非负整数;"></a>1.散列函数计算得到的散列值是一个非负整数;</h4><blockquote><p>散列值用于寻址，作为数组下标当然是从0开始，所以应该大于等于0。</p></blockquote><h4 id="2-如果key1-key2-那么hash-key1-hash-key2-；"><a href="#2-如果key1-key2-那么hash-key1-hash-key2-；" class="headerlink" title="2.如果key1 = key2,那么hash(key1) == hash(key2)；"></a>2.如果key1 = key2,那么hash(key1) == hash(key2)；</h4><blockquote><p>同样的数据进行散列处理，肯定需要相同的值来保证寻址正确性。</p></blockquote><h4 id="3-如果key1-key2-那么hash-key1-hash-key2-。"><a href="#3-如果key1-key2-那么hash-key1-hash-key2-。" class="headerlink" title="3.如果key1 != key2, 那么hash(key1) != hash(key2)。"></a>3.如果key1 != key2, 那么hash(key1) != hash(key2)。</h4><blockquote><p>这个只能是尽可能的保证两个不同数据进行散列以后的散列值不同,但是几乎无法找到一个无冲突的散列函数。如果相同就会产生<strong>散列冲突</strong>问题。</p></blockquote><h3 id="三、装载因子"><a href="#三、装载因子" class="headerlink" title="三、装载因子"></a>三、装载因子</h3><p>装载因子的计算公式:<br><strong>散列表的装载因子 = 填入散列表中的元素个数/散列表的长度</strong></p><blockquote><p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p></blockquote><h3 id="四、散列冲突"><a href="#四、散列冲突" class="headerlink" title="四、散列冲突"></a>四、散列冲突</h3><h4 id="1-散列冲突的定义"><a href="#1-散列冲突的定义" class="headerlink" title="1.散列冲突的定义"></a>1.散列冲突的定义</h4><blockquote><p>当存在不同数据进行散列以后得到的散列值相同，这种情况就是散列冲突。</p></blockquote><h4 id="2-解决散列冲突的方法"><a href="#2-解决散列冲突的方法" class="headerlink" title="2.解决散列冲突的方法:"></a>2.解决散列冲突的方法:</h4><h5 id="a-开放寻址法"><a href="#a-开放寻址法" class="headerlink" title="a.开放寻址法"></a>a.开放寻址法</h5><p>如果出现了散列冲突，我们就重新探测一个空闲位置将其插入。</p><p><strong>探测方式：</strong></p><blockquote><p><strong>线性探测</strong>:如果某个数据经过散列之后，存储位置已经被占用了，就从被占用位置开始，依次往后查找空闲位置进行插入操作。(如果寻找到数组尾部还没有找到，就从数组头部开始查找空闲位置)。<br><strong>二次探测</strong>:和线性探测一样，只是把步长变为原来的二次方。(例如原来的是hash(key) + 1,hash(key+2),就变为hash(key)+1^2,hash(key)+2^2)。<br><strong>双重散列</strong>:就是实现一组散列函数。如果前一个散列函数对数据的散列值已经被占用，就启用后一个散列函数。</p></blockquote><h5 id="b-链表法"><a href="#b-链表法" class="headerlink" title="b.链表法"></a>b.链表法</h5><blockquote><p>链表法就是在散列表中，把每个“桶(bucket)”或者“槽(slot)”会对应一条链表，所有散列 值相同的元素我们都放到相同槽位对应的链表中。</p></blockquote><p><strong>插入&amp;删除</strong><br><strong>插入操作</strong>:将数据进行散列操作，找到对应的槽位，然后再对应的链表中进行插入操作。时间复杂度为O(1);<br><strong>删除操作</strong>:将数据进行散列操作，找到对应的槽位，然后再对应的链表中遍历找到元素进行删除操作。时间复杂度就等于链表中遍历找到元素进行删除操作的时间复杂度。如果链表长度为k那么时间复杂度就为k。然后对于散列比较均匀的散列函数来说，理论上为 <strong>k = n / m</strong>。n表示散列表中数据个数，m表示散列表中槽的个数。 </p><h3 id="五、Word-文档中单词拼写检查功能-是如何实现的"><a href="#五、Word-文档中单词拼写检查功能-是如何实现的" class="headerlink" title="五、Word 文档中单词拼写检查功能 是如何实现的?"></a>五、Word 文档中单词拼写检查功能 是如何实现的?</h3><blockquote><p>常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB。可以用散列表来存储整个英文单词词典。<br>当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼 写正确;如果没有查到，则说明拼写可能有误，给予提示。</p></blockquote><h2 id="第15课-散列表-中"><a href="#第15课-散列表-中" class="headerlink" title="第15课 - - - - - - -散列表(中)"></a>第15课 - - - - - - -散列表(中)</h2><h3 id="一、如何设计散列函数"><a href="#一、如何设计散列函数" class="headerlink" title="一、如何设计散列函数"></a>一、如何设计散列函数</h3><blockquote><p>1.散列函数的设计不能太复杂，过于复杂的散列函数会消耗过多的时间，间接影响散列表的性能。<br>2.散列函数生成的值要尽可能随机并且均匀分布。</p></blockquote><p><strong>散列函数的一些设计方法</strong>：<br>数据分析法、直接寻址法、平方取中值法、折叠法、随机数法、等等。</p><h3 id="二、装载因子过大的解决办法"><a href="#二、装载因子过大的解决办法" class="headerlink" title="二、装载因子过大的解决办法"></a>二、装载因子过大的解决办法</h3><p>可以设置一个装载因子的临界值，达到这个临界值以后就对散列表进行动态扩容。<br>可以先申请一个原来散列表大小两倍的空间，这个时候散列表对应的装载因子就为原来的一半，并且重新设计散列函数。<br>如果这时候对所有数据进行搬移，使用均摊法，可以得到时间复杂度为O(n)。</p><h3 id="二、避免低效扩容"><a href="#二、避免低效扩容" class="headerlink" title="二、避免低效扩容"></a>二、避免低效扩容</h3><blockquote><p>在动态扩容的过程中，当我们申请了新的内存空间以后，可以先不全部搬移数据。<br>而是把数据搬移的操作穿插在散列表的新数据的普通插入操作中，这个时候，<strong>一次性</strong>的扩容就被均分到多次普通插入操作中。可以解决扩容时那次操作造成的系统拥堵。这种情况下时间复杂度为O(1)。<br>即，当有新数据插入时，先将新数据插入新散列表，并且从老的散列表中拿一个数据放入到新的散列表中。经过多次这样的操作，老的散列表数据被完全搬移到新散列表以后，释放老散列表的空间。</p></blockquote><h3 id="三、处理散列冲突"><a href="#三、处理散列冲突" class="headerlink" title="三、处理散列冲突"></a>三、处理散列冲突</h3><h4 id="1-开放寻址法"><a href="#1-开放寻址法" class="headerlink" title="1.开放寻址法"></a>1.开放寻址法</h4><blockquote><p><strong>优点</strong>:<br>a.数据都存储在数组中，CPU缓存查查询速度快。<br>b.这种形式的散列表序列化起来比较简单。相对的链表法实现的散列表序列化相对困难。<br><strong>缺点</strong>:<br>a.删除节点的时候比较麻烦，需要特殊标记已经删除的数据。<br>b.散列冲突的代价更高。<br>开放寻址法，适合装载因子上限不大的散列表。<br>开放寻址法只适用于转载因子小于1，且当装载因子接近1的时候，就会有大量的散列冲突，导致大量的探测，再散列等，性能下降很多。</p></blockquote><p><strong>当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。</strong></p><h4 id="2-链表法"><a href="#2-链表法" class="headerlink" title="2.链表法"></a>2.链表法</h4><blockquote><p><strong>优点</strong><br>a.链表法对内存的利用率比开放寻址法高。<em>即用即申请</em>。<br>b.对装载因子的容忍度比开放寻址法高。<br>c.当数据是大对象的时候，指针的空间消耗，不值一提。</p></blockquote><p><strong>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列 表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表</strong></p><h3 id="四、工业级散列表举例分析"><a href="#四、工业级散列表举例分析" class="headerlink" title="四、工业级散列表举例分析"></a>四、工业级散列表举例分析</h3><p><font size="5"><strong>《java HashMap》</strong></font></p><h4 id="1-初始大小"><a href="#1-初始大小" class="headerlink" title="1. 初始大小"></a>1. 初始大小</h4><blockquote><p>初始大小为16，可以设置。如果事先知道大概数据量，可以设置，避免扩容操作。</p></blockquote><h4 id="2-装载因子和动态扩容"><a href="#2-装载因子和动态扩容" class="headerlink" title="2.装载因子和动态扩容"></a>2.装载因子和动态扩容</h4><blockquote><p>最大装载因子是0.75，超过以后就进行扩容，扩容空间为原来的两倍。</p></blockquote><h4 id="3-散列冲突解决方法"><a href="#3-散列冲突解决方法" class="headerlink" title="3.散列冲突解决方法"></a>3.散列冲突解决方法</h4><blockquote><p>最开始底层采用链表法解决冲突。<br>JDK1.8以后，当链表长度超过8，就转换为用红黑树解决。当红黑树节点少于8个的时候，又转为用链表解决。</p></blockquote><h4 id="4-散列函数"><a href="#4-散列函数" class="headerlink" title="4.散列函数"></a>4.散列函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = key.hashCode();</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; (capitity -<span class="number">1</span>); <span class="comment">//capicity 表示散列表的大小</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1 = <span class="keyword">this</span>.hash;</span><br><span class="line">    <span class="keyword">if</span>(var1 == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] var2 = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; <span class="keyword">this</span>.value.length; ++var3) &#123;</span><br><span class="line">            var1 = <span class="number">31</span> * var1 + var2[var3];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.hash = var1; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var1; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="五、工业级散列表"><a href="#五、工业级散列表" class="headerlink" title="五、工业级散列表"></a>五、工业级散列表</h3><h4 id="1-特性"><a href="#1-特性" class="headerlink" title="1.特性:"></a>1.特性:</h4><blockquote><p>a.支持快速的查询、插入、删除操作;<br>b.内存占用合理，不能浪费过多的内存空间; c.性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。</p></blockquote><h4 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现:"></a>2.实现:</h4><blockquote><p>a.设计一个合适的散列函数;<br>b.定义装载因子阈值，并且设计动态扩容策略;<br>c.选择合适的散列冲突解决方法。</p></blockquote><h2 id="第16课-散列表-下"><a href="#第16课-散列表-下" class="headerlink" title="第16课 - - - - - - -散列表(下)"></a>第16课 - - - - - - -散列表(下)</h2><h3 id="一、LRU缓存淘汰算法"><a href="#一、LRU缓存淘汰算法" class="headerlink" title="一、LRU缓存淘汰算法"></a>一、LRU缓存淘汰算法</h3><p><img src="/2020/04/24/DataStructure07/LRU.png" alt></p><h4 id="1-设计原理："><a href="#1-设计原理：" class="headerlink" title="1.设计原理："></a>1.设计原理：</h4><blockquote><p>a.通过散列表法来解决散列冲突。<br>b.这个链表含有两条链<br>1).一条是存储相同hash值的元素的双向链表<br>2).一条是把所有元素串起来的链</p></blockquote><h4 id="1-查找插入删除操作："><a href="#1-查找插入删除操作：" class="headerlink" title="1.查找插入删除操作："></a>1.查找插入删除操作：</h4><p>a.<strong>查找数据</strong><br>通过散列表查找，找到对应的槽，然后遍历链表查找，找到以后将数据移动到遍历的起始节点之前。平摊以后时间复杂度为O(1);<br>b.<strong>删除数据</strong><br>先通过a查找到数据，然后删除节点，双向链表删除节点的时间复杂度为O(1);<br>c.<strong>添加一个数据</strong><br>先查询这个数据是否已经在缓存中，<br>如果已经在缓存中，将其移动到链表遍历的起始节点之前。<br>如果不存在缓存中，就要看缓存是否已满(通过一个缓存计数变量实现)，<br>如果满了，就将双向链表遍历末尾节点删除，将添加的节点放在链表遍历的起始节点之前。<br>如果没满，就直接将添加的节点放在链表遍历的起始节点之前。</p><h3 id="二、Redis有序集合"><a href="#二、Redis有序集合" class="headerlink" title="二、Redis有序集合"></a>二、Redis有序集合</h3><h4 id="1-设计原理：-1"><a href="#1-设计原理：-1" class="headerlink" title="1.设计原理："></a>1.设计原理：</h4><blockquote><p>通过散列表实现；<br>散列冲突通过链表法解决；<br>链表上面两条链，一条双向链表，一条顺序查询链表(这条链表通过跳表实现)。</p></blockquote><h4 id="2-处理问题"><a href="#2-处理问题" class="headerlink" title="2.处理问题:"></a>2.处理问题:</h4><blockquote><p>查找通过散列表<br>删除通过散列表，然后看情况决定是否修改跳表<br>插入通过散列表，然后看情况决定是否修改跳表<br>按分区查找通过跳表实现</p></blockquote><h3 id="三、Java-LinkedHashMap"><a href="#三、Java-LinkedHashMap" class="headerlink" title="三、Java LinkedHashMap"></a>三、Java LinkedHashMap</h3><p>和上面LRU实现相同。<br><strong>LinkedHashMap 是通过双向链表和散列表这两种数据结构 组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表 法解决散列冲突。</strong>；</p><h3 id="四、为什么散列表和链表经常一块使用"><a href="#四、为什么散列表和链表经常一块使用" class="headerlink" title="四、为什么散列表和链表经常一块使用?"></a>四、为什么散列表和链表经常一块使用?</h3><p>散列表的插入、删除、查找操作非常高效。但是数据通过哈希函数以后，被打乱了顺序，变得无规律。<br>无法支持按照某种顺序快速的遍历数据。<br>所以把散列表和链表(或者跳表)结合使用，就能实现高效的插入删除查找操作，以及按顺序或者区间遍历数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第14课-散列表-上&quot;&gt;&lt;a href=&quot;#第14课-散列表-上&quot; class=&quot;headerlink&quot; title=&quot;第14课 - 
      
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 06 跳表</title>
    <link href="http://yoursite.com/2020/04/23/DataStructure06/"/>
    <id>http://yoursite.com/2020/04/23/DataStructure06/</id>
    <published>2020-04-23T11:57:54.908Z</published>
    <updated>2020-04-24T09:55:38.857Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。</p></blockquote><h2 id="第13课-跳表"><a href="#第13课-跳表" class="headerlink" title="第13课 - - - - - - -跳表"></a>第13课 - - - - - - -跳表</h2><h3 id="一、跳表的定义"><a href="#一、跳表的定义" class="headerlink" title="一、跳表的定义"></a>一、跳表的定义</h3><blockquote><p>跳表就是链表加多级索引的动态数据结构。</p></blockquote><p><img src="/2020/04/23/DataStructure06/skipList.png" alt></p><h3 id="二、跳表查找的时间复杂度"><a href="#二、跳表查找的时间复杂度" class="headerlink" title="二、跳表查找的时间复杂度"></a>二、跳表查找的时间复杂度</h3><blockquote><p>当每两个节点就抽出一个节点作为上级索引节点的情况下。<br>查找一个元素的时间复杂度和二分查找相当，是O(logn)。</p></blockquote><h3 id="三、跳表查找的空间复杂度"><a href="#三、跳表查找的空间复杂度" class="headerlink" title="三、跳表查找的空间复杂度"></a>三、跳表查找的空间复杂度</h3><blockquote><p>当每两个节点就抽出一个节点作为上级索引节点的情况下。<br>每两个元素向上提取一个元素，那么，最后额外需要的空间就是：n/2 + (n/2)^2 + (n/2)^3 + … + 8 + 4 + 2 = n - 2。所以空间复杂度为O(n)。<br>每三个节点抽出一个节点作为上级节点的情况下复杂度为n/2虽然也是O(n)但是实际减少了一半。</p></blockquote><h3 id="四、跳表的动态插入和删除"><a href="#四、跳表的动态插入和删除" class="headerlink" title="四、跳表的动态插入和删除"></a>四、跳表的动态插入和删除</h3><h4 id="1-插入操作"><a href="#1-插入操作" class="headerlink" title="1.插入操作"></a>1.插入操作</h4><blockquote><p> 首先需要找到插入节点的位置，时间复杂度为O(logn)，然后插入操作为O(1)，所以时间复杂度为O(logn)。</p></blockquote><h4 id="2-删除操作"><a href="#2-删除操作" class="headerlink" title="2.删除操作"></a>2.删除操作</h4><blockquote><p>如果需要删除的节点在索引中也出现，我们除了要删除链表里面的节点，还要删除索引中的节点。<br>注意：如果是在单链表中，要删除一个节点首先需要拿到一个节点的前驱节点才能进行删除。</p></blockquote><h3 id="五、跳表的动态更新"><a href="#五、跳表的动态更新" class="headerlink" title="五、跳表的动态更新"></a>五、跳表的动态更新</h3><p> 当我们不停的往跳表中插入数据的时候，如果我们不添加更新索引，就会导致2个索引节点之间的数据非常多。极端情况下还会退化成单链表。导致查找的效率降低。</p><blockquote><p>作为一种动态数据结构，我们需要某种手段来维护索引和原始链表大小之间的平衡。也就是说，如果链表中的节点多了，索引就相应的增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。<br><strong>我们通过一个随机函数来决定将这个节点插入到哪几层索引中</strong>，比如随机函数生成了值k，我们就将这个节点添加到第一级到第k级这k级索引中。</p></blockquote><h3 id="五、为什么-Redis-要用跳表来-实现有序集合，而不是红黑树"><a href="#五、为什么-Redis-要用跳表来-实现有序集合，而不是红黑树" class="headerlink" title="五、为什么 Redis 要用跳表来 实现有序集合，而不是红黑树?"></a>五、为什么 Redis 要用跳表来 实现有序集合，而不是红黑树?</h3><blockquote><p>首先，我们来分析下Redis的有序集合支持的操作：<br>1）插入元素<br>2）删除元素<br>3）查找元素<br>4）有序输出所有元素<br>5）查找区间内所有元素<br>其中，前4项红黑树都可以完成，且时间复杂度与跳表一致。<br>但是，最后一项，红黑树的效率就没有跳表高了。<br>在跳表中，要查找区间的元素，我们只要定位到两个区间端点在最低层级的位置，然后按顺序遍历元素就可以了，非常高效。<br>而红黑树只能定位到端点后，再从首位置开始每次都要查找后继节点，相对来说是比较耗时的。<br>此外，跳表实现起来很容易且易读，红黑树实现起来相对困难，所以Redis选择使用跳表来实现有序集合。</p></blockquote><h3 id="六、跳表的实现"><a href="#六、跳表的实现" class="headerlink" title="六、跳表的实现"></a>六、跳表的实现</h3><blockquote><p>后面有时间再补。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第13课-跳表&quot;&gt;&lt;a href=&quot;#第13课-跳表&quot; class=&quot;headerlink&quot; title=&quot;第13课 - - - - 
      
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 05 二分查找</title>
    <link href="http://yoursite.com/2020/04/23/DataStructure05/"/>
    <id>http://yoursite.com/2020/04/23/DataStructure05/</id>
    <published>2020-04-23T11:32:24.228Z</published>
    <updated>2020-04-24T09:55:35.138Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。</p></blockquote><h2 id="第11课-二分查找-上"><a href="#第11课-二分查找-上" class="headerlink" title="第11课 - - - - - - - 二分查找(上)"></a>第11课 - - - - - - - 二分查找(上)</h2><h3 id="一、二分查找思想"><a href="#一、二分查找思想" class="headerlink" title="一、二分查找思想"></a>一、二分查找思想</h3><blockquote><p>二分查找针对的是一个有序的数据集合，查找思想类似分治思想。每次都通过跟区间的中间元素对比，将查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0。</p></blockquote><h3 id="二、二分查找的时间复杂度"><a href="#二、二分查找的时间复杂度" class="headerlink" title="二、二分查找的时间复杂度"></a>二、二分查找的时间复杂度</h3><h4 id="1-二分查找的时间复杂度推导"><a href="#1-二分查找的时间复杂度推导" class="headerlink" title="1.二分查找的时间复杂度推导"></a>1.二分查找的时间复杂度推导</h4><p>被查找的区间的大小变化为:<br>n,n/2,n/4,n/8,…,n/(2^k),…<br>由于每次缩小都只比较两个数的大小，所以经过k次区间缩小的操作，当区间为1的时候就是必定找到数据。<br>即n/(2^k) = 1;其中k就是总共缩小的次数，k = logn(以2为底数),所以时间复杂度为O(logn)。</p><h4 id="2-二分查找的递归和非递归实现"><a href="#2-二分查找的递归和非递归实现" class="headerlink" title="2.二分查找的递归和非递归实现"></a>2.二分查找的递归和非递归实现</h4><p><strong><em>非递归实现</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bSearch</span><span class="params">(<span class="keyword">int</span> * nums, <span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">NULL</span> || <span class="built_in">size</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = <span class="built_in">size</span><span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; value)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; value) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>三个需要注意的点</strong><br>a.循环退出条件:low &lt;= high<br>b.mid 取值，为了不超过int的最大值:mid = low + (high-low)/2;还可以优化成:mid = low + ((high-low)&gt;&gt;2)”这里需要注意&gt;&gt;的运算优先级和+一样所以要多加一个括号”;<br>c.low和high的更新:low = mid + 1; high = mid - 1;<br><strong><em>递归实现</em></strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _bSearch2(<span class="keyword">int</span> * nums,<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = low + ((high - low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nums[mid]  == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; value) &#123;</span><br><span class="line">        <span class="keyword">return</span> _bSearch2(nums, low, mid - <span class="number">1</span>,value);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; value) &#123;</span><br><span class="line">        <span class="keyword">return</span> _bSearch2(nums, mid + <span class="number">1</span>, high, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bSearch2</span><span class="params">(<span class="keyword">int</span> * nums, <span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  _bSearch2(nums, <span class="number">0</span>, <span class="built_in">size</span><span class="number">-1</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、二分查找的应用局限性"><a href="#三、二分查找的应用局限性" class="headerlink" title="三、二分查找的应用局限性"></a>三、二分查找的应用局限性</h3><h4 id="1-依赖于顺序表结构，简单点说就是数组。"><a href="#1-依赖于顺序表结构，简单点说就是数组。" class="headerlink" title="1.依赖于顺序表结构，简单点说就是数组。"></a>1.依赖于顺序表结构，简单点说就是数组。</h4><blockquote><p>二分查找每次查找的时候都依赖下标进行随机访问。数组比较合适。</p></blockquote><h4 id="2-二分查找依赖于有序数据。"><a href="#2-二分查找依赖于有序数据。" class="headerlink" title="2.二分查找依赖于有序数据。"></a>2.二分查找依赖于有序数据。</h4><blockquote><p>如果是无序数据需要先排序，再进行查找。通常是一次排序，多次二分查找。</p></blockquote><h4 id="3-数据量太小不适合二分查找。"><a href="#3-数据量太小不适合二分查找。" class="headerlink" title="3.数据量太小不适合二分查找。"></a>3.数据量太小不适合二分查找。</h4><blockquote><p>数据量太小，使用二分查找或者顺序遍历，查找速度差不多。</p></blockquote><h4 id="4-数据量太大不适合二分查找。"><a href="#4-数据量太大不适合二分查找。" class="headerlink" title="4.数据量太大不适合二分查找。"></a>4.数据量太大不适合二分查找。</h4><blockquote><p>如果数据太多，不能一次性读入到<strong>连续</strong>的内存空间，就无法查找。关键是需要一片连续的内存空间。</p></blockquote><h3 id="四、如何在-1000-万个整数-中快速查找某个整数-内存限制100MB"><a href="#四、如何在-1000-万个整数-中快速查找某个整数-内存限制100MB" class="headerlink" title="四、如何在 1000 万个整数 中快速查找某个整数?(内存限制100MB)"></a>四、如何在 1000 万个整数 中快速查找某个整数?(内存限制100MB)</h3><blockquote><p>100 000 000个整数，每个数据大小是8字节，那么如果把全部数据存入内存需要1000000*8/1024/1024大约等于76MB。<br>那么我们可以通过把所有数据读入内存，然后进行二分查找。</p></blockquote><p>如果使用散列表和二叉树，因为需要额外空间，所以不能实现。</p><h3 id="五、课后题"><a href="#五、课后题" class="headerlink" title="五、课后题"></a>五、课后题</h3><h4 id="1-如何求一个数的平方根？要求精确到小数点后6位。"><a href="#1-如何求一个数的平方根？要求精确到小数点后6位。" class="headerlink" title="1.如何求一个数的平方根？要求精确到小数点后6位。"></a>1.如何求一个数的平方根？要求精确到小数点后6位。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">double mySqrt(int x,double t) &#123;</span><br><span class="line">    double low &#x3D; 0;</span><br><span class="line">    double high &#x3D; x;</span><br><span class="line">    double mid &#x3D; high&#x2F;2.;</span><br><span class="line">    while (high - low &gt; t) &#123;</span><br><span class="line">        if (mid*mid &gt; x) &#123;</span><br><span class="line">            high &#x3D; mid;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            low &#x3D; mid;</span><br><span class="line">        &#125;</span><br><span class="line">        mid &#x3D; low + (high-low)&#x2F;2.;</span><br><span class="line">    &#125;</span><br><span class="line">    return mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>两个数相乘的积去和x做比较,通过2分查找去找近似值。<br>以精度作为结束条件。</p></blockquote><h4 id="2-用链表来存储数据，使用二分查找算法的时间复杂度是多少？"><a href="#2-用链表来存储数据，使用二分查找算法的时间复杂度是多少？" class="headerlink" title="2.用链表来存储数据，使用二分查找算法的时间复杂度是多少？"></a>2.用链表来存储数据，使用二分查找算法的时间复杂度是多少？</h4><blockquote><p>时间复杂度为O(n)。<br>每次比较都要找到相应的数，找到这个数需要经过的次数为<br>第一次为 n/2<br>第二次为 n/4<br>…<br>第N次为 n/(2^n)<br>那么就是: （n/2 + n/4 + ….+n/(2^n)）/n = 1/2+1/4+….+1/(2^n) 近似n<br>所以时间复杂度为O(n)。</p></blockquote><h2 id="第12课-二分查找-下"><a href="#第12课-二分查找-下" class="headerlink" title="第12课 - - - - - - - 二分查找(下)"></a>第12课 - - - - - - - 二分查找(下)</h2><h4 id="一、查找第一个值等于给定值的元素"><a href="#一、查找第一个值等于给定值的元素" class="headerlink" title="一、查找第一个值等于给定值的元素"></a>一、查找第一个值等于给定值的元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找第一个x</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch1</span><span class="params">(<span class="keyword">int</span> * nums,<span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span>  mid = low + ((high-low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x &lt; nums[mid] ) &#123;</span><br><span class="line">            high  = mid <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (x &gt; nums[mid]) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x == nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span>|| nums[mid <span class="number">-1</span>] != x) &#123; <span class="comment">//在数组首位说明不存在更前的数。||前一个值不等于x</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//前一个值等于x</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、查找最后一个值等于给定值的元素"><a href="#二、查找最后一个值等于给定值的元素" class="headerlink" title="二、查找最后一个值等于给定值的元素"></a>二、查找最后一个值等于给定值的元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找最后一个x</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span> * nums,<span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x &lt; nums[mid]) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &gt; nums[mid]) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x == nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="built_in">size</span> <span class="number">-1</span> || nums[mid+<span class="number">1</span>] != x) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、查找第一个大于等于给定值"><a href="#三、查找第一个大于等于给定值" class="headerlink" title="三、查找第一个大于等于给定值"></a>三、查找第一个大于等于给定值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找第一个大于等于x的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch3</span><span class="params">(<span class="keyword">int</span> * nums,<span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = <span class="built_in">size</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (( high - low ) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid == <span class="number">0</span> || nums[mid <span class="number">-1</span>] &lt; x) &#123; <span class="comment">//前面没有更小的值</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &gt; nums[mid]) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、查找最后一个小于等于给定值"><a href="#四、查找最后一个小于等于给定值" class="headerlink" title="四、查找最后一个小于等于给定值"></a>四、查找最后一个小于等于给定值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找最后一个小于等于x的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">binarySearch4</span><span class="params">(<span class="keyword">int</span> * nums,<span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="built_in">size</span> - <span class="number">1</span> || nums[mid + <span class="number">1</span>] &gt; x) &#123; <span class="comment">//后一个数大于x</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; nums[mid]) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、如何快速定位一个IP地址的归属地-假设我-们有-12-万条这样的-IP-区间与归属地的对应关系，如何快速定位出一个IP地址的归属地呢"><a href="#四、如何快速定位一个IP地址的归属地-假设我-们有-12-万条这样的-IP-区间与归属地的对应关系，如何快速定位出一个IP地址的归属地呢" class="headerlink" title="四、如何快速定位一个IP地址的归属地?(假设我 们有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个IP地址的归属地呢?)"></a>四、如何快速定位一个IP地址的归属地?(假设我 们有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个IP地址的归属地呢?)</h4><blockquote><p>第一步,将ip地址进行排序,可以把ip转换为32位的整型数。按照整型值的大小进行从小到大的排序。<br>第二步,查询某个IP，通过二分查找，找到最后一个起始IP小于等于这个IP的IP区间，然后检查这个IP是否在这个IP的区间内，如果在，就取出相应的归属地，进行显示，如果不在就返回未找到。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第11课-二分查找-上&quot;&gt;&lt;a href=&quot;#第11课-二分查找-上&quot; class=&quot;headerlink&quot; title=&quot;第11课 
      
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
</feed>
