<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MiHuA</title>
  
  <subtitle>Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-30T10:48:54.203Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>mihua</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Re:从零开始的异世界》手游抽卡实现</title>
    <link href="http://yoursite.com/2020/04/30/LotteryDraw/"/>
    <id>http://yoursite.com/2020/04/30/LotteryDraw/</id>
    <published>2020-04-30T05:28:36.101Z</published>
    <updated>2020-04-30T10:48:54.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h1><blockquote><p>基于2020-04-30版本分析，<br>现在5星角色爱蜜莉雅·朦胧的睡意以及怠情疯狂的信仰概率提升。<br>现在5星装备卡鬼族的末裔以及遵守的契约概率提升。</p></blockquote><h3 id="1、不同的抽奖卡类型"><a href="#1、不同的抽奖卡类型" class="headerlink" title="1、不同的抽奖卡类型"></a>1、不同的抽奖卡类型</h3><blockquote><p>首先拥有两种不同的卡类型<br>分别是人物卡、装备卡<br>人物卡和装备卡均分别有三星四星和五星。</p></blockquote><h3 id="2、不同的抽奖卡类型概率统计"><a href="#2、不同的抽奖卡类型概率统计" class="headerlink" title="2、不同的抽奖卡类型概率统计"></a>2、不同的抽奖卡类型概率统计</h3><table><thead><tr><th>类型</th><th>概率</th><th>卡数量</th><th>单个概率</th></tr></thead><tbody><tr><td><center>五星角色卡</center></td><td><center>1.5%</center></td><td><center>10</center></td><td><center> 0.15%</center></td></tr><tr><td><center>四星角色卡</center></td><td><center>8.0%</center></td><td><center>12</center></td><td><center>0.67%</center></td></tr><tr><td><center>三星角色卡</center></td><td><center>40%</center></td><td><center>14</center></td><td><center>2.86%</center></td></tr><tr><td><center>五星装备卡</center></td><td><center>2.5%</center></td><td><center>10</center></td><td><center> 0.25%</center></td></tr><tr><td><center>四星装备卡</center></td><td><center>8.0%</center></td><td><center>12</center></td><td><center>0.67%</center></td></tr><tr><td><center>三星装备卡</center></td><td><center>40%</center></td><td><center>12</center></td><td><center> 3.33%</center></td></tr><tr><td><center>总概率</center></td><td><center>100%</center></td><td><center>\</center></td><td><center>\</center></td></tr></tbody></table><h3 id="3、活动时的五星角色获取概率提升"><a href="#3、活动时的五星角色获取概率提升" class="headerlink" title="3、活动时的五星角色获取概率提升"></a>3、活动时的五星角色获取概率提升</h3><p>当前版本：<br>现在五星角色爱蜜莉雅·朦胧的睡意以及怠情疯狂的信仰概率分别占五星卡的35%。<br>现在五星装备卡鬼族的末裔以及遵守的契约概率分别占五星卡的35%。</p><h3 id="4、连抽不中五星卡概率提升"><a href="#4、连抽不中五星卡概率提升" class="headerlink" title="4、连抽不中五星卡概率提升"></a>4、连抽不中五星卡概率提升</h3><p>如果连续30次召唤没有获得五星角色卡，则下次抽牌概率增加0.5%。不中依次增加，抽中五星角色卡后回归初始状态。</p><h1 id="二、编码设计"><a href="#二、编码设计" class="headerlink" title="二、编码设计"></a>二、编码设计</h1><h3 id="1、活动时，五星角色获取概率提升的只是在五星卡中的占比，所以没有影响五星卡的获取概率。"><a href="#1、活动时，五星角色获取概率提升的只是在五星卡中的占比，所以没有影响五星卡的获取概率。" class="headerlink" title="1、活动时，五星角色获取概率提升的只是在五星卡中的占比，所以没有影响五星卡的获取概率。"></a>1、活动时，五星角色获取概率提升的只是在五星卡中的占比，所以没有影响五星卡的获取概率。</h3><h3 id="2、连续不中五星卡概率提升，提升的是整个五星卡的概率，不影响五星卡角色在五星卡中的占比。"><a href="#2、连续不中五星卡概率提升，提升的是整个五星卡的概率，不影响五星卡角色在五星卡中的占比。" class="headerlink" title="2、连续不中五星卡概率提升，提升的是整个五星卡的概率，不影响五星卡角色在五星卡中的占比。"></a>2、连续不中五星卡概率提升，提升的是整个五星卡的概率，不影响五星卡角色在五星卡中的占比。</h3><blockquote><p>所以、抽奖分为两个步骤：<br>1.抽出具体属于哪一类卡。该步骤受连续不中影响。<br>2.抽出具体卡后，再在具体的卡类型中进行一次抽取。</p></blockquote><h1 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  抽奖</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by mihuasama on 2020/4/30.</span></span><br><span class="line"><span class="comment">//  Copyright © 2020 mihuasama. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;time.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max_Random 32768</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> increase_single 0.005</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//各级中奖概率</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r_5_p 0.015</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r_4_p 0.080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r_3_p 0.400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> e_5_p 0.025</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> e_4_p 0.080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> e_3_p 0.400</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//角色卡数量</span></span><br><span class="line"><span class="keyword">int</span> CardNums[<span class="number">6</span>] = &#123;<span class="number">11</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> remainder_rw = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//角色卡类型</span></span><br><span class="line"><span class="keyword">enum</span> Type_Card</span><br><span class="line">&#123;</span><br><span class="line">    Type_Card_Role5 = <span class="number">0</span>,</span><br><span class="line">    Type_Card_Role4,</span><br><span class="line">    Type_Card_Role3,</span><br><span class="line">    Type_Card_EQP5,</span><br><span class="line">    Type_Card_EQP4,</span><br><span class="line">    Type_Card_EQP3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * Card_Pool_role5[] = &#123;</span><br><span class="line">    <span class="string">"阿尼莱尼·银莲一现"</span>,</span><br><span class="line">    <span class="string">"特蕾希雅·无垢青鸟"</span>,</span><br><span class="line">    <span class="string">"艾尔莎·诱惑回眸"</span>,</span><br><span class="line">    <span class="string">"怠情·疯狂的信仰"</span>,</span><br><span class="line">    <span class="string">"莱茵哈鲁特·工作闲暇"</span>,</span><br><span class="line">    <span class="string">"爱蜜莉雅·朦胧的睡意"</span>,</span><br><span class="line">    <span class="string">"青年威尔海姆·挥剑练习"</span>,</span><br><span class="line">    <span class="string">"罗兹瓦尔·夜阑已至"</span>,</span><br><span class="line">    <span class="string">"尤里乌斯·王国之剑"</span>,</span><br><span class="line">    <span class="string">"蕾姆·失控的鬼"</span>,</span><br><span class="line">    <span class="string">"特蕾希雅·漫天黄花"</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> * Card_Pool_role4[] = &#123;<span class="string">"安娜塔西亚·交涉时刻"</span>,<span class="string">"菲鲁特·不习惯的礼服"</span>,<span class="string">"菲克丽丝·彼岸花开"</span>,<span class="string">"菲莉丝·猫与猫"</span>,<span class="string">"普莉西亚·傲慢的凝视"</span>,<span class="string">"库珥修·铠甲的英姿"</span>,<span class="string">"威尔海姆·心愿终结"</span>,<span class="string">"爱蜜莉雅·晨间微风"</span>,<span class="string">"碧翠丝·和哥哥一起"</span>,<span class="string">"拉姆窗外的风景"</span>,<span class="string">"蕾姆·饮茗赏花"</span>,<span class="string">"库珥修·公务缠身"</span>,<span class="string">"青年威尔海姆·恋诗追忆"</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> * Card_Pool_role3[] = &#123;<span class="string">"堤比·擦拭眼睛"</span>,<span class="string">"奥托·慌乱的一天"</span>,<span class="string">"阿尔迪巴兰·侍从"</span>,<span class="string">"马可仕·团长的威严"</span>,<span class="string">"蜜蜜·好朋友莱卡"</span>,<span class="string">"库乌德·出征的夙愿"</span>,<span class="string">"黑塔洛·精疲力尽"</span>,<span class="string">"阿顿·打劫"</span>,<span class="string">"阿汉·敲诈"</span>,<span class="string">"菲鲁特·偷窃徽章"</span>,<span class="string">"理卡德·激战"</span>,<span class="string">"罗姆爷·野蛮的做法"</span>,<span class="string">"阿珍·恐吓"</span>,<span class="string">"拉塞尔·商人的秘诀"</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> * Card_Pool_eqp5[] = &#123;<span class="string">"青空下的誓言"</span>,<span class="string">"遵守契约"</span>,<span class="string">"狮子的意志"</span>,<span class="string">"最喜欢的菜肴"</span>,<span class="string">"信任的约定"</span>,<span class="string">"剑圣的名义"</span>,<span class="string">"精灵的祝福"</span>,<span class="string">"渺小的梦想"</span>,<span class="string">"沙提拉传说"</span>,<span class="string">"鬼族的末裔"</span>,<span class="string">"王选之局"</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> * Card_Pool_eqp4[] = &#123;<span class="string">"真实的名字"</span>,<span class="string">"品酒的夜晚"</span>,<span class="string">"挥剑的意义"</span>,<span class="string">"阵营联盟"</span>,<span class="string">"从识字开始"</span>,<span class="string">"满分的笑容"</span>,<span class="string">"待客的红茶"</span>,<span class="string">"孩童送行"</span>,<span class="string">"Victory!"</span>,<span class="string">"喜欢书房的两个人"</span>,<span class="string">"实现的火花"</span>,<span class="string">"亲切的待客之道"</span>,<span class="string">"胜利的清晨"</span>,<span class="string">"骑士对决"</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> * Card_Pool_eqp3[] = &#123;<span class="string">"一秒六连拍"</span>,<span class="string">"厨房的技巧"</span>,<span class="string">"美味的早餐"</span>,<span class="string">"锁链的声响"</span>,<span class="string">"梦幻的手艺"</span>,<span class="string">"龙的故事"</span>,<span class="string">"善心的回报"</span>,<span class="string">"水魔法治疗"</span>,<span class="string">"硬币的魔法"</span>,<span class="string">"平静的一天"</span>,<span class="string">"最后的赏月"</span>,<span class="string">"菲鲁特的住所"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">char</span> ** CardPool[] = &#123;Card_Pool_role5,Card_Pool_role4,Card_Pool_role3,Card_Pool_eqp5,Card_Pool_eqp4,Card_Pool_eqp3&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//未抽中五星前抽奖次数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> lotteryDrawNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//活动概率提升</span></span><br><span class="line"><span class="keyword">char</span> p_role5_increase = <span class="number">0.35</span>;</span><br><span class="line"><span class="keyword">char</span> p_role4_increase = <span class="number">0.35</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机函数种子</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> next = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//线性同余伪随机数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rw_rand</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next = next*<span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(next/<span class="number">65536</span>) % <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rw_srand</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next = seed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    usleep(<span class="number">10</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">t_val</span>;</span></span><br><span class="line">    gettimeofday(&amp;t_val, <span class="literal">NULL</span>);</span><br><span class="line">    rw_srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(t_val.tv_usec*t_val.tv_usec+t_val.tv_usec));</span><br><span class="line">    <span class="keyword">int</span> ret = rw_rand();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 抽奖第一层</span></span><br><span class="line"><span class="comment"> RETURN int :</span></span><br><span class="line"><span class="comment"> -1 err</span></span><br><span class="line"><span class="comment"> 5，4，3 =&gt; 角色卡五四三</span></span><br><span class="line"><span class="comment"> 50,40,30 =&gt; 装备卡五四三</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lotteryDraw_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = getRandom()%remainder_rw;</span><br><span class="line">    <span class="keyword">float</span> ret_1 = (<span class="keyword">float</span>)(ret) / (<span class="keyword">float</span>)(remainder_rw);</span><br><span class="line">    <span class="comment">//    printf("随机数 %d ret_1:%f\n",ret,ret_1);</span></span><br><span class="line">    <span class="comment">/*划分抽奖区间:</span></span><br><span class="line"><span class="comment">     五星角色卡区间为 0 - p_r_5_index</span></span><br><span class="line"><span class="comment">     四星角色卡区间为 p_r_5_index - p_r_4_index</span></span><br><span class="line"><span class="comment">     三星角色卡区间为 p_r_4_index - p_r_3_index</span></span><br><span class="line"><span class="comment">     五星装备卡区间为 p_r_3_index - p_e_5_index</span></span><br><span class="line"><span class="comment">     四星装备卡区间为 p_e_5_index - p_e_4_index</span></span><br><span class="line"><span class="comment">     三星装备卡区间为 p_e_4_index - 1.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">float</span> p_r_5_index , p_r_4_index , p_r_3_index , p_e_5_index , p_e_4_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> p_r_5_increase = lotteryDrawNum &gt; <span class="number">30</span> ? (lotteryDrawNum - <span class="number">30</span>) * increase_single : <span class="number">0</span>;</span><br><span class="line">    p_r_5_index = r_5_p + p_r_5_increase;</span><br><span class="line">    p_r_4_index = p_r_5_index + r_4_p;</span><br><span class="line">    p_r_3_index = p_r_4_index + r_3_p;</span><br><span class="line">    p_e_5_index = p_r_3_index + e_5_p;</span><br><span class="line">    p_e_4_index = p_e_5_index + e_4_p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查找区间2分思想</span></span><br><span class="line">    <span class="keyword">int</span> flag_class = <span class="number">0</span>; <span class="comment">//0位角色卡，1为装备卡</span></span><br><span class="line">    <span class="keyword">if</span> (ret_1 &gt; p_r_3_index) &#123;</span><br><span class="line">        flag_class = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (flag_class == <span class="number">0</span> &amp;&amp; ret_1 &lt; p_r_5_index) &#123; <span class="comment">//5星角色卡</span></span><br><span class="line">        <span class="keyword">return</span> Type_Card_Role5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag_class == <span class="number">0</span> &amp;&amp; ret_1 &lt; p_r_4_index) &#123;<span class="comment">//4星角色卡</span></span><br><span class="line">        <span class="keyword">return</span> Type_Card_Role4;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag_class == <span class="number">0</span> &amp;&amp; ret_1 &lt; p_r_3_index) &#123;<span class="comment">//3星角色卡</span></span><br><span class="line">        <span class="keyword">return</span> Type_Card_Role3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag_class == <span class="number">1</span> &amp;&amp; ret_1 &gt;= p_e_4_index) &#123;<span class="comment">//3星装备卡</span></span><br><span class="line">        <span class="keyword">return</span> Type_Card_EQP3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag_class == <span class="number">1</span> &amp;&amp; ret_1 &gt;= p_e_5_index) &#123;<span class="comment">//4星装备卡</span></span><br><span class="line">        <span class="keyword">return</span> Type_Card_EQP4;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Type_Card_EQP5;<span class="comment">//5星装备卡</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//五星卡处理</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lotteryDraw_2</span><span class="params">(<span class="keyword">enum</span> Type_Card card,<span class="keyword">float</span> activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = getRandom();</span><br><span class="line">    ret = ret % remainder_rw;</span><br><span class="line">    <span class="keyword">float</span> random_num = (<span class="keyword">float</span>)(ret) / (<span class="keyword">float</span>)(remainder_rw);</span><br><span class="line">    <span class="keyword">int</span> num = CardNums[card];</span><br><span class="line">    <span class="keyword">float</span> p = (<span class="number">1.0</span>-activity)/(<span class="keyword">float</span>)num;</span><br><span class="line">    <span class="keyword">int</span> random_index = (<span class="keyword">int</span>)(random_num/p); <span class="comment">//哈希函数</span></span><br><span class="line">    <span class="keyword">if</span> (random_index &gt;= num) &#123;<span class="comment">//特殊卡</span></span><br><span class="line">        random_index -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"恭喜抽中 "</span>);</span><br><span class="line">    <span class="keyword">if</span> (card == Type_Card_Role5) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"5☆☆☆☆☆   角色卡"</span>);</span><br><span class="line">        lotteryDrawNum = <span class="number">0</span>;<span class="comment">//抽中五星角色之后归零重新开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (card == Type_Card_Role4) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"4☆☆☆☆    角色卡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (card == Type_Card_Role3) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"3☆☆☆     角色卡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (card == Type_Card_EQP5) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"5☆☆☆☆☆   星之器"</span>);</span><br><span class="line">        lotteryDrawNum = <span class="number">0</span>;<span class="comment">//抽中五星角色之后归零重新开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (card == Type_Card_EQP4) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"4☆☆☆☆    星之器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (card == Type_Card_EQP3) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"3☆☆☆     星之器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> * cardName = CardPool[card][random_index];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"     %s\n"</span>,cardName);</span><br><span class="line">    <span class="keyword">return</span> random_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽一次</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lotteryDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lotteryDrawNum ++; <span class="comment">//抽奖次数喜加一</span></span><br><span class="line">    <span class="keyword">int</span> ret_1 = lotteryDraw_1();</span><br><span class="line">    <span class="comment">//    printf("\nrandom - %f\n",random_num);</span></span><br><span class="line">    <span class="keyword">enum</span> Type_Card card = Type_Card_Role3;</span><br><span class="line">    <span class="keyword">float</span> activity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (ret_1) &#123;</span><br><span class="line">        <span class="keyword">case</span> Type_Card_Role5:</span><br><span class="line">        &#123;</span><br><span class="line">            activity = p_role5_increase;</span><br><span class="line">            card = Type_Card_Role5;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Type_Card_Role4:</span><br><span class="line">        &#123;</span><br><span class="line">            activity = p_role4_increase;</span><br><span class="line">            card = Type_Card_Role4;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Type_Card_Role3:</span><br><span class="line">        &#123;</span><br><span class="line">            card = Type_Card_Role3;<span class="comment">//可以不写</span></span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Type_Card_EQP5:</span><br><span class="line">        &#123;</span><br><span class="line">            card = Type_Card_EQP5;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Type_Card_EQP4:</span><br><span class="line">        &#123;</span><br><span class="line">            card = Type_Card_EQP4;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Type_Card_EQP3:</span><br><span class="line">        &#123;</span><br><span class="line">            card = Type_Card_EQP3;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> detail_index = lotteryDraw_2(card, activity);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> card;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dataInit</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="keyword">sizeof</span>(<span class="keyword">char</span>*);</span><br><span class="line">    CardNums[Type_Card_Role5] = <span class="keyword">sizeof</span>(Card_Pool_role5)/<span class="built_in">size</span>;</span><br><span class="line">    CardNums[Type_Card_Role4] = <span class="keyword">sizeof</span>(Card_Pool_role4)/<span class="built_in">size</span>;</span><br><span class="line">    CardNums[Type_Card_Role3] = <span class="keyword">sizeof</span>(Card_Pool_role3)/<span class="built_in">size</span>;</span><br><span class="line">    CardNums[Type_Card_EQP5] = <span class="keyword">sizeof</span>(Card_Pool_eqp5)/<span class="built_in">size</span>;</span><br><span class="line">    CardNums[Type_Card_EQP4] = <span class="keyword">sizeof</span>(Card_Pool_eqp4)/<span class="built_in">size</span>;</span><br><span class="line">    CardNums[Type_Card_EQP3] = <span class="keyword">sizeof</span>(Card_Pool_eqp3)/<span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    dataInit();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> nums = <span class="number">10000000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cardNum[<span class="number">6</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i ++) &#123;</span><br><span class="line">        cardNum[lotteryDraw()]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n抽取：%d 次：\n"</span>,nums);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"五星角色卡 %d 张\n"</span>,cardNum[Type_Card_Role5]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"四星角色卡 %d 张\n"</span>,cardNum[Type_Card_Role4]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"三星角色卡 %d 张\n"</span>,cardNum[Type_Card_Role3]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"五星星之卡 %d 张\n"</span>,cardNum[Type_Card_EQP5]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"四星星之卡 %d 张\n"</span>,cardNum[Type_Card_EQP4]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"三星星之卡 %d 张\n"</span>,cardNum[Type_Card_EQP3]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>世界上不存在真随机数。<br>如何弄出随机数就是一个困难的地方。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、需求分析&quot;&gt;&lt;a href=&quot;#一、需求分析&quot; class=&quot;headerlink&quot; title=&quot;一、需求分析&quot;&gt;&lt;/a&gt;一、需求分析&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;基于2020-04-30版本分析，&lt;br&gt;现在5星角色爱蜜莉雅·朦胧的睡意以及怠情
      
    
    </summary>
    
    
      <category term="个人理解" scheme="http://yoursite.com//categories/234/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="杂谈" scheme="http://yoursite.com//tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 10 红黑树</title>
    <link href="http://yoursite.com/2020/04/29/DataStructure10/"/>
    <id>http://yoursite.com/2020/04/29/DataStructure10/</id>
    <published>2020-04-29T01:26:58.176Z</published>
    <updated>2020-04-30T03:09:53.542Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。</p></blockquote><h2 id="第21-22课-红黑树"><a href="#第21-22课-红黑树" class="headerlink" title="第21-22课 - - - - - - -红黑树"></a>第21-22课 - - - - - - -红黑树</h2><h3 id="1-2-3查找树。"><a href="#1-2-3查找树。" class="headerlink" title="1.2-3查找树。"></a>1.2-3查找树。</h3><h4 id="a-定义"><a href="#a-定义" class="headerlink" title="a.定义"></a>a.定义</h4><blockquote><p><strong>2-3树</strong>:由2节点和3节点这两种种节点构成的树。</p></blockquote><blockquote><p><strong>2节点</strong>:1key+2child，一个值加两个子节点。类似排序二叉树的节点，左子节点的值小于它，右子节点的值大于它。<br><img src="/2020/04/29/DataStructure10/23tree1.png" alt></p></blockquote><blockquote><p><strong>3节点</strong>:2key+3child,就是通过两个key分为三个范围：<br>range1 &lt; key1 &lt; range2 &lt; key2 &lt; range3<br>其中的三个子节点的取值范围分别在range1,range2和range3中。<br><img src="/2020/04/29/DataStructure10/23tree2.png" alt></p></blockquote><h4 id="b-插入操作"><a href="#b-插入操作" class="headerlink" title="b.插入操作"></a>b.插入操作</h4><p>第一步，先查找对应的元素应该被插入的位置。<br>第二步，分两种情况操作。<br>如果查找的位置结束于2节点，那么直接插入，形成一个3节点。<br>如果查找的位置结束于3节点，那么需要处理的方式有三种。<br>1).只有一个3节点的树的情况下：<br><img src="/2020/04/29/DataStructure10/23tree3.png" alt><br>这种情况下先将插入数放入3节点构造成一个4节点，然后提取中值(中键)分裂成一个2节点带两个子节点。</p><p>2).插入节点为3节点，插入节点的父节点为2节点的情况下：<br> <img src="/2020/04/29/DataStructure10/23tree4.png" alt><br>这种情况下先将插入数放入3节点构造成一个4节点，然后将4节点分裂成两个2节点，并且提取中值(中键)移到父节点，将父节点构造成一个3节点。</p><p>3).插入节点为3节点，插入节点的父节点为3节点的情况下：<br> <img src="/2020/04/29/DataStructure10/23tree5.png" alt><br>这种情况下先将插入数放入3节点构造成一个4节点，然后将4节点分裂成两个2节点，并且提取中值(中键)移到父节点，将父节点构造成一个4节点。然后父节点提取中值向上分裂，知道分裂到情况2，处理完成后没有4节点结束。</p><blockquote><p>除了相关的结点和链接之外不必修改或者检查树的其他部分。每次变换中，变更的链接数量不会超过一个很小的常数。所有局部变换都不会影响整棵树的有序性和平衡性。</p></blockquote><h4 id="c-删除操作"><a href="#c-删除操作" class="headerlink" title="c.删除操作"></a>c.删除操作</h4><p>1.删除的元素是叶子节点并且含有两个元素<br> <img src="/2020/04/29/DataStructure10/23tree6.png" alt><br>2.删除的元素是叶子节点并且只有1个元素的话,但是父节点的右节点函数含有两个元素<br> <img src="/2020/04/29/DataStructure10/23tree7.png" alt><br> 3.删除的元素是叶子节点,但是父节点的右节点只有一个元素<br>  <img src="/2020/04/29/DataStructure10/23tree8.png" alt><br>4.如果删除的叶子节点的父结点是两个元素的话并且父节点的左右的左结点还可以插入<br>  <img src="/2020/04/29/DataStructure10/23tree9.png" alt><br>5.如果删除的是满二叉树<br><img src="/2020/04/29/DataStructure10/23tree10.png" alt><br>6.删除的是非叶子节点并且只有一个元素<br><img src="/2020/04/29/DataStructure10/23tree11.png" alt><br>7.删除的是非叶子节点并且只有两个元素<br>情况1：<br><img src="/2020/04/29/DataStructure10/23tree12.png" alt><br>情况2：<br><img src="/2020/04/29/DataStructure10/23tree13.png" alt></p><h4 id="d-2-3树的优点"><a href="#d-2-3树的优点" class="headerlink" title="d.2-3树的优点"></a>d.2-3树的优点</h4><blockquote><p>2-3树在最坏情况下仍有较好的性能。每个操作中处理每个结点的时间都不会超过一个很小的常数，且这两个操作都只会访问一条路径上的结点，所以任何查找或者插入的成本都肯定不会超过对数级别。</p></blockquote><p>完美平衡的2-3树要平展的多。例如，含有10亿个结点的一颗2-3树的高度仅在19到30之间。我们最多只需要访问30个结点就能在10亿个键中进行任意查找和插入操作。</p><h4 id="e-2-3树的缺点"><a href="#e-2-3树的缺点" class="headerlink" title="e.2-3树的缺点"></a>e.2-3树的缺点</h4><p>我们需要维护两种不同类型的结点，查找和插入操作的实现需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。<br>平衡一棵树的初衷是为了消除最坏情况，但我们希望这种保障所需的代码能够越少越好。</p><h3 id="2-红黑树"><a href="#2-红黑树" class="headerlink" title="2.红黑树"></a>2.红黑树</h3><p>红黑树其实用红节点标识3节点，黑节点标识2节点的2-3树。</p><blockquote><p>红节点，其实是标识连接到这个节点的边是红色的。<br>红黑树的定义就是满足3个条件的二叉查找树：<br>1.红连接均为左连接。<br>2.没有一个节点同时和两条红连接相连。(因为如果有超过一条红连接，那么3节点就不再是3节点，而是更高)<br>3.该树是完美黑色平衡的，即任意空连接到根节点的路径上的黑链接数量相同。</p></blockquote><blockquote><p><strong>红黑树正统官方定义</strong>:<br>1.红黑树是一棵排序二叉树。<br>2.节点是红色或黑色。<br>根是黑色。<br>所有叶子都是黑色（叶子是NIL节点）。<br>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）<br>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</p></blockquote><blockquote><p>参考资料:<br>[1]  <a href="https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf" target="_blank" rel="noopener">https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf</a><br>[2]  <a href="https://blog.csdn.net/yang_yulei/article/details/26066409" target="_blank" rel="noopener">https://blog.csdn.net/yang_yulei/article/details/26066409</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第21-22课-红黑树&quot;&gt;&lt;a href=&quot;#第21-22课-红黑树&quot; class=&quot;headerlink&quot; title=&quot;第21-2
      
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 09 二叉树</title>
    <link href="http://yoursite.com/2020/04/27/DataStructure09/"/>
    <id>http://yoursite.com/2020/04/27/DataStructure09/</id>
    <published>2020-04-27T11:21:41.163Z</published>
    <updated>2020-04-29T01:24:55.023Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。</p></blockquote><h2 id="第19课-二叉树-上"><a href="#第19课-二叉树-上" class="headerlink" title="第19课 - - - - - - -二叉树(上)"></a>第19课 - - - - - - -二叉树(上)</h2><h3 id="一、树"><a href="#一、树" class="headerlink" title="一、树"></a>一、树</h3><h4 id="概念1："><a href="#概念1：" class="headerlink" title="概念1："></a>概念1：</h4><p><img src="/2020/04/27/DataStructure09/binaryTree1.png" alt></p><blockquote><p>A 节点是 B 节点的<strong>父节点</strong>，B 节点是 A 节点的<strong>子节点</strong>。<br> B、C、D 这三 个节点的父节点是同一个节点，所以它们之间互称为<strong>兄弟节点</strong>。<br> 没有父节点的节点叫 作<strong>根节点</strong>，也就是图中的节点 E。<br> 没有子节点的节点叫作<strong>叶子节点</strong>或者<strong>叶节点</strong>，比如 图中的 G、H、I、J、K、L 都是叶子节点。</p></blockquote><h4 id="概念2："><a href="#概念2：" class="headerlink" title="概念2："></a>概念2：</h4><p><img src="/2020/04/27/DataStructure09/binaryTree2.png" alt></p><blockquote><p><strong>高度</strong>：节点到叶子节点的最长路径(边数)<br><strong>深度</strong>：根节点到这个节点所经历的边的个数<br><strong>节点的层数</strong> ： 节点的深度+1<br><strong>树的高度</strong> = 根节点的高度</p></blockquote><h3 id="二、二叉树"><a href="#二、二叉树" class="headerlink" title="二、二叉树"></a>二、二叉树</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><p><strong>二叉树</strong>，每个节点最多有两个子节点，分别是<strong>左子节点</strong>和<strong>右子节点</strong>。<br><img src="/2020/04/27/DataStructure09/binaryTree3.png" alt><br><strong>满二叉树</strong>：编号 2 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左 右两个子节点。<br><strong>完全二叉树</strong>：编号 3 的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除 了最后一层，其他层的节点个数都要达到最大。（主要从存储去看）</p><h4 id="2-二叉树的存储"><a href="#2-二叉树的存储" class="headerlink" title="2.二叉树的存储"></a>2.二叉树的存储</h4><p><strong>a.基于指针或者引用的二叉链式存储法</strong><br><img src="/2020/04/27/DataStructure09/binaryTree4.png" alt></p><blockquote><p>每个节点有三 个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就 可以通过左右子节点的指针，把整棵树都串起来。</p></blockquote><p><strong>b.基于数组的顺序存储法</strong><br><img src="/2020/04/27/DataStructure09/binaryTree5.png" alt></p><blockquote><p>把根节点存储在下标 i = 1 的位置，那左子节点 存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。以此类推，B 节点的 左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位 置。</p></blockquote><p>如果不是完全二叉树就会浪费存储空间:<br><img src="/2020/04/27/DataStructure09/binaryTree6.png" alt></p><blockquote><p><strong>堆其实就是一种完全二叉树，最常用的存储方式 就是数组。</strong></p></blockquote><h4 id="3-二叉树的遍历"><a href="#3-二叉树的遍历" class="headerlink" title="3.二叉树的遍历"></a>3.二叉树的遍历</h4><p><img src="/2020/04/27/DataStructure09/binaryTree7.png" alt><br>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最 后打印它的右子树。<br>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后 打印它的右子树。<br>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树， 最后打印这个节点本身。</p><blockquote><p><strong>实际上，二叉树的前、中、后序遍历就是一个递归的过程。</strong></p></blockquote><p>代码实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree_Node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tree_Node</span> * <span class="title">leftChild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tree_Node</span> * <span class="title">rightChild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node * root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,root-&gt;data);</span><br><span class="line">    preOrder(root-&gt;leftChild);</span><br><span class="line">    preOrder(root-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intOrder</span><span class="params">(Node * root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(root-&gt;leftChild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,root-&gt;data);</span><br><span class="line">    preOrder(root-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node * root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(root-&gt;leftChild);</span><br><span class="line">    preOrder(root-&gt;rightChild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,root-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-二叉树遍历的时间复杂度"><a href="#4-二叉树遍历的时间复杂度" class="headerlink" title="4.二叉树遍历的时间复杂度"></a>4.二叉树遍历的时间复杂度</h4><blockquote><p>从前面画的前、中、后序遍历的顺序图，可以看出来，每个节点最多会被访问两次，所以 遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说二叉树遍历的时间复杂度是 O(n)。</p></blockquote><h3 id="三、完全二叉树适合用数组来存储"><a href="#三、完全二叉树适合用数组来存储" class="headerlink" title="三、完全二叉树适合用数组来存储"></a>三、完全二叉树适合用数组来存储</h3><blockquote><p>二叉树既可以用链式存储，也可以用数组顺序存储。数组顺序存储的方式比较适合完全二叉 树，其他类型的二叉树用数组存储会比较浪费存储空间。</p></blockquote><h3 id="四、二叉树的基础编码"><a href="#四、二叉树的基础编码" class="headerlink" title="四、二叉树的基础编码"></a>四、二叉树的基础编码</h3><h4 id="1-从数组创建完全二叉树"><a href="#1-从数组创建完全二叉树" class="headerlink" title="1.从数组创建完全二叉树"></a>1.从数组创建完全二叉树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">createNode</span><span class="params">(<span class="keyword">int</span> * nums,<span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="built_in">size</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = nums[index];</span><br><span class="line">    node-&gt;leftChild = createNode(nums, <span class="built_in">size</span>, <span class="number">2</span>*(index+<span class="number">1</span>)<span class="number">-1</span>);</span><br><span class="line">    node-&gt;rightChild = createNode(nums, <span class="built_in">size</span>, <span class="number">2</span>*(index+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组存储的完全二叉树生成链式存储的完全二叉树</span></span><br><span class="line"><span class="function">Node * <span class="title">createBinaryTreeByArray</span><span class="params">(<span class="keyword">int</span> * nums,<span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createNode(nums, <span class="built_in">size</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><h2 id="第20课-二叉树-下"><a href="#第20课-二叉树-下" class="headerlink" title="第20课 - - - - - - -二叉树(下)"></a>第20课 - - - - - - -二叉树(下)</h2><h3 id="一、二叉查找树"><a href="#一、二叉查找树" class="headerlink" title="一、二叉查找树"></a>一、二叉查找树</h3><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h4><blockquote><p><strong>二叉查找树</strong>：在树的任意一个节点，左子树中的每个节点的值都要小于这个节点的值，右子树节点的值都大于这个节点的值。</p></blockquote><h4 id="2-插入操作"><a href="#2-插入操作" class="headerlink" title="2.插入操作"></a>2.插入操作</h4><p>二叉排序树的插入过程：<br>第一步、先判断当前节点与插入节点的值大小。<br>第二步1、当插入值大于节点值，判断右子树是否为空，<br>    如果右子树为空，则创建右子树节点并赋值。<br>    如果右子树不为空，则去判断右子树节点和插入值大小，回到第一步<br>第二步2、当插入值小于节点值，判断左子树是否为空，<br>    如果左子树为空，则创建左子树节点并赋值。<br>    如果左子树不为空，则去判断左子树节点和插入值大小，回到第一步<br><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST_insert</span><span class="params">(Node * root,<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data &gt; p-&gt;data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rightChild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                p-&gt;rightChild = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">                &#123;<span class="comment">//初始化</span></span><br><span class="line">                    p-&gt;rightChild-&gt;data = data;</span><br><span class="line">                    p-&gt;rightChild-&gt;leftChild = <span class="literal">NULL</span>;</span><br><span class="line">                    p-&gt;rightChild-&gt;rightChild = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p = p-&gt;rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;leftChild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                p-&gt;leftChild = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">                &#123;<span class="comment">//初始化</span></span><br><span class="line">                    p-&gt;leftChild-&gt;data = data;</span><br><span class="line">                    p-&gt;leftChild-&gt;leftChild = <span class="literal">NULL</span>;</span><br><span class="line">                    p-&gt;leftChild-&gt;rightChild = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p = p-&gt;leftChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-二叉查找树的创建"><a href="#3-二叉查找树的创建" class="headerlink" title="3.二叉查找树的创建"></a>3.二叉查找树的创建</h4><p>二叉查找树的创建过程就是一个个节点的插入过程<br><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *  <span class="title">createBST</span><span class="params">(<span class="keyword">int</span> *nums,<span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">NULL</span> || <span class="built_in">size</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * root = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    root-&gt;data = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span>; i ++) &#123;</span><br><span class="line">        BST_insert(root, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-查找操作"><a href="#4-查找操作" class="headerlink" title="4.查找操作"></a>4.查找操作</h4><p>查找过程<br>第一步：先判断当前节点的值是否与查找值相同。<br>如果查找值相同，直接返回节点。<br>如果查找值不相同进入第二步：<br>第二步：判断查找值和当前节点值的大小关系：<br>如果查找值大于当前节点值，就去右节点查找，返回第一步。<br>如果查找值小于当前节点值，就去左节点查找，返回第一步。<br><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">findInBST</span><span class="params">(Node * root,<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * findP = root;</span><br><span class="line">    <span class="keyword">while</span> (findP != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == findP-&gt;data) &#123;</span><br><span class="line">            <span class="keyword">return</span> findP;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data &gt; findP-&gt;data) &#123;</span><br><span class="line">            findP = findP-&gt;rightChild;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data &lt; findP-&gt;data) &#123;</span><br><span class="line">            findP =  findP-&gt;leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-删除操作"><a href="#5-删除操作" class="headerlink" title="5.删除操作"></a>5.删除操作</h4><p>删除的节点有三种情况。<br>第一种，没有子节点，可以直接将其父节点指向它的指针设置为NULL，并且释放它的内存。<br>第二种，有一个子节点，可以将其父节点指向它的指针指向子节点，并且释放它的内存。<br>第三种，有两个子节点，需要找到右子树的最小节点，替换当前节点，并且释放当前节点的内存。<br>编码的过程：<br>先查找到相应的节点，并且记录所在节点的父节点。<br>如果没有找到节点，直接返回。<br>如果找到节点。则判断删除的三种情况。<br>先判断是不是有双子节点的情况。<br>如果是，则找到该节点的右子树的最小节点。将节点的值修改为最小节点的值，然后将找到的几点指针和父指针都指向最小节点。<br>在综合判断有一个子节点还是没有子节点的情况。如果没有子节点，父节指向该节点的指针置空，释放节点内存。<br>如果有子节点，判断是左子节点还是右子节点。将父节点指向相应的子节点，然后释放节点内存。<br><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *  <span class="title">BST_delete</span><span class="params">(Node * root,<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node * p = root;</span><br><span class="line">    Node * pp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data &gt; p-&gt;data) &#123;</span><br><span class="line">            pp = p;</span><br><span class="line">            p = p-&gt;rightChild;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (data &lt; p-&gt;data)&#123;</span><br><span class="line">            pp = p;</span><br><span class="line">            p = p-&gt;leftChild;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;data == data) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123; <span class="comment">//没找到直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断有两个子节点的情况</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;leftChild != <span class="literal">NULL</span> &amp;&amp; p-&gt;rightChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Node * minP = p-&gt;rightChild;</span><br><span class="line">        Node * minPP = p;</span><br><span class="line">        <span class="keyword">while</span> (minP-&gt;leftChild != <span class="literal">NULL</span>) &#123;  <span class="comment">//没有左子树的子节点最小</span></span><br><span class="line">            minPP = minP;</span><br><span class="line">            minP = minP-&gt;leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data = minP-&gt;data; <span class="comment">//把最小值赋值给该删除的节点，</span></span><br><span class="line">        p = minP;<span class="comment">//然后删除最小值所在位置的节点。</span></span><br><span class="line">        pp = minPP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除的节点是叶子节点，或者只有一个子节点的节点</span></span><br><span class="line">    Node * child;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;leftChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        child = p-&gt;leftChild;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;rightChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        child = p-&gt;rightChild;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        child = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pp == <span class="literal">NULL</span>) &#123; <span class="comment">//删除根节点</span></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pp-&gt;leftChild == p)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        pp-&gt;leftChild = child;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pp-&gt;rightChild == p)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        pp-&gt;rightChild = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-二叉查找树的其他操作"><a href="#6-二叉查找树的其他操作" class="headerlink" title="6.二叉查找树的其他操作"></a>6.二叉查找树的其他操作</h4><h5 id="a-快速地查找最大节点和最小节点、"><a href="#a-快速地查找最大节点和最小节点、" class="headerlink" title="a.快速地查找最大节点和最小节点、"></a>a.快速地查找最大节点和最小节点、</h5><blockquote><p>最大节点就是最右没有右子树的叶子。<br>最小节点就是最左没有左子树的叶子。</p></blockquote><h5 id="b-前驱节点和后继节点"><a href="#b-前驱节点和后继节点" class="headerlink" title="b.前驱节点和后继节点"></a>b.前驱节点和后继节点</h5><blockquote><p>前驱节点可以通过多加一个指针记录寻找过程。<br>后继节点直接获取。</p></blockquote><h5 id="c-二叉树的高度"><a href="#c-二叉树的高度" class="headerlink" title="c.二叉树的高度"></a>c.二叉树的高度</h5><blockquote><blockquote><p>待定</p></blockquote></blockquote><h4 id="7-二叉查找树输出有序数列"><a href="#7-二叉查找树输出有序数列" class="headerlink" title="7.二叉查找树输出有序数列"></a>7.二叉查找树输出有序数列</h4><blockquote><p>中序遍历二叉查找树， 可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。</p></blockquote><h3 id="二、支持重复数据的二叉查找树"><a href="#二、支持重复数据的二叉查找树" class="headerlink" title="二、支持重复数据的二叉查找树"></a>二、支持重复数据的二叉查找树</h3><blockquote><p>当利用对象的某个字段作为键值(key)来构建二叉查找树，对象中的其他字段叫作卫星数据。<br><strong>存储的两个对象键值相同</strong>如何解决？</p></blockquote><h4 id="1-相同数据存在同一个树形节点上"><a href="#1-相同数据存在同一个树形节点上" class="headerlink" title="1.相同数据存在同一个树形节点上"></a>1.相同数据存在同一个树形节点上</h4><p>通过链表和 支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p><h4 id="2-把这个新插入的数据当作大于这个节点的值来处理"><a href="#2-把这个新插入的数据当作大于这个节点的值来处理" class="headerlink" title="2.把这个新插入的数据当作大于这个节点的值来处理"></a>2.把这个新插入的数据当作大于这个节点的值来处理</h4><p>按这种处理情况:</p><blockquote><p>当要查找数据的时候，遇到值相同的节点，并不停止查找操作，而是继续在右子树中查 找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。<br>对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方 法，依次删除。</p></blockquote><h3 id="三、二叉查找树的时间复杂度分析"><a href="#三、二叉查找树的时间复杂度分析" class="headerlink" title="三、二叉查找树的时间复杂度分析"></a>三、二叉查找树的时间复杂度分析</h3><h4 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1.时间复杂度"></a>1.时间复杂度</h4><p>不管操作是插入、删除还是查找，<strong>时间复杂度其实都跟树的高度成正比，也就是 O(height)</strong>。</p><h4 id="2-树的高度"><a href="#2-树的高度" class="headerlink" title="2.树的高度"></a>2.树的高度</h4><p>完全二叉树的层数小于等于 log(n) + 1，也就是说，完全二叉树的高度小于等于 log(n)。</p><h3 id="四、散列表和二叉树对比"><a href="#四、散列表和二叉树对比" class="headerlink" title="四、散列表和二叉树对比"></a>四、散列表和二叉树对比</h3><blockquote><p>1.散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二 叉查找树来说，只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序 列。</p></blockquote><blockquote><p>2.散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能 不稳定，但是在工程中，平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</p></blockquote><blockquote><p>3.笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的 存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈 希函数的耗时，也不一定就比平衡二叉查找树的效率高。</p></blockquote><blockquote><p>4.散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲 突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题 的解决方案比较成熟、固定。</p></blockquote><blockquote><p>5.为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲 突的散列表，不然会浪费一定的存储空间。</p></blockquote><p>综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲 突。在实际的开发过程中，需要结合具体的需求来选择使用哪一个。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第19课-二叉树-上&quot;&gt;&lt;a href=&quot;#第19课-二叉树-上&quot; class=&quot;headerlink&quot; title=&quot;第19课 - 
      
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 08 哈希算法</title>
    <link href="http://yoursite.com/2020/04/25/DataStructure08/"/>
    <id>http://yoursite.com/2020/04/25/DataStructure08/</id>
    <published>2020-04-25T05:11:16.768Z</published>
    <updated>2020-04-27T05:40:40.700Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。</p></blockquote><h2 id="第17课-哈希算法-上"><a href="#第17课-哈希算法-上" class="headerlink" title="第17课 - - - - - - -哈希算法(上)"></a>第17课 - - - - - - -哈希算法(上)</h2><h3 id="一、哈希算法"><a href="#一、哈希算法" class="headerlink" title="一、哈希算法"></a>一、哈希算法</h3><p>任意长度的二进制串映射为固定长度的二进制串，这个映射的规则就是<strong>哈希算法</strong>。<br>映射出的固定长度的二进制串就是<strong>哈希值</strong>。</p><h3 id="二、哈希算法的应用-上"><a href="#二、哈希算法的应用-上" class="headerlink" title="二、哈希算法的应用(上)"></a>二、哈希算法的应用(上)</h3><h4 id="1-安全加密"><a href="#1-安全加密" class="headerlink" title="1.安全加密"></a>1.安全加密</h4><p>通过哈希算法加密以后，很难根据哈希值反向推导出原始数据，可以有效防止原始数据泄露。</p><blockquote><p>鸽巢原理：如果有10个鸽巢，有11只鸽子，那么肯定有一个鸽巢中的鸽子数量多于1。<br>哈希算法之所以无法做到零冲突,是因为需要映射的二进制数据是无穷的，但是有限位的哈希结果却不是无穷的。</p></blockquote><h4 id="2-唯一标识"><a href="#2-唯一标识" class="headerlink" title="2.唯一标识"></a>2.唯一标识</h4><p>可以通过取整个文件、或者截取部分文件求哈希值，将哈希值作为文件的唯一标识。</p><blockquote><p>例如实现一个图库<br>可以把每个图片都进行处理得到一个唯一标识，将标识和图片在图库中的路径信息存储在散列表中。<br>当插入某个图片是不是在图库中的时候，我们先通过哈希算法对这个图片取唯一标识，然后在散列表中查询是否存在。<br>如果不存在，就说明不在图库中；<br>如果存在，就再通过散列表中存储的文件路径，获取这个已经存在的图片，和插入图片做全量对比，看是否完全一样。<br>如果一样，说明已经存在。<br>如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。</p></blockquote><h4 id="3-数据校验"><a href="#3-数据校验" class="headerlink" title="3.数据校验"></a>3.数据校验</h4><p>通过BT协议下载的文件。可以通过下面思路实现校验。</p><blockquote><p>服务器通过哈希算法，对100个文件块，分别取哈希值，并且保存在种子文件中。<br>当客户端下载的时候，可以通过相同的哈希算法对下载的文件块进行哈希计算，并且和种子文件保存的哈希值做比对。<br>如果不同，说明这个文件块不完整，或者被篡改了。需要重新从其他宿主机器上下载这个文件块。</p></blockquote><h4 id="4-散列函数"><a href="#4-散列函数" class="headerlink" title="4.散列函数"></a>4.散列函数</h4><p>用于哈希表进行散列。<br>需要注意散列以后的值，是否能平均分布。以及哈希函数的执行快慢。<br>均匀分布会减少散列冲突。哈希函数执行的快慢直接决定查找删除插入操作的快慢。</p><h3 id="三、如何防止数据库中的用户信息被脱库"><a href="#三、如何防止数据库中的用户信息被脱库" class="headerlink" title="三、如何防止数据库中的用户信息被脱库"></a>三、如何防止数据库中的用户信息被脱库</h3><p>将用户的密码通过加盐的方式组合，增加密码的复杂度，然后拿组合之后的字符串做哈希算法加密。然后保存到数据库中。</p><blockquote><p>即使这样也只是增加破解的难度，增加了攻击的成本。</p></blockquote><h2 id="第18课-哈希算法-下"><a href="#第18课-哈希算法-下" class="headerlink" title="第18课 - - - - - - -哈希算法(下)"></a>第18课 - - - - - - -哈希算法(下)</h2><h3 id="一、哈希算法的应用-下"><a href="#一、哈希算法的应用-下" class="headerlink" title="一、哈希算法的应用(下)"></a>一、哈希算法的应用(下)</h3><h4 id="1-负载均衡"><a href="#1-负载均衡" class="headerlink" title="1.负载均衡"></a>1.负载均衡</h4><p>负载均衡的算法有很多，比如:轮询、随机、加权轮询等。<br>可以通过哈希算法实现一个会话粘滞的负载均衡算法。</p><blockquote><p>会话粘滞(session sticky)：在同一个客户端上，在一次会话中，所有的请求都路由到同一台服务器上。<br>通过哈希算法，对客户端IP地址，或者会话ID计算哈希值。将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该背路由到的服务器编号。</p></blockquote><h4 id="2-数据分片"><a href="#2-数据分片" class="headerlink" title="2.数据分片"></a>2.数据分片</h4><p><strong>a.如何统计”搜索关键词”出现的次数？</strong><br>(假如有 1T 的日志文件，这里面记录了用户的搜索关键词,想要快速统计出每个关键词被搜索的次数)</p><blockquote><p>可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。</p></blockquote><p>对日志文件进行分片，多台计算机读取分片的日志文件中的搜索关键词。<br>读出搜索关键词后，通过哈希函数计算哈希值，然后对哈希值对n取模，得到应该被分配到处理数据机器编号。（n就是最后进行处理的机器的总数。）<br>这样，哈希值相同的搜索关键词就被分配到了同一个机器上。也就是说，同一个搜索关键词被分配到同一台机器上进行处理。每台机器分别统计关键词出现的次数，最终合并起来就是最终的结果。<br><strong>b.如何快速判断图片是否在图库中?</strong><br>散列表中每个数据单元包含两个信息，哈希值和图片文件的路径。假设通过 MD5 来计 算哈希值，那长度就是 128 比特，也就是 16 字节。文件路径长度的上限是 256 字节，可以假设平均长度是 128 字节。如果用链表法来解决冲突，那还需要存储指针，指 针只占用 8 字节。所以，散列表中每个数据单元就占用 152 字节(这里只是估算，并不准 确)。<br>假设一台机器的内存大小为 2GB，散列表的装载因子为 0.75，那一台机器可以给大约 1000 万(2GB*0.75/152)张图片构建散列表。所以，如果要对 1 亿张图片构建索引，需 要大约十几台机器。在工程中，这种估算还是很重要的，能事先对需要投入的资源、 资金有个大概的了解，能更好地评估解决方案的可行性。<br>实际上，针对这种海量数据的处理问题，都可以采用多机分布式处理。借助这种分片的 思路，可以突破单机内存、CPU 等资源的限制。</p><h4 id="3-分布式存储"><a href="#3-分布式存储" class="headerlink" title="3.分布式存储"></a>3.分布式存储</h4><p>通过<strong>一致性哈希算法</strong>解决分布式机器扩容后数据迁移问题。</p><blockquote><p>一致性哈希算法<br>假设有 k 个机器，数据的哈希值的范围是 [0, MAX]。将整个范围划分成 m 个小 区间(m 远大于 k)，每个机器负责 m/k 个小区间。当有新机器加入的时候，就将某 几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移 数据，也保持了各个机器上数据数量的均衡。</p></blockquote><h4 id="4-哈希算法在分布式系统中的应用。"><a href="#4-哈希算法在分布式系统中的应用。" class="headerlink" title="4.哈希算法在分布式系统中的应用。"></a>4.哈希算法在分布式系统中的应用。</h4><blockquote><p>在负载均衡应用中，利用哈希算法替代映射表，可以实现一个会话粘滞的负载均衡策略。在 数据分片应用中，通过哈希算法对处理的海量数据进行分片，多机分布式处理，可以突破单 机资源的限制。在分布式存储应用中，利用一致性哈希算法，可以解决缓存等分布式系统的 扩容、缩容导致数据大量搬移的难题。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第17课-哈希算法-上&quot;&gt;&lt;a href=&quot;#第17课-哈希算法-上&quot; class=&quot;headerlink&quot; title=&quot;第17课 
      
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>H.264 码率</title>
    <link href="http://yoursite.com/2020/04/24/H264bitrate/"/>
    <id>http://yoursite.com/2020/04/24/H264bitrate/</id>
    <published>2020-04-24T09:12:01.807Z</published>
    <updated>2020-04-30T01:18:27.769Z</updated>
    
    <content type="html"><![CDATA[<h3 id="压缩率"><a href="#压缩率" class="headerlink" title="压缩率"></a>压缩率</h3><blockquote><p>图像总像素存储体积/压缩后H.264 = 压缩率<br>通常情况下，同一段视频，压缩率越高，解码后的图像画质越差。<br>影响压缩率的因素非常多。<br>压缩率和图像相关：如果是静止画面，压缩率会非常大。画面运动越剧烈，压缩率就越小。画面噪点越多，压缩率越小。画面内部相邻像素相似度越低，压缩率越小。等等。<br>压缩率同时还和编码策略相关。例如：b帧越多，压缩率越大、GOP越大，压缩率越大等等。</p></blockquote><h3 id="那么多大的H-264码率是合适的呢"><a href="#那么多大的H-264码率是合适的呢" class="headerlink" title="那么多大的H.264码率是合适的呢"></a>那么多大的H.264码率是合适的呢</h3><h4 id="1-根据预期的理想比特率共识计算"><a href="#1-根据预期的理想比特率共识计算" class="headerlink" title="1.根据预期的理想比特率共识计算"></a>1.根据预期的理想比特率共识计算</h4><p><strong>[图像宽度] x [图像高度] x [帧速率] x [运动等级] x 0.07(压缩比系数) = [所需比特率]</strong></p><blockquote><p>根据<font color="blue"><a href="https://issuu.com/konu/docs/h264_primer" target="_blank" rel="noopener">https://issuu.com/konu/docs/h264_primer</a></font>这里提供的公式进行计算，<br>1080p30fps的视频在画质和压缩率适配相对较好的情况下为：<br><strong>1920*1080*30*2*0.07 = 8709120 bps = 8505kbps。</strong></p></blockquote><h4 id="2-根据Video-Streaming-Primer提供的信息。"><a href="#2-根据Video-Streaming-Primer提供的信息。" class="headerlink" title="2.根据Video Streaming Primer提供的信息。"></a>2.根据Video Streaming Primer提供的信息。</h4><p><font color="blue"><a href="https://www.bogotobogo.com/VideoStreaming/Files/Video_streaming_etc/Video%20Streaming%201.12.pdf" target="_blank" rel="noopener">Video Streaming Primer</a></font><br>1080p30fps用于电视和广播的码率应该在15Mbps = 1.875MBps。</p><h4 id="3-自己计算"><a href="#3-自己计算" class="headerlink" title="3.自己计算"></a>3.自己计算</h4><blockquote><p>YUV420存储一个像素点需要1.5个字节;<br>YUV422存储一个像素点需要2个字节;<br>YUV444存储一个像素点需要3个字节;</p></blockquote><p>一帧包含<strong>1080*1920 = 2073600</strong> 个像素。<br>iOS采集一般是YUV420格式，所以一个像素点需要1.5个字节存储。<br>即:一帧需要<strong>2073600*1.5 = 3110400个字节 = 3037.5kB = 24300kb</strong><br>一秒钟30帧就需要：<strong>24300*30 = 729000kbps</strong>;<br>如果压缩比为50倍则：<strong>729000/50 = 14580kbps</strong>;<br>如果压缩比为150倍则：<strong>729000/150 = 4860kbps</strong>;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;压缩率&quot;&gt;&lt;a href=&quot;#压缩率&quot; class=&quot;headerlink&quot; title=&quot;压缩率&quot;&gt;&lt;/a&gt;压缩率&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;图像总像素存储体积/压缩后H.264 = 压缩率&lt;br&gt;通常情况下，同一段视频，压缩率越高，解码后的图像画
      
    
    </summary>
    
    
      <category term="个人理解" scheme="http://yoursite.com//categories/234/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com//tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 07 散列表</title>
    <link href="http://yoursite.com/2020/04/24/DataStructure07/"/>
    <id>http://yoursite.com/2020/04/24/DataStructure07/</id>
    <published>2020-04-24T06:31:22.298Z</published>
    <updated>2020-04-30T01:19:01.093Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。</p></blockquote><h2 id="第14课-散列表-上"><a href="#第14课-散列表-上" class="headerlink" title="第14课 - - - - - - -散列表(上)"></a>第14课 - - - - - - -散列表(上)</h2><h3 id="一、什么是散列表"><a href="#一、什么是散列表" class="headerlink" title="一、什么是散列表"></a>一、什么是散列表</h3><blockquote><p>散列表就是，通过一个函数计算将数据压缩转化为一个数组的下标，并将数据存储在这个数组的该下标所在内存中的数据结构。这个函数就是<strong>散列函数</strong>，散列表是基于数组的扩展(主要利用数组随机访问时间复杂度为O(1)的优点)。</p></blockquote><h3 id="二、如何构造散列函数"><a href="#二、如何构造散列函数" class="headerlink" title="二、如何构造散列函数"></a>二、如何构造散列函数</h3><blockquote><p>散列函数设计的三个基本要求:</p></blockquote><h4 id="1-散列函数计算得到的散列值是一个非负整数"><a href="#1-散列函数计算得到的散列值是一个非负整数" class="headerlink" title="1.散列函数计算得到的散列值是一个非负整数;"></a>1.散列函数计算得到的散列值是一个非负整数;</h4><blockquote><p>散列值用于寻址，作为数组下标当然是从0开始，所以应该大于等于0。</p></blockquote><h4 id="2-如果key1-key2-那么hash-key1-hash-key2-；"><a href="#2-如果key1-key2-那么hash-key1-hash-key2-；" class="headerlink" title="2.如果key1 = key2,那么hash(key1) == hash(key2)；"></a>2.如果key1 = key2,那么hash(key1) == hash(key2)；</h4><blockquote><p>同样的数据进行散列处理，肯定需要相同的值来保证寻址正确性。</p></blockquote><h4 id="3-如果key1-key2-那么hash-key1-hash-key2-。"><a href="#3-如果key1-key2-那么hash-key1-hash-key2-。" class="headerlink" title="3.如果key1 != key2, 那么hash(key1) != hash(key2)。"></a>3.如果key1 != key2, 那么hash(key1) != hash(key2)。</h4><blockquote><p>这个只能是尽可能的保证两个不同数据进行散列以后的散列值不同,但是几乎无法找到一个无冲突的散列函数。如果相同就会产生<strong>散列冲突</strong>问题。</p></blockquote><h3 id="三、装载因子"><a href="#三、装载因子" class="headerlink" title="三、装载因子"></a>三、装载因子</h3><p>装载因子的计算公式:<br><strong>散列表的装载因子 = 填入散列表中的元素个数/散列表的长度</strong></p><blockquote><p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p></blockquote><h3 id="四、散列冲突"><a href="#四、散列冲突" class="headerlink" title="四、散列冲突"></a>四、散列冲突</h3><h4 id="1-散列冲突的定义"><a href="#1-散列冲突的定义" class="headerlink" title="1.散列冲突的定义"></a>1.散列冲突的定义</h4><blockquote><p>当存在不同数据进行散列以后得到的散列值相同，这种情况就是散列冲突。</p></blockquote><h4 id="2-解决散列冲突的方法"><a href="#2-解决散列冲突的方法" class="headerlink" title="2.解决散列冲突的方法:"></a>2.解决散列冲突的方法:</h4><h5 id="a-开放寻址法"><a href="#a-开放寻址法" class="headerlink" title="a.开放寻址法"></a>a.开放寻址法</h5><p>如果出现了散列冲突，我们就重新探测一个空闲位置将其插入。</p><p><strong>探测方式：</strong></p><blockquote><p><strong>线性探测</strong>:如果某个数据经过散列之后，存储位置已经被占用了，就从被占用位置开始，依次往后查找空闲位置进行插入操作。(如果寻找到数组尾部还没有找到，就从数组头部开始查找空闲位置)。<br><strong>二次探测</strong>:和线性探测一样，只是把步长变为原来的二次方。(例如原来的是hash(key) + 1,hash(key+2),就变为hash(key)+1^2,hash(key)+2^2)。<br><strong>双重散列</strong>:就是实现一组散列函数。如果前一个散列函数对数据的散列值已经被占用，就启用后一个散列函数。</p></blockquote><h5 id="b-链表法"><a href="#b-链表法" class="headerlink" title="b.链表法"></a>b.链表法</h5><blockquote><p>链表法就是在散列表中，把每个“桶(bucket)”或者“槽(slot)”会对应一条链表，所有散列 值相同的元素我们都放到相同槽位对应的链表中。</p></blockquote><p><strong>插入&amp;删除</strong><br><strong>插入操作</strong>:将数据进行散列操作，找到对应的槽位，然后再对应的链表中进行插入操作。时间复杂度为O(1);<br><strong>删除操作</strong>:将数据进行散列操作，找到对应的槽位，然后再对应的链表中遍历找到元素进行删除操作。时间复杂度就等于链表中遍历找到元素进行删除操作的时间复杂度。如果链表长度为k那么时间复杂度就为k。然后对于散列比较均匀的散列函数来说，理论上为 <strong>k = n / m</strong>。n表示散列表中数据个数，m表示散列表中槽的个数。 </p><h3 id="五、Word-文档中单词拼写检查功能-是如何实现的"><a href="#五、Word-文档中单词拼写检查功能-是如何实现的" class="headerlink" title="五、Word 文档中单词拼写检查功能 是如何实现的?"></a>五、Word 文档中单词拼写检查功能 是如何实现的?</h3><blockquote><p>常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB。可以用散列表来存储整个英文单词词典。<br>当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼 写正确;如果没有查到，则说明拼写可能有误，给予提示。</p></blockquote><h2 id="第15课-散列表-中"><a href="#第15课-散列表-中" class="headerlink" title="第15课 - - - - - - -散列表(中)"></a>第15课 - - - - - - -散列表(中)</h2><h3 id="一、如何设计散列函数"><a href="#一、如何设计散列函数" class="headerlink" title="一、如何设计散列函数"></a>一、如何设计散列函数</h3><blockquote><p>1.散列函数的设计不能太复杂，过于复杂的散列函数会消耗过多的时间，间接影响散列表的性能。<br>2.散列函数生成的值要尽可能随机并且均匀分布。</p></blockquote><p><strong>散列函数的一些设计方法</strong>：<br>数据分析法、直接寻址法、平方取中值法、折叠法、随机数法、等等。</p><h3 id="二、装载因子过大的解决办法"><a href="#二、装载因子过大的解决办法" class="headerlink" title="二、装载因子过大的解决办法"></a>二、装载因子过大的解决办法</h3><p>可以设置一个装载因子的临界值，达到这个临界值以后就对散列表进行动态扩容。<br>可以先申请一个原来散列表大小两倍的空间，这个时候散列表对应的装载因子就为原来的一半，并且重新设计散列函数。<br>如果这时候对所有数据进行搬移，使用均摊法，可以得到时间复杂度为O(n)。</p><h3 id="二、避免低效扩容"><a href="#二、避免低效扩容" class="headerlink" title="二、避免低效扩容"></a>二、避免低效扩容</h3><blockquote><p>在动态扩容的过程中，当我们申请了新的内存空间以后，可以先不全部搬移数据。<br>而是把数据搬移的操作穿插在散列表的新数据的普通插入操作中，这个时候，<strong>一次性</strong>的扩容就被均分到多次普通插入操作中。可以解决扩容时那次操作造成的系统拥堵。这种情况下时间复杂度为O(1)。<br>即，当有新数据插入时，先将新数据插入新散列表，并且从老的散列表中拿一个数据放入到新的散列表中。经过多次这样的操作，老的散列表数据被完全搬移到新散列表以后，释放老散列表的空间。</p></blockquote><h3 id="三、处理散列冲突"><a href="#三、处理散列冲突" class="headerlink" title="三、处理散列冲突"></a>三、处理散列冲突</h3><h4 id="1-开放寻址法"><a href="#1-开放寻址法" class="headerlink" title="1.开放寻址法"></a>1.开放寻址法</h4><blockquote><p><strong>优点</strong>:<br>a.数据都存储在数组中，CPU缓存查查询速度快。<br>b.这种形式的散列表序列化起来比较简单。相对的链表法实现的散列表序列化相对困难。<br><strong>缺点</strong>:<br>a.删除节点的时候比较麻烦，需要特殊标记已经删除的数据。<br>b.散列冲突的代价更高。<br>开放寻址法，适合装载因子上限不大的散列表。<br>开放寻址法只适用于转载因子小于1，且当装载因子接近1的时候，就会有大量的散列冲突，导致大量的探测，再散列等，性能下降很多。</p></blockquote><p><strong>当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。</strong></p><h4 id="2-链表法"><a href="#2-链表法" class="headerlink" title="2.链表法"></a>2.链表法</h4><blockquote><p><strong>优点</strong><br>a.链表法对内存的利用率比开放寻址法高。<em>即用即申请</em>。<br>b.对装载因子的容忍度比开放寻址法高。<br>c.当数据是大对象的时候，指针的空间消耗，不值一提。</p></blockquote><p><strong>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列 表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表</strong></p><h3 id="四、工业级散列表举例分析"><a href="#四、工业级散列表举例分析" class="headerlink" title="四、工业级散列表举例分析"></a>四、工业级散列表举例分析</h3><p><font size="5"><strong>《java HashMap》</strong></font></p><h4 id="1-初始大小"><a href="#1-初始大小" class="headerlink" title="1. 初始大小"></a>1. 初始大小</h4><blockquote><p>初始大小为16，可以设置。如果事先知道大概数据量，可以设置，避免扩容操作。</p></blockquote><h4 id="2-装载因子和动态扩容"><a href="#2-装载因子和动态扩容" class="headerlink" title="2.装载因子和动态扩容"></a>2.装载因子和动态扩容</h4><blockquote><p>最大装载因子是0.75，超过以后就进行扩容，扩容空间为原来的两倍。</p></blockquote><h4 id="3-散列冲突解决方法"><a href="#3-散列冲突解决方法" class="headerlink" title="3.散列冲突解决方法"></a>3.散列冲突解决方法</h4><blockquote><p>最开始底层采用链表法解决冲突。<br>JDK1.8以后，当链表长度超过8，就转换为用红黑树解决。当红黑树节点少于8个的时候，又转为用链表解决。</p></blockquote><h4 id="4-散列函数"><a href="#4-散列函数" class="headerlink" title="4.散列函数"></a>4.散列函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = key.hashCode();</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; (capitity -<span class="number">1</span>); <span class="comment">//capicity 表示散列表的大小</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1 = <span class="keyword">this</span>.hash;</span><br><span class="line">    <span class="keyword">if</span>(var1 == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] var2 = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; <span class="keyword">this</span>.value.length; ++var3) &#123;</span><br><span class="line">            var1 = <span class="number">31</span> * var1 + var2[var3];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.hash = var1; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var1; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="五、工业级散列表"><a href="#五、工业级散列表" class="headerlink" title="五、工业级散列表"></a>五、工业级散列表</h3><h4 id="1-特性"><a href="#1-特性" class="headerlink" title="1.特性:"></a>1.特性:</h4><blockquote><p>a.支持快速的查询、插入、删除操作;<br>b.内存占用合理，不能浪费过多的内存空间; c.性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。</p></blockquote><h4 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现:"></a>2.实现:</h4><blockquote><p>a.设计一个合适的散列函数;<br>b.定义装载因子阈值，并且设计动态扩容策略;<br>c.选择合适的散列冲突解决方法。</p></blockquote><h2 id="第16课-散列表-下"><a href="#第16课-散列表-下" class="headerlink" title="第16课 - - - - - - -散列表(下)"></a>第16课 - - - - - - -散列表(下)</h2><h3 id="一、LRU缓存淘汰算法"><a href="#一、LRU缓存淘汰算法" class="headerlink" title="一、LRU缓存淘汰算法"></a>一、LRU缓存淘汰算法</h3><p><img src="/2020/04/24/DataStructure07/LRU.png" alt></p><h4 id="1-设计原理："><a href="#1-设计原理：" class="headerlink" title="1.设计原理："></a>1.设计原理：</h4><blockquote><p>a.通过散列表法来解决散列冲突。<br>b.这个链表含有两条链<br>1).一条是存储相同hash值的元素的双向链表<br>2).一条是把所有元素串起来的链</p></blockquote><h4 id="1-查找插入删除操作："><a href="#1-查找插入删除操作：" class="headerlink" title="1.查找插入删除操作："></a>1.查找插入删除操作：</h4><p>a.<strong>查找数据</strong><br>通过散列表查找，找到对应的槽，然后遍历链表查找，找到以后将数据移动到遍历的起始节点之前。平摊以后时间复杂度为O(1);<br>b.<strong>删除数据</strong><br>先通过a查找到数据，然后删除节点，双向链表删除节点的时间复杂度为O(1);<br>c.<strong>添加一个数据</strong><br>先查询这个数据是否已经在缓存中，<br>如果已经在缓存中，将其移动到链表遍历的起始节点之前。<br>如果不存在缓存中，就要看缓存是否已满(通过一个缓存计数变量实现)，<br>如果满了，就将双向链表遍历末尾节点删除，将添加的节点放在链表遍历的起始节点之前。<br>如果没满，就直接将添加的节点放在链表遍历的起始节点之前。</p><h3 id="二、Redis有序集合"><a href="#二、Redis有序集合" class="headerlink" title="二、Redis有序集合"></a>二、Redis有序集合</h3><h4 id="1-设计原理：-1"><a href="#1-设计原理：-1" class="headerlink" title="1.设计原理："></a>1.设计原理：</h4><blockquote><p>通过散列表实现；<br>散列冲突通过链表法解决；<br>链表上面两条链，一条双向链表，一条顺序查询链表(这条链表通过跳表实现)。</p></blockquote><h4 id="2-处理问题"><a href="#2-处理问题" class="headerlink" title="2.处理问题:"></a>2.处理问题:</h4><blockquote><p>查找通过散列表<br>删除通过散列表，然后看情况决定是否修改跳表<br>插入通过散列表，然后看情况决定是否修改跳表<br>按分区查找通过跳表实现</p></blockquote><h3 id="三、Java-LinkedHashMap"><a href="#三、Java-LinkedHashMap" class="headerlink" title="三、Java LinkedHashMap"></a>三、Java LinkedHashMap</h3><p>和上面LRU实现相同。<br><strong>LinkedHashMap 是通过双向链表和散列表这两种数据结构 组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表 法解决散列冲突。</strong>；</p><h3 id="四、为什么散列表和链表经常一块使用"><a href="#四、为什么散列表和链表经常一块使用" class="headerlink" title="四、为什么散列表和链表经常一块使用?"></a>四、为什么散列表和链表经常一块使用?</h3><p>散列表的插入、删除、查找操作非常高效。但是数据通过哈希函数以后，被打乱了顺序，变得无规律。<br>无法支持按照某种顺序快速的遍历数据。<br>所以把散列表和链表(或者跳表)结合使用，就能实现高效的插入删除查找操作，以及按顺序或者区间遍历数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第14课-散列表-上&quot;&gt;&lt;a href=&quot;#第14课-散列表-上&quot; class=&quot;headerlink&quot; title=&quot;第14课 - 
      
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 06 跳表</title>
    <link href="http://yoursite.com/2020/04/23/DataStructure06/"/>
    <id>http://yoursite.com/2020/04/23/DataStructure06/</id>
    <published>2020-04-23T11:57:54.908Z</published>
    <updated>2020-04-24T09:55:38.857Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。</p></blockquote><h2 id="第13课-跳表"><a href="#第13课-跳表" class="headerlink" title="第13课 - - - - - - -跳表"></a>第13课 - - - - - - -跳表</h2><h3 id="一、跳表的定义"><a href="#一、跳表的定义" class="headerlink" title="一、跳表的定义"></a>一、跳表的定义</h3><blockquote><p>跳表就是链表加多级索引的动态数据结构。</p></blockquote><p><img src="/2020/04/23/DataStructure06/skipList.png" alt></p><h3 id="二、跳表查找的时间复杂度"><a href="#二、跳表查找的时间复杂度" class="headerlink" title="二、跳表查找的时间复杂度"></a>二、跳表查找的时间复杂度</h3><blockquote><p>当每两个节点就抽出一个节点作为上级索引节点的情况下。<br>查找一个元素的时间复杂度和二分查找相当，是O(logn)。</p></blockquote><h3 id="三、跳表查找的空间复杂度"><a href="#三、跳表查找的空间复杂度" class="headerlink" title="三、跳表查找的空间复杂度"></a>三、跳表查找的空间复杂度</h3><blockquote><p>当每两个节点就抽出一个节点作为上级索引节点的情况下。<br>每两个元素向上提取一个元素，那么，最后额外需要的空间就是：n/2 + (n/2)^2 + (n/2)^3 + … + 8 + 4 + 2 = n - 2。所以空间复杂度为O(n)。<br>每三个节点抽出一个节点作为上级节点的情况下复杂度为n/2虽然也是O(n)但是实际减少了一半。</p></blockquote><h3 id="四、跳表的动态插入和删除"><a href="#四、跳表的动态插入和删除" class="headerlink" title="四、跳表的动态插入和删除"></a>四、跳表的动态插入和删除</h3><h4 id="1-插入操作"><a href="#1-插入操作" class="headerlink" title="1.插入操作"></a>1.插入操作</h4><blockquote><p> 首先需要找到插入节点的位置，时间复杂度为O(logn)，然后插入操作为O(1)，所以时间复杂度为O(logn)。</p></blockquote><h4 id="2-删除操作"><a href="#2-删除操作" class="headerlink" title="2.删除操作"></a>2.删除操作</h4><blockquote><p>如果需要删除的节点在索引中也出现，我们除了要删除链表里面的节点，还要删除索引中的节点。<br>注意：如果是在单链表中，要删除一个节点首先需要拿到一个节点的前驱节点才能进行删除。</p></blockquote><h3 id="五、跳表的动态更新"><a href="#五、跳表的动态更新" class="headerlink" title="五、跳表的动态更新"></a>五、跳表的动态更新</h3><p> 当我们不停的往跳表中插入数据的时候，如果我们不添加更新索引，就会导致2个索引节点之间的数据非常多。极端情况下还会退化成单链表。导致查找的效率降低。</p><blockquote><p>作为一种动态数据结构，我们需要某种手段来维护索引和原始链表大小之间的平衡。也就是说，如果链表中的节点多了，索引就相应的增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。<br><strong>我们通过一个随机函数来决定将这个节点插入到哪几层索引中</strong>，比如随机函数生成了值k，我们就将这个节点添加到第一级到第k级这k级索引中。</p></blockquote><h3 id="五、为什么-Redis-要用跳表来-实现有序集合，而不是红黑树"><a href="#五、为什么-Redis-要用跳表来-实现有序集合，而不是红黑树" class="headerlink" title="五、为什么 Redis 要用跳表来 实现有序集合，而不是红黑树?"></a>五、为什么 Redis 要用跳表来 实现有序集合，而不是红黑树?</h3><blockquote><p>首先，我们来分析下Redis的有序集合支持的操作：<br>1）插入元素<br>2）删除元素<br>3）查找元素<br>4）有序输出所有元素<br>5）查找区间内所有元素<br>其中，前4项红黑树都可以完成，且时间复杂度与跳表一致。<br>但是，最后一项，红黑树的效率就没有跳表高了。<br>在跳表中，要查找区间的元素，我们只要定位到两个区间端点在最低层级的位置，然后按顺序遍历元素就可以了，非常高效。<br>而红黑树只能定位到端点后，再从首位置开始每次都要查找后继节点，相对来说是比较耗时的。<br>此外，跳表实现起来很容易且易读，红黑树实现起来相对困难，所以Redis选择使用跳表来实现有序集合。</p></blockquote><h3 id="六、跳表的实现"><a href="#六、跳表的实现" class="headerlink" title="六、跳表的实现"></a>六、跳表的实现</h3><blockquote><p>后面有时间再补。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第13课-跳表&quot;&gt;&lt;a href=&quot;#第13课-跳表&quot; class=&quot;headerlink&quot; title=&quot;第13课 - - - - 
      
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》 05 二分查找</title>
    <link href="http://yoursite.com/2020/04/23/DataStructure05/"/>
    <id>http://yoursite.com/2020/04/23/DataStructure05/</id>
    <published>2020-04-23T11:32:24.228Z</published>
    <updated>2020-04-24T09:55:35.138Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。</p></blockquote><h2 id="第11课-二分查找-上"><a href="#第11课-二分查找-上" class="headerlink" title="第11课 - - - - - - - 二分查找(上)"></a>第11课 - - - - - - - 二分查找(上)</h2><h3 id="一、二分查找思想"><a href="#一、二分查找思想" class="headerlink" title="一、二分查找思想"></a>一、二分查找思想</h3><blockquote><p>二分查找针对的是一个有序的数据集合，查找思想类似分治思想。每次都通过跟区间的中间元素对比，将查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0。</p></blockquote><h3 id="二、二分查找的时间复杂度"><a href="#二、二分查找的时间复杂度" class="headerlink" title="二、二分查找的时间复杂度"></a>二、二分查找的时间复杂度</h3><h4 id="1-二分查找的时间复杂度推导"><a href="#1-二分查找的时间复杂度推导" class="headerlink" title="1.二分查找的时间复杂度推导"></a>1.二分查找的时间复杂度推导</h4><p>被查找的区间的大小变化为:<br>n,n/2,n/4,n/8,…,n/(2^k),…<br>由于每次缩小都只比较两个数的大小，所以经过k次区间缩小的操作，当区间为1的时候就是必定找到数据。<br>即n/(2^k) = 1;其中k就是总共缩小的次数，k = logn(以2为底数),所以时间复杂度为O(logn)。</p><h4 id="2-二分查找的递归和非递归实现"><a href="#2-二分查找的递归和非递归实现" class="headerlink" title="2.二分查找的递归和非递归实现"></a>2.二分查找的递归和非递归实现</h4><p><strong><em>非递归实现</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bSearch</span><span class="params">(<span class="keyword">int</span> * nums, <span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">NULL</span> || <span class="built_in">size</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = <span class="built_in">size</span><span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; value)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; value) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>三个需要注意的点</strong><br>a.循环退出条件:low &lt;= high<br>b.mid 取值，为了不超过int的最大值:mid = low + (high-low)/2;还可以优化成:mid = low + ((high-low)&gt;&gt;2)”这里需要注意&gt;&gt;的运算优先级和+一样所以要多加一个括号”;<br>c.low和high的更新:low = mid + 1; high = mid - 1;<br><strong><em>递归实现</em></strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _bSearch2(<span class="keyword">int</span> * nums,<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = low + ((high - low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nums[mid]  == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; value) &#123;</span><br><span class="line">        <span class="keyword">return</span> _bSearch2(nums, low, mid - <span class="number">1</span>,value);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; value) &#123;</span><br><span class="line">        <span class="keyword">return</span> _bSearch2(nums, mid + <span class="number">1</span>, high, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bSearch2</span><span class="params">(<span class="keyword">int</span> * nums, <span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  _bSearch2(nums, <span class="number">0</span>, <span class="built_in">size</span><span class="number">-1</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、二分查找的应用局限性"><a href="#三、二分查找的应用局限性" class="headerlink" title="三、二分查找的应用局限性"></a>三、二分查找的应用局限性</h3><h4 id="1-依赖于顺序表结构，简单点说就是数组。"><a href="#1-依赖于顺序表结构，简单点说就是数组。" class="headerlink" title="1.依赖于顺序表结构，简单点说就是数组。"></a>1.依赖于顺序表结构，简单点说就是数组。</h4><blockquote><p>二分查找每次查找的时候都依赖下标进行随机访问。数组比较合适。</p></blockquote><h4 id="2-二分查找依赖于有序数据。"><a href="#2-二分查找依赖于有序数据。" class="headerlink" title="2.二分查找依赖于有序数据。"></a>2.二分查找依赖于有序数据。</h4><blockquote><p>如果是无序数据需要先排序，再进行查找。通常是一次排序，多次二分查找。</p></blockquote><h4 id="3-数据量太小不适合二分查找。"><a href="#3-数据量太小不适合二分查找。" class="headerlink" title="3.数据量太小不适合二分查找。"></a>3.数据量太小不适合二分查找。</h4><blockquote><p>数据量太小，使用二分查找或者顺序遍历，查找速度差不多。</p></blockquote><h4 id="4-数据量太大不适合二分查找。"><a href="#4-数据量太大不适合二分查找。" class="headerlink" title="4.数据量太大不适合二分查找。"></a>4.数据量太大不适合二分查找。</h4><blockquote><p>如果数据太多，不能一次性读入到<strong>连续</strong>的内存空间，就无法查找。关键是需要一片连续的内存空间。</p></blockquote><h3 id="四、如何在-1000-万个整数-中快速查找某个整数-内存限制100MB"><a href="#四、如何在-1000-万个整数-中快速查找某个整数-内存限制100MB" class="headerlink" title="四、如何在 1000 万个整数 中快速查找某个整数?(内存限制100MB)"></a>四、如何在 1000 万个整数 中快速查找某个整数?(内存限制100MB)</h3><blockquote><p>100 000 000个整数，每个数据大小是8字节，那么如果把全部数据存入内存需要1000000*8/1024/1024大约等于76MB。<br>那么我们可以通过把所有数据读入内存，然后进行二分查找。</p></blockquote><p>如果使用散列表和二叉树，因为需要额外空间，所以不能实现。</p><h3 id="五、课后题"><a href="#五、课后题" class="headerlink" title="五、课后题"></a>五、课后题</h3><h4 id="1-如何求一个数的平方根？要求精确到小数点后6位。"><a href="#1-如何求一个数的平方根？要求精确到小数点后6位。" class="headerlink" title="1.如何求一个数的平方根？要求精确到小数点后6位。"></a>1.如何求一个数的平方根？要求精确到小数点后6位。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">double mySqrt(int x,double t) &#123;</span><br><span class="line">    double low &#x3D; 0;</span><br><span class="line">    double high &#x3D; x;</span><br><span class="line">    double mid &#x3D; high&#x2F;2.;</span><br><span class="line">    while (high - low &gt; t) &#123;</span><br><span class="line">        if (mid*mid &gt; x) &#123;</span><br><span class="line">            high &#x3D; mid;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            low &#x3D; mid;</span><br><span class="line">        &#125;</span><br><span class="line">        mid &#x3D; low + (high-low)&#x2F;2.;</span><br><span class="line">    &#125;</span><br><span class="line">    return mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>两个数相乘的积去和x做比较,通过2分查找去找近似值。<br>以精度作为结束条件。</p></blockquote><h4 id="2-用链表来存储数据，使用二分查找算法的时间复杂度是多少？"><a href="#2-用链表来存储数据，使用二分查找算法的时间复杂度是多少？" class="headerlink" title="2.用链表来存储数据，使用二分查找算法的时间复杂度是多少？"></a>2.用链表来存储数据，使用二分查找算法的时间复杂度是多少？</h4><blockquote><p>时间复杂度为O(n)。<br>每次比较都要找到相应的数，找到这个数需要经过的次数为<br>第一次为 n/2<br>第二次为 n/4<br>…<br>第N次为 n/(2^n)<br>那么就是: （n/2 + n/4 + ….+n/(2^n)）/n = 1/2+1/4+….+1/(2^n) 近似n<br>所以时间复杂度为O(n)。</p></blockquote><h2 id="第12课-二分查找-下"><a href="#第12课-二分查找-下" class="headerlink" title="第12课 - - - - - - - 二分查找(下)"></a>第12课 - - - - - - - 二分查找(下)</h2><h4 id="一、查找第一个值等于给定值的元素"><a href="#一、查找第一个值等于给定值的元素" class="headerlink" title="一、查找第一个值等于给定值的元素"></a>一、查找第一个值等于给定值的元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找第一个x</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch1</span><span class="params">(<span class="keyword">int</span> * nums,<span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span>  mid = low + ((high-low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x &lt; nums[mid] ) &#123;</span><br><span class="line">            high  = mid <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (x &gt; nums[mid]) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x == nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span>|| nums[mid <span class="number">-1</span>] != x) &#123; <span class="comment">//在数组首位说明不存在更前的数。||前一个值不等于x</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//前一个值等于x</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、查找最后一个值等于给定值的元素"><a href="#二、查找最后一个值等于给定值的元素" class="headerlink" title="二、查找最后一个值等于给定值的元素"></a>二、查找最后一个值等于给定值的元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找最后一个x</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span> * nums,<span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x &lt; nums[mid]) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &gt; nums[mid]) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x == nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="built_in">size</span> <span class="number">-1</span> || nums[mid+<span class="number">1</span>] != x) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、查找第一个大于等于给定值"><a href="#三、查找第一个大于等于给定值" class="headerlink" title="三、查找第一个大于等于给定值"></a>三、查找第一个大于等于给定值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找第一个大于等于x的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch3</span><span class="params">(<span class="keyword">int</span> * nums,<span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = <span class="built_in">size</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (( high - low ) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid == <span class="number">0</span> || nums[mid <span class="number">-1</span>] &lt; x) &#123; <span class="comment">//前面没有更小的值</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &gt; nums[mid]) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、查找最后一个小于等于给定值"><a href="#四、查找最后一个小于等于给定值" class="headerlink" title="四、查找最后一个小于等于给定值"></a>四、查找最后一个小于等于给定值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找最后一个小于等于x的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">binarySearch4</span><span class="params">(<span class="keyword">int</span> * nums,<span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="built_in">size</span> - <span class="number">1</span> || nums[mid + <span class="number">1</span>] &gt; x) &#123; <span class="comment">//后一个数大于x</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; nums[mid]) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、如何快速定位一个IP地址的归属地-假设我-们有-12-万条这样的-IP-区间与归属地的对应关系，如何快速定位出一个IP地址的归属地呢"><a href="#四、如何快速定位一个IP地址的归属地-假设我-们有-12-万条这样的-IP-区间与归属地的对应关系，如何快速定位出一个IP地址的归属地呢" class="headerlink" title="四、如何快速定位一个IP地址的归属地?(假设我 们有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个IP地址的归属地呢?)"></a>四、如何快速定位一个IP地址的归属地?(假设我 们有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个IP地址的归属地呢?)</h4><blockquote><p>第一步,将ip地址进行排序,可以把ip转换为32位的整型数。按照整型值的大小进行从小到大的排序。<br>第二步,查询某个IP，通过二分查找，找到最后一个起始IP小于等于这个IP的IP区间，然后检查这个IP是否在这个IP的区间内，如果在，就取出相应的归属地，进行显示，如果不在就返回未找到。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第11课-二分查找-上&quot;&gt;&lt;a href=&quot;#第11课-二分查找-上&quot; class=&quot;headerlink&quot; title=&quot;第11课 
      
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》04 排序</title>
    <link href="http://yoursite.com/2020/04/20/DataStructure04/"/>
    <id>http://yoursite.com/2020/04/20/DataStructure04/</id>
    <published>2020-04-20T08:01:14.055Z</published>
    <updated>2020-04-24T09:55:29.360Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。</p></blockquote><h2 id="第07课-排序-上"><a href="#第07课-排序-上" class="headerlink" title="第07课 - - - - - - - 排序(上)"></a>第07课 - - - - - - - 排序(上)</h2><h3 id="一、排序中的一些概念"><a href="#一、排序中的一些概念" class="headerlink" title="一、排序中的一些概念"></a>一、排序中的一些概念</h3><h4 id="1-原地排序-Sorted-in-place"><a href="#1-原地排序-Sorted-in-place" class="headerlink" title="1.原地排序(Sorted in place)"></a>1.原地排序(Sorted in place)</h4><p>不消耗额外的空间，空间复杂度为O(1)；</p><h4 id="2-稳定性"><a href="#2-稳定性" class="headerlink" title="2.稳定性"></a>2.稳定性</h4><p>排序后，相等的元素之间原有的先后顺序不变，叫做稳定的排序算法，反之。</p><blockquote><p><strong>应用场景</strong>：按照金额对订单排序，相同金额的订单按照时间排序。</p></blockquote><h3 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a>二、冒泡排序</h3><h4 id="1-实现"><a href="#1-实现" class="headerlink" title="1.实现:"></a>1.实现:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> * nums, <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;<span class="comment">//通过添加提前退出，如果一轮都没有交换过，说明已经有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; <span class="built_in">size</span>; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123; <span class="comment">//不添加 = 为稳定排序算法</span></span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = temp;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-冒泡排序法是原地排序算法。"><a href="#2-冒泡排序法是原地排序算法。" class="headerlink" title="2.冒泡排序法是原地排序算法。"></a>2.冒泡排序法是原地排序算法。</h4><blockquote><p>只需要常量级的临时空间，空间复杂度为O(1)，所以是原地排序算法。</p></blockquote><h4 id="3-冒泡排序法的稳定性。"><a href="#3-冒泡排序法的稳定性。" class="headerlink" title="3.冒泡排序法的稳定性。"></a>3.冒泡排序法的稳定性。</h4><blockquote><p>当判断条件为<code>if (nums[i] &gt; nums[j])</code>时为稳定，为<code>if (nums[i] &gt;= nums[j])</code>时，为不稳定。</p></blockquote><h4 id="4-冒泡排序法的时间复杂度。"><a href="#4-冒泡排序法的时间复杂度。" class="headerlink" title="4.冒泡排序法的时间复杂度。"></a>4.冒泡排序法的时间复杂度。</h4><blockquote><p>最好情况是全部有序，需要进行n次比较得出O(n)。<br>最坏情况是倒序排列，需要进行n*(n-1)次比较得出，时间复杂度为O(n²)。</p></blockquote><h3 id="二、有序度、逆序度"><a href="#二、有序度、逆序度" class="headerlink" title="二、有序度、逆序度"></a>二、有序度、逆序度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-有序度是数组中具有有序关系的元素对个数。"><a href="#1-有序度是数组中具有有序关系的元素对个数。" class="headerlink" title="1.有序度是数组中具有有序关系的元素对个数。"></a>1.有序度是数组中具有<strong>有序关系的元素对</strong>个数。</h4><blockquote><p>其中有的有序元素对为<br>(1,5),(1,2),(1,4),(1,3),(2,4),(2,3)<br>为6</p></blockquote><h4 id="2-逆序度是数组中具有逆序关系的元素对个数。"><a href="#2-逆序度是数组中具有逆序关系的元素对个数。" class="headerlink" title="2.逆序度是数组中具有逆序关系的元素对个数。"></a>2.逆序度是数组中具有<strong>逆序关系的元素对</strong>个数。</h4><blockquote><p>其中有的逆序元素对为<br>(5,2),(5,4),(5,3),(4,3)<br>为4</p></blockquote><h4 id="3-完全有序的数组的有序度叫做满有序度。"><a href="#3-完全有序的数组的有序度叫做满有序度。" class="headerlink" title="3.完全有序的数组的有序度叫做满有序度。"></a>3.完全有序的数组的有序度叫做<strong>满有序度</strong>。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nums[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>其中有的有序元素对为<br>(1,2),(1,3),(1,4),(1,5),<br>(2,3),(2,4),(2,5),<br>(3,4),(3,5),<br>(4,5),<br>为10</p></blockquote><h4 id="4-逆序度-满有序度-有序度。"><a href="#4-逆序度-满有序度-有序度。" class="headerlink" title="4.逆序度 = 满有序度 - 有序度。"></a>4.逆序度 = 满有序度 - 有序度。</h4><blockquote><p>类似上面 <code>4 = 10 - 6</code></p></blockquote><h3 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h3><h4 id="1-实现-1"><a href="#1-实现-1" class="headerlink" title="1.实现:"></a>1.实现:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span> <span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">NULL</span> || <span class="built_in">size</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> indexValue = nums[i]; <span class="comment">//后一个位置用来比较的值。</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>; <span class="comment">//前面的比较队列</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j -- ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indexValue &lt; nums[j]) &#123; <span class="comment">//前面的数比比较值大就将前面的数向后移动。否则终止。</span></span><br><span class="line">                nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>] = indexValue; <span class="comment">//移动以后把比较值放在合适的位置。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-插入排序是原地排序算法"><a href="#2-插入排序是原地排序算法" class="headerlink" title="2.插入排序是原地排序算法"></a>2.插入排序是原地排序算法</h4><blockquote><p>插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1),是一个原地排序算法。</p></blockquote><h4 id="3-插入排序是稳定的排序算法"><a href="#3-插入排序是稳定的排序算法" class="headerlink" title="3.插入排序是稳定的排序算法"></a>3.插入排序是稳定的排序算法</h4><blockquote><p>判断条件<code>if (indexValue &lt; nums[j])</code>的时候是稳定排序算法。</p></blockquote><h4 id="4-插入排序的时间复杂度"><a href="#4-插入排序的时间复杂度" class="headerlink" title="4.插入排序的时间复杂度"></a>4.插入排序的时间复杂度</h4><blockquote><p>最好情况:当遇到一个完全有序的数据，只需要一次遍历就能完成，时间复杂度为O(n)。<br>最坏情况:当遇到一个完全倒序的数据，每次插入都相当于在数组头插入数据即1+2+…+n所以为(n+1)*n/2即为:O(n²)。</p></blockquote><h3 id="三、选择排序"><a href="#三、选择排序" class="headerlink" title="三、选择排序"></a>三、选择排序</h3><h4 id="1-实现-2"><a href="#1-实现-2" class="headerlink" title="1.实现:"></a>1.实现:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> * nums,<span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">NULL</span> || <span class="built_in">size</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span> ; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = i; <span class="comment">//当前值设为最小。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">size</span>; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="built_in">min</span>] &gt; nums[j]) &#123; <span class="comment">//如果有比当前值更小的，就设置为最小</span></span><br><span class="line">                <span class="built_in">min</span> = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换当前值和最小值</span></span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[<span class="built_in">min</span>];</span><br><span class="line">        nums[<span class="built_in">min</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-选择排序是原地排序算法"><a href="#2-选择排序是原地排序算法" class="headerlink" title="2.选择排序是原地排序算法"></a>2.选择排序是原地排序算法</h4><blockquote><p>插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1),是一个原地排序算法。</p></blockquote><h4 id="3-选择排序是不稳定的排序算法"><a href="#3-选择排序是不稳定的排序算法" class="headerlink" title="3.选择排序是不稳定的排序算法"></a>3.选择排序是不稳定的排序算法</h4><blockquote><p>由于每轮只交换一次，在最前面的数会被交换到后面去，所以是不稳定的排序算法。</p></blockquote><h4 id="4-选择排序的时间复杂度"><a href="#4-选择排序的时间复杂度" class="headerlink" title="4.选择排序的时间复杂度"></a>4.选择排序的时间复杂度</h4><blockquote><p>不论遇到什么样的情况，选择排序中的判断<code>if (nums[min] &gt; nums[j])</code>始终都要执行n*(n-1)次，所以最好和最坏的时间复杂度都是O(n)。</p></blockquote><h3 id="四、冒泡排序和插入排序的时间复杂度都是O-n2-，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢"><a href="#四、冒泡排序和插入排序的时间复杂度都是O-n2-，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢" class="headerlink" title="四、冒泡排序和插入排序的时间复杂度都是O(n2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢?"></a>四、冒泡排序和插入排序的时间复杂度都是O(n2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢?</h3><blockquote><p>冒泡排序不管怎么优化，元素交换的次数是 一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也 等于原始数据的逆序度。<br>但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序 需要 3 个赋值操作，而插入排序只需要 1 个。<br>所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n2)，但是如果我们希望 把性能优化做到极致，那肯定首选插入排序。</p></blockquote><h2 id="第08课-排序-下"><a href="#第08课-排序-下" class="headerlink" title="第08课 - - - - - - - 排序(下)"></a>第08课 - - - - - - - 排序(下)</h2><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="一、实现"><a href="#一、实现" class="headerlink" title="一、实现"></a>一、实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeArray</span> <span class="params">(<span class="keyword">int</span> * nums,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tempArray[right-left];</span><br><span class="line">    <span class="keyword">int</span> tempArrayIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min_left = left;</span><br><span class="line">    <span class="keyword">int</span> min_right = mid+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//两个数组比较小的放入临时数组</span></span><br><span class="line">    <span class="keyword">while</span> (min_left &lt;= mid &amp;&amp; min_right &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[min_left] &lt;= nums[min_right]) &#123; <span class="comment">//《=先取前面的保证稳定性</span></span><br><span class="line">            tempArray[tempArrayIndex++] = nums[min_left ++];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            tempArray[tempArrayIndex++] = nums[min_right ++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把剩下没放完的放入零式数组</span></span><br><span class="line">    <span class="keyword">while</span> (min_left &lt;= mid) &#123;</span><br><span class="line">         tempArray[tempArrayIndex++] = nums[min_left ++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (min_right &lt;= right) &#123;</span><br><span class="line">         tempArray[tempArrayIndex++] = nums[min_right ++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放回原数组</span></span><br><span class="line">    tempArrayIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i ++) &#123;</span><br><span class="line">        nums[i] = tempArray[tempArrayIndex++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _mergeSort(<span class="keyword">int</span> * nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123; <span class="comment">//当左边等于右边代表只有一个元素有序，需要返回。</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分成两份</span></span><br><span class="line">    <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,left,mid,right);</span><br><span class="line">    _mergeSort(nums, left, mid);</span><br><span class="line">    _mergeSort(nums, mid+<span class="number">1</span>, right);</span><br><span class="line">    mergeArray(nums,left,mid,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> * nums,<span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    _mergeSort(nums,<span class="number">0</span>,<span class="built_in">size</span><span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-归并排序不是原地排序算法"><a href="#2-归并排序不是原地排序算法" class="headerlink" title="2.归并排序不是原地排序算法"></a>2.归并排序不是原地排序算法</h4><blockquote><p>归并排序需要开辟额外空间进行排序。<br>每次开辟空间为:,且cpu运行时，一个线程，同时只有一个函数在运行,所以同一时间只会开辟一个空间。<code>int tempArray[right-left]</code>,依次是2,…n/4,n/2,n所以空间复杂度为O(n)。</p></blockquote><h4 id="3-归并排序是稳定的排序算法"><a href="#3-归并排序是稳定的排序算法" class="headerlink" title="3.归并排序是稳定的排序算法"></a>3.归并排序是稳定的排序算法</h4><blockquote><p>在合并数组的方法中<code>if (nums[min_left] &lt;= nums[min_right])</code><br>这里的<strong>&lt;=</strong>可以取前面的数组，所以不会造成相同元素的顺序置换，所以是稳定的排序算法。</p></blockquote><h4 id="4-归并排序的时间复杂度"><a href="#4-归并排序的时间复杂度" class="headerlink" title="4.归并排序的时间复杂度"></a>4.归并排序的时间复杂度</h4><blockquote><p>不好分析。。。记得nlogn</p></blockquote><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="1-实现-3"><a href="#1-实现-3" class="headerlink" title="1.实现"></a>1.实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _quickSort (<span class="keyword">int</span>* nums,<span class="keyword">int</span> low,<span class="keyword">int</span> high) &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> value = nums[low];</span><br><span class="line">    <span class="keyword">int</span> left = low;</span><br><span class="line">    <span class="keyword">int</span> right = high;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= value) &#123;</span><br><span class="line">            right --;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= value) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[right] = nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[left] = value;</span><br><span class="line">    _quickSort(nums, low, left);</span><br><span class="line">    _quickSort(nums, left+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-归并排序和快速排序对比"><a href="#2-归并排序和快速排序对比" class="headerlink" title="2.归并排序和快速排序对比"></a>2.归并排序和快速排序对比</h4><blockquote><p>a.归并排序的处理过程是下到上，先分开然后处理合成。<br>快速排序的处理过程是从上到下，先处理然后分开。<br>b.快速排序按照上面的实现方法是原地排序。而归并排序则不是原地排序。</p></blockquote><h4 id="3-快速排序的性能分析"><a href="#3-快速排序的性能分析" class="headerlink" title="3.快速排序的性能分析"></a>3.快速排序的性能分析</h4><blockquote><p>如果每次分区操作，选择的privot都能正好把数组分成大小接近相等的两个小区间，那么快排的时间复杂度为O(nlogn)。<br>如果选择的privot不合适，每次分区我们平均要扫 描大约 n/2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n2)。(例如倒序排列的数据，每次都选第一个数。)</p></blockquote><h4 id="4-如何通过快排思想在O-n-的时间复杂度内查找第k大元素。"><a href="#4-如何通过快排思想在O-n-的时间复杂度内查找第k大元素。" class="headerlink" title="4.如何通过快排思想在O(n)的时间复杂度内查找第k大元素。"></a>4.如何通过快排思想在O(n)的时间复杂度内查找第k大元素。</h4><p><strong>实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 查找第k大元素。</span></span><br><span class="line"><span class="comment">    从大到小排列，比较索引值，只执行在索引值范围内的那部分。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> _findK(<span class="keyword">int</span> * nums,<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span> value = nums[low];</span><br><span class="line">    <span class="keyword">int</span> left = low;</span><br><span class="line">    <span class="keyword">int</span> right = high;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] &lt;= value) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] &gt;= value) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[right] = nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[left] = value;</span><br><span class="line">    <span class="keyword">if</span> (left == k) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left &lt; k) &#123;</span><br><span class="line">       <span class="keyword">return</span> _findK(nums, left+<span class="number">1</span>, high, k);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>   _findK(nums, low, left, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findK</span><span class="params">(<span class="keyword">int</span> * nums,<span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _findK(nums, <span class="number">0</span>,<span class="built_in">size</span><span class="number">-1</span>, k<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第09课-线性排序"><a href="#第09课-线性排序" class="headerlink" title="第09课 - - - - - - - 线性排序"></a>第09课 - - - - - - - 线性排序</h2><h3 id="一、桶排序"><a href="#一、桶排序" class="headerlink" title="一、桶排序"></a>一、桶排序</h3><h4 id="1-桶排序定义-将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数-据按照顺序依次取出，组成的序列就是有序的了。"><a href="#1-桶排序定义-将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数-据按照顺序依次取出，组成的序列就是有序的了。" class="headerlink" title="1.桶排序定义 将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数 据按照顺序依次取出，组成的序列就是有序的了。"></a>1.桶排序定义 将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数 据按照顺序依次取出，组成的序列就是有序的了。</h4><h4 id="2-适用条件"><a href="#2-适用条件" class="headerlink" title="2.适用条件"></a>2.适用条件</h4><blockquote><p>条件苛刻:<br>1.数据容易划分成各个桶;<br>2.各个桶之间分布均匀;<br>3.划分的桶之间有着天然的大小顺序。<br>所以比较适合在外部排序中。</p></blockquote><h4 id="3-桶的划分"><a href="#3-桶的划分" class="headerlink" title="3.桶的划分"></a>3.桶的划分</h4><blockquote><p>按照内存能读取的值，可以对粒度进行仔细划分。<br>按照分布进行桶范围划分。</p></blockquote><h3 id="二、计数排序"><a href="#二、计数排序" class="headerlink" title="二、计数排序"></a>二、计数排序</h3><h4 id="1-实现-4"><a href="#1-实现-4" class="headerlink" title="1.实现"></a>1.实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span> * nums,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//计算桶最大范围</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">max</span> &lt; nums[i]) &#123;</span><br><span class="line">            <span class="built_in">max</span> = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建计数桶 并初始化.</span></span><br><span class="line">    <span class="keyword">int</span> countNums[<span class="built_in">max</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">max</span>; i ++) &#123;</span><br><span class="line">        countNums[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算每个桶内的元素个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i ++) &#123;</span><br><span class="line">        countNums[nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生成计数桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span>; i ++) &#123;</span><br><span class="line">        countNums[i] = countNums[i] + countNums[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//临时桶</span></span><br><span class="line">    <span class="keyword">int</span> temp[<span class="built_in">size</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">size</span>; i ++) &#123;</span><br><span class="line">        temp[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">size</span><span class="number">-1</span>; i &gt;=<span class="number">0</span>; i --) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums[i]; <span class="comment">//读取的数字</span></span><br><span class="line">        <span class="keyword">int</span> countNum = countNums[num]; <span class="comment">//计数桶中的数字</span></span><br><span class="line">        temp[countNum<span class="number">-1</span>] = num;</span><br><span class="line">        countNums[num]--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i ++) &#123;</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-时间复杂度"><a href="#2-时间复杂度" class="headerlink" title="2.时间复杂度"></a>2.时间复杂度</h4><p>计数排序的主体:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">size</span><span class="number">-1</span>; i &gt;=<span class="number">0</span>; i --) &#123;</span><br><span class="line">     <span class="keyword">int</span> num = nums[i]; <span class="comment">//读取的数字</span></span><br><span class="line">     <span class="keyword">int</span> countNum = countNums[num]; <span class="comment">//计数桶中的数字</span></span><br><span class="line">     temp[countNum<span class="number">-1</span>] = num;</span><br><span class="line">     countNums[num]--;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>所以桶排序的时间复杂度为O(n);</p><h4 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3.适用场景"></a>3.适用场景</h4><blockquote><p>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数<br>据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p></blockquote><h3 id="三、基数排序"><a href="#三、基数排序" class="headerlink" title="三、基数排序"></a>三、基数排序</h3><h4 id="1-实现-5"><a href="#1-实现-5" class="headerlink" title="1.实现"></a>1.实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _radixSort(<span class="keyword">int</span> * nums,<span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> wei) &#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (wei &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        k *= <span class="number">10</span>;</span><br><span class="line">        wei --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">10</span>][<span class="built_in">size</span>];</span><br><span class="line">    <span class="keyword">int</span> tempNumIndex[<span class="number">10</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">        tempNumIndex[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;  j &lt; <span class="built_in">size</span>; j ++) &#123;</span><br><span class="line">            temp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放入桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> bucket = nums[i]/k%<span class="number">10</span>;</span><br><span class="line">        temp[bucket][tempNumIndex[bucket]] = nums[i];</span><br><span class="line">        tempNumIndex[bucket] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行排序</span></span><br><span class="line">    <span class="keyword">int</span> tempNums[<span class="built_in">size</span>];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tempNumIndex[i]; j ++) &#123;</span><br><span class="line">            tempNums[index] = temp[i][j];</span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i ++) &#123;</span><br><span class="line">        nums[i] = tempNums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span> * nums,<span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">NULL</span> || <span class="built_in">size</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//寻找最大值</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; <span class="built_in">size</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">max</span> &lt; nums[i]) &#123;</span><br><span class="line">            <span class="built_in">max</span> = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对最大值取位</span></span><br><span class="line">    <span class="keyword">int</span> numWei = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">max</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">max</span> = <span class="built_in">max</span>/<span class="number">10</span>;</span><br><span class="line">        numWei ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//赋值回去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= numWei; i ++) &#123;</span><br><span class="line">        _radixSort(nums,<span class="built_in">size</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-排序思路"><a href="#2-排序思路" class="headerlink" title="2.排序思路"></a>2.排序思路</h4><blockquote><p>a.找数据最大值。<br>b.对最大值处理求出位数。<br>c.从最低位到最高位对数据进行多轮入桶排序。<br>d.桶排序方式：通过位数创建桶。<br>e.对桶进行排序的时候注意保证有序。排到最高位的时候，数据就有序了。</p></blockquote><h3 id="四、如何根据年龄给100万用户排序"><a href="#四、如何根据年龄给100万用户排序" class="headerlink" title="四、如何根据年龄给100万用户排序?"></a>四、如何根据年龄给100万用户排序?</h3><blockquote><p>问题主要考虑系统内存消耗。<br>先按照年龄划分1-120个桶，然后遍历数据，将数据放入桶。<br>某些桶可能人太多，可以将桶继续按照月份划分成更新的桶。如果月份还是多久继续划分。<br>知道可以将数据读入内存。然后通过快速排序对各个桶内数据进行排序。<br>那么桶内的数据是有序的，桶之间的元素也是有序的，就可以得到所有用户的有序数据。</p></blockquote><h2 id="第10课-排序算法优化"><a href="#第10课-排序算法优化" class="headerlink" title="第10课 - - - - - - - 排序算法优化"></a>第10课 - - - - - - - 排序算法优化</h2><h3 id="一、如何选择合适的排序算法？"><a href="#一、如何选择合适的排序算法？" class="headerlink" title="一、如何选择合适的排序算法？"></a>一、如何选择合适的排序算法？</h3><blockquote><p>1.对小规模的数据进行排序，可以选择时间复杂度为O(n)的算法。<br>2.如果对大规模的数据进行排序，可以选择时间复杂度为O(nlogn)的算法。<br>3.为了兼容任意规模的数据，一般都会首选时间复杂度是O(nlogn)的算法。<br>4.O(nlogn)的算法中，快排最差情况下的时间复杂度为O(n²)而归并排序最差也是O(nlogn)，但是归并排序需要额外的O(n)的空间复杂度。</p></blockquote><h3 id="二、如何优化快速排序"><a href="#二、如何优化快速排序" class="headerlink" title="二、如何优化快速排序?"></a>二、如何优化快速排序?</h3><blockquote><p>导致快速排序出现O(n²)出现的原因，就是因为分区点设置不合理，所以可以在分区点上做文章。<br>尽可能的降低时间复杂度，选择的分区点最好的情况就是被分区点分开的两个区中，数据的数量差不多。</p></blockquote><h4 id="1-三数取中法"><a href="#1-三数取中法" class="headerlink" title="1.三数取中法"></a>1.三数取中法</h4><blockquote><p>从整个区间的头尾和中间取元素，取三元素中大小在中间的数作为分区点。</p></blockquote><h4 id="2-随机法"><a href="#2-随机法" class="headerlink" title="2.随机法"></a>2.随机法</h4><blockquote><p>每次从区间中随机取一个元素,在平均情况下这样分区，可以降低时间复杂度退化为最糟糕的O(n²)的可能性。</p></blockquote><h3 id="三、glibc-gt-qsort-c的实现"><a href="#三、glibc-gt-qsort-c的实现" class="headerlink" title="三、glibc-&gt;qsort.c的实现"></a>三、glibc-&gt;qsort.c的实现</h3><h4 id="1-源码"><a href="#1-源码" class="headerlink" title="1.源码"></a>1.源码</h4><blockquote><p>以下源码分析,来自知乎,作者:丁冬。<a href="https://www.zhihu.com/question/39214230/answer/80244880" target="_blank" rel="noopener">直达链接</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">首先实现qsort需要有一个swap：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAP(a, b, size)</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">size_t</span> __size = (<span class="built_in">size</span>);</span><br><span class="line">      <span class="keyword">char</span> *__a = (a), *__b = (b);</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">char</span> __tmp = *__a;</span><br><span class="line">      *__a++ = *__b;</span><br><span class="line">      *__b++ = __tmp;</span><br><span class="line">    &#125; <span class="keyword">while</span> (--__size &gt; <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为了阅读方便，我把用于宏定义续行用的\去掉了，方便看到语法高亮。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SWAP的定义很简单，只是以char为单位长度进行交换。实际上，对于足够大的对象，这里还有</span></span><br><span class="line"><span class="comment">一定的优化空间，但qsort不能假定你的对象足够大。这也是qsort统计性能不如C++的</span></span><br><span class="line"><span class="comment">std::sort的原因之一。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所谓qsort并不是单纯的快速排序，当快速排序划分区间小到一定程度时，改用插入排序可以在</span></span><br><span class="line"><span class="comment">更少的耗时内完成排序。glibc将这个小区间定义为元素数不超过常数4的区间：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_THRESH 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可以认为对每一个小区间的插入排序耗时是不超过一个常数值（即对4个元素进行插入排序的最</span></span><br><span class="line"><span class="comment">差情况）的，这样插入排序总耗时也可以认为是线性的，不影响总体时间复杂度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">接下来这段不难理解：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *lo;</span><br><span class="line">    <span class="keyword">char</span> *hi;</span><br><span class="line">  &#125; stack_node;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE    (CHAR_BIT * sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUSH(low, high)    ((void) ((top-&gt;lo = (low)), (top-&gt;hi = (high)), ++top))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    POP(low, high)    ((void) (--top, (low = top-&gt;lo), (high = top-&gt;hi)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    STACK_NOT_EMPTY    (stack &lt; top)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这显然是要手动维护栈来模拟递归，避免实际递归的函数调用开销了。题主自己的实现在元素数</span></span><br><span class="line"><span class="comment">量过多的时候会崩溃，估计就是递归过深爆栈了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">比较值得一提的是STACK_SIZE的选择。由于元素数量是由一个size_t表示的，size_t的最大</span></span><br><span class="line"><span class="comment">值应该是2 ^ (CHAR_BIT * sizeof(size_t))，快速排序的理想“递归”深度是对元素总数</span></span><br><span class="line"><span class="comment">求对数，所以理想的“递归”深度是CHAR_BIT * sizeof(size_t)。虽然理论上最差情况下</span></span><br><span class="line"><span class="comment">“递归”深度会变成2 ^ (CHAR_BIT * sizeof(size_t))，但是一方面我们不需要从头到尾</span></span><br><span class="line"><span class="comment">快速排序（区间足够小时改用插入排序），另一方面，我们是在假设元素数量等于size_t的上</span></span><br><span class="line"><span class="comment">限...这都把内存给挤满了=_=所以最后glibc决定直接采用理想“递归”深度作为栈大小上限。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">接下来该进入qsort的正文了：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_quicksort (<span class="keyword">void</span> *<span class="keyword">const</span> pbase, <span class="keyword">size_t</span> total_elems, <span class="keyword">size_t</span> <span class="built_in">size</span>,</span><br><span class="line">        <span class="keyword">__compar_d_fn_t</span> cmp, <span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">qsort实际上是通过调用这个_quicksort实现的。最后的arg是个workaround，用来搞定</span></span><br><span class="line"><span class="comment">qsort_r的。暂且不去理会。下面是一些准备工作：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> *base_ptr = (<span class="keyword">char</span> *) pbase;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> max_thresh = MAX_THRESH * <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (total_elems == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">明确了对内存操作是以sizeof(char)为单位的。max_thresh实际上是改用插入排序时，维护</span></span><br><span class="line"><span class="comment">当前区间的两个指针（类型均为char*）之间的距离。另外，如果元素数量为0，qsort啥也不</span></span><br><span class="line"><span class="comment">干，函数直接返回。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (total_elems &gt; MAX_THRESH)</span><br><span class="line"> <span class="comment">// 如果元素数大于终止区间（4个元素），则进行快速排序</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">char</span> *lo = base_ptr;</span><br><span class="line">      <span class="keyword">char</span> *hi = &amp;lo[<span class="built_in">size</span> * (total_elems - <span class="number">1</span>)];</span><br><span class="line">      stack_node <span class="built_in">stack</span>[STACK_SIZE];</span><br><span class="line">      stack_node *top = <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line">      PUSH (<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">开始维护“递归”栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (STACK_NOT_EMPTY)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">char</span> *left_ptr;</span><br><span class="line">          <span class="keyword">char</span> *right_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里采用的是中值划分，用于降低特定序列导致递归恶化影响。也就是说，对区间里的首元</span></span><br><span class="line"><span class="comment">素、中间元素和尾元素先进行排序。排序方式是...呃，是冒泡。反正也就3个元素嘛。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">char</span> *mid = lo + <span class="built_in">size</span> * ((hi - lo) / <span class="built_in">size</span> &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((*cmp) ((<span class="keyword">void</span> *) mid, (<span class="keyword">void</span> *) lo, arg) &lt; <span class="number">0</span>)</span><br><span class="line">        SWAP (mid, lo, <span class="built_in">size</span>);</span><br><span class="line">      <span class="keyword">if</span> ((*cmp) ((<span class="keyword">void</span> *) hi, (<span class="keyword">void</span> *) mid, arg) &lt; <span class="number">0</span>)</span><br><span class="line">        SWAP (mid, hi, <span class="built_in">size</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">goto</span> jump_over;</span><br><span class="line">      <span class="keyword">if</span> ((*cmp) ((<span class="keyword">void</span> *) mid, (<span class="keyword">void</span> *) lo, arg) &lt; <span class="number">0</span>)</span><br><span class="line">        SWAP (mid, lo, <span class="built_in">size</span>);</span><br><span class="line">    jump_over:;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接下来就要进行快排划分了：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">      left_ptr  = lo + <span class="built_in">size</span>;</span><br><span class="line">      right_ptr = hi - <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">while</span> ((*cmp) ((<span class="keyword">void</span> *) left_ptr, (<span class="keyword">void</span> *) mid, arg) &lt; <span class="number">0</span>)</span><br><span class="line">        left_ptr += <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> ((*cmp) ((<span class="keyword">void</span> *) mid, (<span class="keyword">void</span> *) right_ptr, arg) &lt; <span class="number">0</span>)</span><br><span class="line">        right_ptr -= <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">和传统的划分方式不同，首先把中间当作键值在左侧找到一个不小于mid的元素，右侧找到一个</span></span><br><span class="line"><span class="comment">不大于mid的元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (left_ptr &lt; right_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">          SWAP (left_ptr, right_ptr, <span class="built_in">size</span>);</span><br><span class="line">          <span class="keyword">if</span> (mid == left_ptr)</span><br><span class="line">            mid = right_ptr;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (mid == right_ptr)</span><br><span class="line">            mid = left_ptr;</span><br><span class="line">          left_ptr += <span class="built_in">size</span>;</span><br><span class="line">          right_ptr -= <span class="built_in">size</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果左右侧找到的不是同一个元素，那就交换之。如果左右侧任意一侧已经达到mid，就把mid往</span></span><br><span class="line"><span class="comment">另一边挪。因为键值已经被“丢”过去了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (left_ptr == right_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">          left_ptr += <span class="built_in">size</span>;</span><br><span class="line">          right_ptr -= <span class="built_in">size</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果左右侧是同一元素，划分其实已经大功告成了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (left_ptr &lt;= right_ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接下来，将划分出来的所有大于的终止区间的区间压入栈准备下一次划分，连这里都会发生丧心</span></span><br><span class="line"><span class="comment">病狂的优化...不能浪费已经在栈里的原区间上下界=_=</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((<span class="keyword">size_t</span>) (right_ptr - lo) &lt;= max_thresh)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">if</span> ((<span class="keyword">size_t</span>) (hi - left_ptr) &lt;= max_thresh)</span><br><span class="line">                POP (lo, hi);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                lo = left_ptr;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">size_t</span>) (hi - left_ptr) &lt;= max_thresh)</span><br><span class="line">            hi = right_ptr;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((right_ptr - lo) &gt; (hi - left_ptr))</span><br><span class="line">            &#123;</span><br><span class="line">              PUSH (lo, right_ptr);</span><br><span class="line">              lo = left_ptr;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              PUSH (left_ptr, hi);</span><br><span class="line">              hi = right_ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">至此快速排序工作结束。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(x, y) ((x) &lt; (y) ? (x) : (y))</span></span><br><span class="line"> <span class="comment">// 头一回学宏“函数”都应该见过这货吧</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接下来是插入排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">众所周知，传统的插入排序中每一趟插入（假设是向前插入），我们都会迭代有序区间，如果已</span></span><br><span class="line"><span class="comment">经迭代到了区间头部，那就把该元素插在区间首部；否则如果前一个元素不大于待插入元素，则</span></span><br><span class="line"><span class="comment">插在该元素之后。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这种插入方式会导致每一次迭代要进行两次比较：一次比较当前迭代位置与区间首部，一次比较</span></span><br><span class="line"><span class="comment">两个元素大小。但事实上，我们可以用一个小技巧省掉前一次比较————插入排序开始前，先将容</span></span><br><span class="line"><span class="comment">器内最小元素放到容器首部，这样就可以保证每趟插入你永远不会迭代到区间首部，因为你总能</span></span><br><span class="line"><span class="comment">在中途找到一个不小于自己的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意，如果区间大于终止区间，搜索最小元素时我们不必遍历整个区间，因为快速排序保证最小</span></span><br><span class="line"><span class="comment">元素一定被划分到了第一个终止区间，也就是头4个元素之内。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *<span class="keyword">const</span> end_ptr = &amp;base_ptr[<span class="built_in">size</span> * (total_elems - <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">char</span> *tmp_ptr = base_ptr;</span><br><span class="line">    <span class="keyword">char</span> *thresh = <span class="built_in">min</span>(end_ptr, base_ptr + max_thresh);</span><br><span class="line">    <span class="keyword">char</span> *run_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (run_ptr = tmp_ptr + <span class="built_in">size</span>; run_ptr &lt;= thresh; run_ptr += <span class="built_in">size</span>)</span><br><span class="line">      <span class="keyword">if</span> ((*cmp) ((<span class="keyword">void</span> *) run_ptr, (<span class="keyword">void</span> *) tmp_ptr, arg) &lt; <span class="number">0</span>)</span><br><span class="line">        tmp_ptr = run_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tmp_ptr != base_ptr)</span><br><span class="line">      SWAP (tmp_ptr, base_ptr, <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">准备工作完毕，这下可以放心地干掉迭代位置的比较了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    run_ptr = base_ptr + <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">while</span> ((run_ptr += <span class="built_in">size</span>) &lt;= end_ptr)</span><br><span class="line">      &#123;</span><br><span class="line">    tmp_ptr = run_ptr - <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">while</span> ((*cmp) ((<span class="keyword">void</span> *) run_ptr, (<span class="keyword">void</span> *) tmp_ptr, arg) &lt; <span class="number">0</span>)</span><br><span class="line">      tmp_ptr -= <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    tmp_ptr += <span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmp_ptr != run_ptr)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">char</span> *trav;</span><br><span class="line"></span><br><span class="line">        trav = run_ptr + <span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">while</span> (--trav &gt;= run_ptr)</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">char</span> c = *trav;</span><br><span class="line">                <span class="keyword">char</span> *hi, *lo;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (hi = lo = trav; (lo -= <span class="built_in">size</span>) &gt;= tmp_ptr; hi = lo)</span><br><span class="line">                  *hi = *lo;</span><br><span class="line">                *hi = c;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">至此，qsort工作完成。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="2-glibc-gt-qsort-c内部逻辑"><a href="#2-glibc-gt-qsort-c内部逻辑" class="headerlink" title="2.glibc-&gt;qsort.c内部逻辑"></a>2.glibc-&gt;qsort.c内部逻辑</h4><blockquote><p>1.先判断元素个数，如果个数大于MAX_THRESH(4)个则进行快速排序，如果小于MAX_THRESH(4)个则进行插入排序。<br>2.快速排序的时候，会手动维护一个递归栈。快排的划分的基准通过中值划分，前中后三个数，通过冒泡排序进行排序，找到中值作为快速排序的划分基准。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第07课-排序-上&quot;&gt;&lt;a href=&quot;#第07课-排序-上&quot; class=&quot;headerlink&quot; title=&quot;第07课 - - 
      
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》03 递归</title>
    <link href="http://yoursite.com/2020/04/20/DataStructure03/"/>
    <id>http://yoursite.com/2020/04/20/DataStructure03/</id>
    <published>2020-04-20T06:56:17.097Z</published>
    <updated>2020-04-24T09:55:21.104Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。</p></blockquote><h2 id="第06课-递归"><a href="#第06课-递归" class="headerlink" title="第06课 - - - - - - - 递归"></a>第06课 - - - - - - - 递归</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><blockquote><p>递归就是一个函数在它的函数体内调用它自身。</p></blockquote><h4 id="一、递归需要满足的三个条件"><a href="#一、递归需要满足的三个条件" class="headerlink" title="一、递归需要满足的三个条件"></a>一、递归需要满足的三个条件</h4><h5 id="1、一个问题的解可以分为几个子问题的解"><a href="#1、一个问题的解可以分为几个子问题的解" class="headerlink" title="1、一个问题的解可以分为几个子问题的解"></a>1、一个问题的解可以分为几个子问题的解</h5><h5 id="2、这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"><a href="#2、这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样" class="headerlink" title="2、这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"></a>2、这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</h5><h5 id="3、存在递归终止条件"><a href="#3、存在递归终止条件" class="headerlink" title="3、存在递归终止条件"></a>3、存在递归终止条件</h5><h4 id="二、如何编写递归代码"><a href="#二、如何编写递归代码" class="headerlink" title="二、如何编写递归代码"></a>二、如何编写递归代码</h4><h5 id="1-写出递推公式"><a href="#1-写出递推公式" class="headerlink" title="1.写出递推公式"></a>1.写出递推公式</h5><h5 id="2-找出终止条件"><a href="#2-找出终止条件" class="headerlink" title="2.找出终止条件"></a>2.找出终止条件</h5><h4 id="三、递归代码要警惕堆栈溢出"><a href="#三、递归代码要警惕堆栈溢出" class="headerlink" title="三、递归代码要警惕堆栈溢出"></a>三、递归代码要警惕堆栈溢出</h4><p>一般通过改写为非递归来解决堆栈溢出问题。</p><h4 id="四、递归代码要警惕重复计算"><a href="#四、递归代码要警惕重复计算" class="headerlink" title="四、递归代码要警惕重复计算"></a>四、递归代码要警惕重复计算</h4><p>一般通过添加一张散列表来记录已经计算的递归值。</p><h4 id="五、怎么将递归代码改写为非递归代码"><a href="#五、怎么将递归代码改写为非递归代码" class="headerlink" title="五、怎么将递归代码改写为非递归代码"></a>五、怎么将递归代码改写为非递归代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(x<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">2</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        ret = ret + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能一步或者两步，上N层楼梯方式有多少种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span> ; i &lt;= n ; i ++) &#123;</span><br><span class="line">        ret = num1 + num2;</span><br><span class="line">        num1 = num2;</span><br><span class="line">        num2 = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所有的递归都可以改为迭代循环的非递归写法。<br>但是实际上只是将递归改为手动递归，本质没有改变，还增加了实现的复杂度。</p></blockquote><h4 id="六、如果通过三行代码找到最终推荐人"><a href="#六、如果通过三行代码找到最终推荐人" class="headerlink" title="六、如果通过三行代码找到最终推荐人"></a>六、如果通过三行代码找到最终推荐人</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">findRootReferrerId</span><span class="params">(<span class="keyword">long</span> actorId)</span> </span>&#123;</span><br><span class="line">    推荐人id = select 推荐人id = from [table] where 用户id = actorId;</span><br><span class="line">    <span class="keyword">if</span>(推荐人id == <span class="literal">NULL</span>) <span class="keyword">return</span> 用户id;</span><br><span class="line">    <span class="keyword">return</span> findRootReferrerId（推荐人id）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="七、其他问题"><a href="#七、其他问题" class="headerlink" title="七、其他问题"></a>七、其他问题</h4><h5 id="1-如果递归很深，可能会有堆栈溢出问题。"><a href="#1-如果递归很深，可能会有堆栈溢出问题。" class="headerlink" title="1.如果递归很深，可能会有堆栈溢出问题。"></a>1.如果递归很深，可能会有堆栈溢出问题。</h5><blockquote><p>可以通过改写为非递归实现来解决。</p></blockquote><h5 id="2-递归环调用出现环。"><a href="#2-递归环调用出现环。" class="headerlink" title="2.递归环调用出现环。"></a>2.递归环调用出现环。</h5><blockquote><p>添加构造一个set集合或者散列表，通过保存调用记录，来比较新的调用记录是否存在。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第06课-递归&quot;&gt;&lt;a href=&quot;#第06课-递归&quot; class=&quot;headerlink&quot; title=&quot;第06课 - - - - 
      
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》02 栈 &amp; 队列</title>
    <link href="http://yoursite.com/2020/04/17/DataStructure02/"/>
    <id>http://yoursite.com/2020/04/17/DataStructure02/</id>
    <published>2020-04-17T07:54:22.973Z</published>
    <updated>2020-04-24T09:55:16.661Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。</p></blockquote><h2 id="第04课-栈"><a href="#第04课-栈" class="headerlink" title="第04课 - - - - - - - 栈"></a>第04课 - - - - - - - 栈</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="一、如何理解栈"><a href="#一、如何理解栈" class="headerlink" title="一、如何理解栈"></a>一、如何理解栈</h4><blockquote><p>其实就是FILO，先进后出，”操作受限”的线性表</p></blockquote><p>当某个数据结合只涉及在一端插入和删除数据，并且满足后进先出，先进后出的特性，我们就应该首选”栈”。</p><h4 id="二、如何实现栈"><a href="#二、如何实现栈" class="headerlink" title="二、如何实现栈"></a>二、如何实现栈</h4><h5 id="1-用数组实现栈，叫做顺序栈"><a href="#1-用数组实现栈，叫做顺序栈" class="headerlink" title="1.用数组实现栈，叫做顺序栈"></a>1.用数组实现栈，叫做顺序栈</h5><h5 id="2-用链表实现的栈，我们叫做链式栈"><a href="#2-用链表实现的栈，我们叫做链式栈" class="headerlink" title="2.用链表实现的栈，我们叫做链式栈"></a>2.用链表实现的栈，我们叫做链式栈</h5><h5 id="3-支持动态扩容的顺序栈"><a href="#3-支持动态扩容的顺序栈" class="headerlink" title="3.支持动态扩容的顺序栈"></a>3.支持动态扩容的顺序栈</h5><p>每次栈满之后，扩充栈的存储空间。平均每耗时的操作复杂度也为O(1),使用的方法叫做均摊法。即把所有操作均摊到每次操作上。</p><h4 id="三、栈在函数调用中的应用"><a href="#三、栈在函数调用中的应用" class="headerlink" title="三、栈在函数调用中的应用"></a>三、栈在函数调用中的应用</h4><h5 id="1-函数调用栈"><a href="#1-函数调用栈" class="headerlink" title="1.函数调用栈"></a>1.函数调用栈</h5><h5 id="2-编译器如何利用栈来实现表达式求值"><a href="#2-编译器如何利用栈来实现表达式求值" class="headerlink" title="2.编译器如何利用栈来实现表达式求值"></a>2.编译器如何利用栈来实现表达式求值</h5><blockquote><p>通过两个栈来实现、一个栈保存操作数，一个栈保存运算符。从左向右遍历表达式，当遇到数字的时候直接压入操作数栈。当遇到运算符，就与运算符栈的栈顶元素进行比较，如果比栈顶元素的运算优先级高，就将当前运算符压入栈；如果比栈顶元素的运算优先级低或者相同，就从运算符栈顶取栈顶运算符，从操作数栈顶取2个操作数，然后进行计算，再把计算结果压入操作数栈。然后继续向右遍历，继续操作，直到结束。</p></blockquote><h4 id="四、栈在括号匹配中的应用"><a href="#四、栈在括号匹配中的应用" class="headerlink" title="四、栈在括号匹配中的应用"></a>四、栈在括号匹配中的应用</h4><blockquote><p>我们利用栈来保存未匹配的左括号，从左到右依次扫描字符串，如果扫描到左括号就进行入栈操作。<br>当扫描到又括号就取出栈顶的左括号进行比较，如果一致就继续向下扫描。如果不一致，或者栈顶没有元素则匹配失败。</p></blockquote><h4 id="五、如何实现网页快进、后退功能"><a href="#五、如何实现网页快进、后退功能" class="headerlink" title="五、如何实现网页快进、后退功能"></a>五、如何实现网页快进、后退功能</h4><blockquote><p>1.用两个栈来实现，一个当前页面来实现。<br>2.一个保存后退页面栈stack_back，一个保存前进页面栈stack_go。<br>3.当相应的栈空时，限制进行前进后退操作。<br>4.当发生后退操作时，将当前页面入栈stack_go,从stack_back取栈顶元素作为当前页面。<br>5.当发生前进操作时，将当前页面入栈stack_back,从stack_go取栈顶元素作为当前页面。</p></blockquote><h2 id="第05课-队列"><a href="#第05课-队列" class="headerlink" title="第05课 - - - - - - - 队列"></a>第05课 - - - - - - - 队列</h2><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="一、如何理解队列"><a href="#一、如何理解队列" class="headerlink" title="一、如何理解队列"></a>一、如何理解队列</h4><blockquote><p>队列也是操作受限的线性表，限制为：<strong>FIFO(先进先出)</strong>。<br>队列支持两个基本操作:入队enqueue()向队尾添加一个元素,出队dequeue()从队头取出一个元素。</p></blockquote><h4 id="二、顺序队列和链式队列"><a href="#二、顺序队列和链式队列" class="headerlink" title="二、顺序队列和链式队列"></a>二、顺序队列和链式队列</h4><h5 id="1-用数组实现的队列叫顺序队列"><a href="#1-用数组实现的队列叫顺序队列" class="headerlink" title="1.用数组实现的队列叫顺序队列"></a>1.用数组实现的队列叫顺序队列</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">S_queue * <span class="title">createQueue</span><span class="params">(<span class="keyword">int</span> * nums,<span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> <span class="built_in">max</span>)</span> </span>&#123;</span><br><span class="line">    S_queue * squeue = (S_queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(S_queue));</span><br><span class="line">    <span class="keyword">int</span> * queueArray = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="built_in">max</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(queueArray,nums,<span class="built_in">size</span>);</span><br><span class="line">    squeue-&gt;innerArray = queueArray;</span><br><span class="line">    squeue-&gt;head = <span class="number">0</span>;</span><br><span class="line">    squeue-&gt;tail    = <span class="built_in">size</span>;</span><br><span class="line">    squeue-&gt;<span class="built_in">max</span> = <span class="built_in">max</span>;</span><br><span class="line">    <span class="keyword">return</span> squeue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enqueue</span><span class="params">(S_queue * <span class="built_in">queue</span>,<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;tail == <span class="built_in">queue</span>-&gt;<span class="built_in">max</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;head == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = <span class="built_in">queue</span>-&gt;tail - <span class="built_in">queue</span>-&gt;head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">max</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">queue</span>-&gt;innerArray[ i ] = <span class="built_in">queue</span>-&gt;innerArray[ <span class="built_in">queue</span>-&gt;head + i ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;head = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;tail = <span class="built_in">max</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail ++;</span><br><span class="line">    *(<span class="built_in">queue</span>-&gt;innerArray+<span class="built_in">queue</span>-&gt;tail) = item;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">(S_queue* <span class="built_in">queue</span>,<span class="keyword">int</span> * item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;head == <span class="built_in">queue</span>-&gt;tail) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    * item = *(<span class="built_in">queue</span>-&gt;innerArray+<span class="built_in">queue</span>-&gt;head);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head ++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意当列表末尾没有空间，而底层数组有空间的时候，需要进行数据搬移（在入队的时候进行）。</p><h5 id="2-用链表实现的队列叫链式队列"><a href="#2-用链表实现的队列叫链式队列" class="headerlink" title="2.用链表实现的队列叫链式队列"></a>2.用链表实现的队列叫链式队列</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">Link_Queue_Node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Link_Queue_Node</span> * <span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Link_Queue</span>&#123;</span></span><br><span class="line">    Node * head;</span><br><span class="line">    Node * tail;</span><br><span class="line">&#125;LQueue;</span><br><span class="line"></span><br><span class="line"><span class="function">Node * <span class="title">createNode</span> <span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    Node * node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(LQueue * <span class="built_in">queue</span>,<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node * node = createNode(data);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node * <span class="title">dequeue</span><span class="params">(LQueue * <span class="built_in">queue</span>, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node * node = <span class="built_in">queue</span>-&gt;head;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = <span class="built_in">queue</span>-&gt;head-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、循环队列"><a href="#三、循环队列" class="headerlink" title="三、循环队列"></a>三、循环队列</h4><p><strong>当用数组来实现队列，tail == n的时候，会有数据搬移操作，这样入队操作性能会受到影响。可以通过循环队列来避免数据搬移。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enqueue</span><span class="params">(S_queue * <span class="built_in">queue</span>,<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">queue</span>-&gt;tail + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;<span class="built_in">max</span> == <span class="built_in">queue</span>-&gt;head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(<span class="built_in">queue</span>-&gt;innerArray+<span class="built_in">queue</span>-&gt;tail) = item;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail = (<span class="built_in">queue</span>-&gt;tail+<span class="number">1</span>)%<span class="built_in">queue</span>-&gt;<span class="built_in">max</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">(S_queue * <span class="built_in">queue</span> , <span class="keyword">int</span> * item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;head == <span class="built_in">queue</span>-&gt;tail) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *item = *(<span class="built_in">queue</span>-&gt;innerArray+<span class="built_in">queue</span>-&gt;head);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = (<span class="built_in">queue</span>-&gt;head + <span class="number">1</span>)%<span class="built_in">queue</span>-&gt;<span class="built_in">max</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、阻塞队列和并发队列"><a href="#四、阻塞队列和并发队列" class="headerlink" title="四、阻塞队列和并发队列"></a>四、阻塞队列和并发队列</h4><h5 id="1-阻塞队列就是在队列的基础上增加了阻塞操作。"><a href="#1-阻塞队列就是在队列的基础上增加了阻塞操作。" class="headerlink" title="1.阻塞队列就是在队列的基础上增加了阻塞操作。"></a>1.阻塞队列就是在队列的基础上增加了阻塞操作。</h5><blockquote><p>当队列为空的时候，取数据操作，会被阻塞。当队列满的时候，插入数据操作会被阻塞。<br>这就是一个”<strong>生产者-消费者模型</strong>“。</p></blockquote><h5 id="2-并发队列就是线程安全的队列。"><a href="#2-并发队列就是线程安全的队列。" class="headerlink" title="2.并发队列就是线程安全的队列。"></a>2.并发队列就是线程安全的队列。</h5><blockquote><p>a.最简单的实现方式就是在enqueue()和dequeue()操作上面加锁。<br>b.基于数组的循环队列，利用CAS(Compare And Swap)原子操作，可以实现非常高效的并发队列。(这也是循环队列比链式队列应用更加广泛的原因)</p></blockquote><h5 id="引申"><a href="#引申" class="headerlink" title="引申:"></a>引申:</h5><p>CAS，即比较内存地址的当前值和期望值保证了交换操作基于最新值。如果其他线程修改了内存地址的值并且与期望值不同则造成CAS操作失败。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C代码描述 CAS</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span> <span class="params">(<span class="keyword">int</span>* reg, intoldval, intnewval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> old_reg_val = *reg;</span><br><span class="line">  <span class="keyword">if</span>(old_reg_val == oldval)</span><br><span class="line">     *reg = newval;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="五、线程池没有空闲线程时，新的任务请求资源时，线程该如何处理？"><a href="#五、线程池没有空闲线程时，新的任务请求资源时，线程该如何处理？" class="headerlink" title="五、线程池没有空闲线程时，新的任务请求资源时，线程该如何处理？"></a>五、线程池没有空闲线程时，新的任务请求资源时，线程该如何处理？</h4><p>一般有两种处理策略:</p><h5 id="1-非阻塞方式处理。通过直接拒绝任务请求进行处理。"><a href="#1-非阻塞方式处理。通过直接拒绝任务请求进行处理。" class="headerlink" title="1.非阻塞方式处理。通过直接拒绝任务请求进行处理。"></a>1.非阻塞方式处理。通过直接拒绝任务请求进行处理。</h5><h5 id="2-阻塞方式处理。讲请求进行排队，等有空闲的时候，取出排队的线程处理。"><a href="#2-阻塞方式处理。讲请求进行排队，等有空闲的时候，取出排队的线程处理。" class="headerlink" title="2.阻塞方式处理。讲请求进行排队，等有空闲的时候，取出排队的线程处理。"></a>2.阻塞方式处理。讲请求进行排队，等有空闲的时候，取出排队的线程处理。</h5><blockquote><p>a.基于链表实现的方式，可以实现一个支持无线排队的无界队列，但是可能会导致过多的请求排队等待，请求处理的响应时间过长。针对时间比较敏感的应用，该中方法不合适。<br>b.基于数组实现的方式，可以实现一个有界队列。队列的大小有限，所以线程池中排队的请求多于队列大小的时候，接下来的请求就会被拒绝。这种方式适合时间敏感的应用。设置队列的大小，会产生不同效果。队列太大，导致等待请求太多，响应不及时，队列太小导致无法充分利用系统资源，发挥最大性能。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第04课-栈&quot;&gt;&lt;a href=&quot;#第04课-栈&quot; class=&quot;headerlink&quot; title=&quot;第04课 - - - - - 
      
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》01 数组 &amp; 链表</title>
    <link href="http://yoursite.com/2020/04/16/DataStructure01/"/>
    <id>http://yoursite.com/2020/04/16/DataStructure01/</id>
    <published>2020-04-16T01:39:05.640Z</published>
    <updated>2020-04-25T01:09:47.173Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。</p></blockquote><h2 id="第01课-数组"><a href="#第01课-数组" class="headerlink" title="第01课 - - - - - - - 数组"></a>第01课 - - - - - - - 数组</h2><blockquote><p>数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p></blockquote><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><h4 id="1、数据排成像一条线一样的结构，属于线性表。"><a href="#1、数据排成像一条线一样的结构，属于线性表。" class="headerlink" title="1、数据排成像一条线一样的结构，属于线性表。"></a>1、数据排成像一条线一样的结构，属于线性表。</h4><p>(线性表中除了数组还有队列、栈、链表等。与之相对的概念就是非线性表，比如二叉树、堆、图等。)</p><h4 id="2、连续的内存空间和相同的数据类型。"><a href="#2、连续的内存空间和相同的数据类型。" class="headerlink" title="2、连续的内存空间和相同的数据类型。"></a>2、连续的内存空间和相同的数据类型。</h4><p>(因为有这两个限制，所以可以实现通过下表就能访问元素的随机访问机制。)</p><h4 id="3、高效的随机访问。"><a href="#3、高效的随机访问。" class="headerlink" title="3、高效的随机访问。"></a>3、高效的随机访问。</h4><p>随机访问第k个元素，可以通过数组下标直接访问，时间复杂度为O(1)。</p><h4 id="4、低效的插入删除操作"><a href="#4、低效的插入删除操作" class="headerlink" title="4、低效的插入删除操作"></a>4、低效的插入删除操作</h4><p>(在某个位置插入和删除一个元素、则需要将这个位置之后的元素都向后或者向前移动一位。<br>普通插入和删除操作的时间复杂度为：(1+2+…+n)/n  = O(n)。<br><strong>插入操作</strong>如果是无序的应用场景下，可以通过给某个位置的元素赋值，并把这个元素添加到数组末尾，这种情况下时间复杂度为O(1);<br><strong>删除操作</strong>如果在不追求数据的连续性应用场景下，可以通过标记已经删除的数据，把多次删除的操作集中在内存空间不足的时候一起执行，可以提高删除效率。</p><h3 id="警惕数组访问越界例子"><a href="#警惕数组访问越界例子" class="headerlink" title="警惕数组访问越界例子"></a><strong>警惕数组访问越界例子</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>( ; i &lt;= <span class="number">3</span>; i++ )&#123;</span><br><span class="line">        arr[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，arr[3]对应的地址和i一样，所以对相当于i = 0；所以会无限循环。<br> <strong>原理</strong>：在C语言函数调用的时候，栈帧存储的时候，C语言会对其进行优化，提高CPU访问数据的效率，如果保证8字节对齐，那么就可以用一个存储器操作来读或者写值。在题目中一个int占用4个字节和占用12字节arr数组外加一个int i合起来就是2个8字节，实现了字节对齐。先分配了数组的内存空间，接着分配了i的内存空间，所以i分配的内存地址刚好是arr[3];</p><h3 id="容器能代替数组吗"><a href="#容器能代替数组吗" class="headerlink" title="容器能代替数组吗"></a>容器能代替数组吗</h3><p>写业务可以牺牲一点性能，直接使用容器，优势是不需要处理扩容等问题。<br>写底层，使用数组会得到更高的性能。</p><h3 id="为什么数组下标从0开始"><a href="#为什么数组下标从0开始" class="headerlink" title="为什么数组下标从0开始?"></a>为什么数组下标从0开始?</h3><p>因为当数组arr下标从0开始的时候第x个元素的时候，传入arr+x<em>sizeof(type)就可以访问到。<br>因为当数组arr下标从1开始的时候第x个元素的时候，传入arr+(x-1)</em>sizeof(type)就可以访问到。<br>cpu会减少一次-1操作。</p><h2 id="第02课-链表-上"><a href="#第02课-链表-上" class="headerlink" title="第02课 - - - - - - - 链表(上)"></a>第02课 - - - - - - - 链表(上)</h2><h3 id="一、链表相关概念"><a href="#一、链表相关概念" class="headerlink" title="一、链表相关概念"></a>一、链表相关概念</h3><h4 id="1、链表"><a href="#1、链表" class="headerlink" title="1、链表"></a><strong>1、链表</strong></h4><p>链表是通过指针将一组零散的内存块串联起来使用。根据指针多少和指向可以分为:单链表、双向链表和循环链表等。</p><h4 id="2、链表组成"><a href="#2、链表组成" class="headerlink" title="2、链表组成"></a><strong>2、链表组成</strong></h4><p>被串联的内存块称为<strong>“节点”</strong>,习惯性的把第一个节点叫做<strong>“头结点”</strong>,把最后一个节点叫做<strong>“尾结点”</strong>，记录上个节点地址的指针叫做<strong>“前驱指针prev”</strong>,记录下个节点地址的指针叫做<strong>“后继指针next”</strong>。</p><h4 id="3、链表插入删除操作时间复杂度"><a href="#3、链表插入删除操作时间复杂度" class="headerlink" title="3、链表插入删除操作时间复杂度"></a><strong>3、链表插入删除操作时间复杂度</strong></h4><p>链表插入一个节点，删除一个节点所需操作的时间复杂度为O(1);</p><h4 id="4、链表随机访问时间复杂度"><a href="#4、链表随机访问时间复杂度" class="headerlink" title="4、链表随机访问时间复杂度"></a><strong>4、链表随机访问时间复杂度</strong></h4><p>链表随机访问第k个元素，就需要通过遍历才能访问到，所以时间复杂度为O(n)。</p><h4 id="5、循环链表"><a href="#5、循环链表" class="headerlink" title="5、循环链表"></a><strong>5、循环链表</strong></h4><p>循环链表就是尾结点的next指针指向头结点的单链表。当处理的数据具有环形结构特点的时候，特别适合采用循环链表。例如<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98" target="_blank" rel="noopener"><font color="blue">约瑟夫问题</font></a>。</p><h4 id="6、双向链表"><a href="#6、双向链表" class="headerlink" title="6、双向链表"></a><strong>6、双向链表</strong></h4><p>双向链表的每个节点都具有两个指针，分别指向前驱节点和后继节点。带来了存储空间浪费，但是支持双向遍历。为操作带来了灵活性。可以在O(1)的时间复杂度下找到前驱节点。<br>双向链表的优势场景:<br>a、当已经拿到了某节点，要删除该节点，或者增加前驱节点的时候，双向链表可以直接删除或者增加，但是单向链表需要先遍历找到前驱节点才能进行删除和增加。<br>b、在一个有序链表中，可以通过记录上一次查找的位置，然后根据值比较的关系，决定向前查找还是向后查找，平均只需要查找一半的数据。<br>实际上，链表通过空间换时间的设计思想，提高了某些情况下的操作时间复杂度。</p><h4 id="7、双向循环链表"><a href="#7、双向循环链表" class="headerlink" title="7、双向循环链表"></a><strong>7、双向循环链表</strong></h4><p>就是双向链表的头节点前驱指针prev指向尾节点。尾节点的后继指针next指向头结点。</p><h4 id="8、链表和数组性能分析"><a href="#8、链表和数组性能分析" class="headerlink" title="8、链表和数组性能分析"></a><strong>8、链表和数组性能分析</strong></h4><p>数组适合随机访问，时间复杂度为O(1)，插入删除操作的时间复杂度为O(n)。<br>链表适合插入删除，时间复杂度为O(1)，随机访问操作的时间复杂度为O(n)。<br>我们再实际开发中针对不同项目要具体分析用什么数据结构。</p><h3 id="二、如何实现LRU缓存淘汰算法"><a href="#二、如何实现LRU缓存淘汰算法" class="headerlink" title="二、如何实现LRU缓存淘汰算法"></a>二、如何实现LRU缓存淘汰算法</h3><p><strong>缓存淘汰策略，常见的有三种:先进先出策略FIFO(First In,First Out)、最少使用策略LFU(Least Frequently Used)、最近最少使用策略LRU(Least Recently Used)。</strong></p><h3 id="使用链表实现LRU步骤："><a href="#使用链表实现LRU步骤：" class="headerlink" title="使用链表实现LRU步骤："></a>使用链表实现LRU步骤：</h3><blockquote><p>1.维护一个有序的单链表，越靠近链表尾部的节点就是越早之前访问的。当有一个新的数据被访问的时候，我们从链表头开始顺序遍历离链表。<br>2.如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的节点，并将其原来的位置删除，然后再插入到链表头部。<br>3.如果此数据没有再缓存链表中，又可以分为两种情况:<br>1).如果此时缓存未满，则将此节点直接插入到链表的头部；<br>2).如果此时缓存已满，则删除链表的尾节点，然后将新的数据节点插入链表的头部。</p></blockquote><p>实现代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lru_Cache_Node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lru_Cache_Node</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span>* data;</span><br><span class="line">&#125;Lru_Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lru_Cache_List</span> &#123;</span></span><br><span class="line">    Lru_Node * header; <span class="comment">//头结点</span></span><br><span class="line">    <span class="keyword">int</span> currentSize; <span class="comment">//当前缓存大小</span></span><br><span class="line">    <span class="keyword">int</span> maxSize; <span class="comment">//最大缓存大小</span></span><br><span class="line">&#125;Lru_List;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accessData</span><span class="params">(<span class="keyword">void</span>* access_data,Lru_List * <span class="built_in">list</span>,uint <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否可以进行操作。</span></span><br><span class="line">    <span class="keyword">if</span> (access_data == <span class="literal">NULL</span> || <span class="built_in">list</span> == <span class="literal">NULL</span> || <span class="built_in">list</span>-&gt;header == <span class="literal">NULL</span> || <span class="built_in">list</span>-&gt;header-&gt;data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果操作的缓存为头结点则直接缓存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;header-&gt;data == access_data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历寻找链表</span></span><br><span class="line">    Lru_Node * node = <span class="built_in">list</span>-&gt;header;</span><br><span class="line">    <span class="keyword">int</span> find_flag =<span class="number">0</span>;</span><br><span class="line">    Lru_Node * findNode_pre = node;</span><br><span class="line">    node = node-&gt;next;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data == access_data) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       findNode_pre = node;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        find_flag ++;</span><br><span class="line">   &#125; <span class="keyword">while</span> (node != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//找到对应节点</span></span><br><span class="line">    <span class="keyword">if</span> (find_flag &lt; <span class="built_in">list</span>-&gt;currentSize) &#123;</span><br><span class="line">        findNode_pre-&gt;next = node-&gt;next; <span class="comment">//删除节点</span></span><br><span class="line">        node-&gt;next = <span class="built_in">list</span>-&gt;header; <span class="comment">//添加头结点</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;header = node;</span><br><span class="line">        node-&gt;data = access_data;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到对应节点</span></span><br><span class="line">    <span class="comment">//      缓存未满</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;currentSize &lt; <span class="built_in">list</span>-&gt;maxSize) &#123;</span><br><span class="line">        Lru_Node * newNode = (Lru_Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lru_Node));</span><br><span class="line">        newNode-&gt;next = <span class="built_in">list</span>-&gt;header;</span><br><span class="line">        <span class="built_in">list</span>-&gt;header = newNode;</span><br><span class="line">        newNode-&gt;data = access_data;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//      缓存已满</span></span><br><span class="line">    node-&gt;next = <span class="built_in">list</span>-&gt;header; <span class="comment">// node节点就是遍历到最后的尾节点，直接赋值为头结点。</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;header = node-&gt;next;</span><br><span class="line">    node-&gt;data = access_data;</span><br><span class="line">    findNode_pre-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 删除尾节点。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、使用数组实现LRU缓存淘汰策略"><a href="#三、使用数组实现LRU缓存淘汰策略" class="headerlink" title="三、使用数组实现LRU缓存淘汰策略"></a>三、使用数组实现LRU缓存淘汰策略</h3><h4 id="方式一：首位置保存最新访问数据，末尾位置优先清理"><a href="#方式一：首位置保存最新访问数据，末尾位置优先清理" class="headerlink" title="方式一：首位置保存最新访问数据，末尾位置优先清理"></a>方式一：<strong>首位置保存最新访问数据，末尾位置优先清理</strong></h4><blockquote><p>当访问的数据未存在于缓存的数组中时，直接将数据插入数组第一个元素位置，此时数组所有元素需要向后移动1个位置，时间复杂度为O(n)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入数组的第一个位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉末尾的数据，时间复杂度为O(1)。</p></blockquote><h4 id="方式二：首位置优先清理，末尾位置保存最新访问数据"><a href="#方式二：首位置优先清理，末尾位置保存最新访问数据" class="headerlink" title="方式二：首位置优先清理，末尾位置保存最新访问数据"></a>方式二：<strong>首位置优先清理，末尾位置保存最新访问数据</strong></h4><blockquote><p>当访问的数据未存在于缓存的数组中时，直接将数据添加进数组作为当前最有一个元素时间复杂度为O(1)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入当前数组最后一个元素的位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉数组首位置的元素，且剩余数组元素需整体前移一位，时间复杂度为O(n)。（优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。）</p></blockquote><h3 id="四、使用单链表判断回文字符串"><a href="#四、使用单链表判断回文字符串" class="headerlink" title="四、使用单链表判断回文字符串"></a>四、使用单链表判断回文字符串</h3><blockquote><p>1.使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步<br>2.在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。<br>3.最后比较中点两侧的链表是否相等</p></blockquote><p><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Link_Node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Link_Node</span>*<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Link_List</span> &#123;</span></span><br><span class="line">    Node * header;</span><br><span class="line">&#125;List;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deallocList</span> <span class="params">(List * <span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">    Node * node = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">list</span>-&gt;header != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node = <span class="built_in">list</span>-&gt;header;</span><br><span class="line">        <span class="built_in">list</span>-&gt;header = <span class="built_in">list</span>-&gt;header-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">char</span> * <span class="built_in">string</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span> == <span class="literal">NULL</span> || <span class="keyword">sizeof</span>(<span class="built_in">string</span>) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List <span class="built_in">list</span>;</span><br><span class="line">    Node * lastNode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(<span class="built_in">string</span>); i ++) &#123;</span><br><span class="line">        Node * node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        node-&gt;data = <span class="built_in">string</span>[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>.header == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">list</span>.header = node;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            lastNode-&gt;next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        lastNode = node;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * fast = <span class="built_in">list</span>.header;</span><br><span class="line">    Node * slow = <span class="built_in">list</span>.header;</span><br><span class="line">    Node * slowPre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> ( fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        Node * tempNode =  slow-&gt;next;</span><br><span class="line">        slow-&gt;next = slowPre;</span><br><span class="line">        slowPre = slow;</span><br><span class="line">        slow = tempNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//单数个</span></span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//偶数个</span></span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow-&gt;data != slowPre-&gt;data) &#123;</span><br><span class="line">            deallocList(&amp;<span class="built_in">list</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        slowPre = slowPre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    deallocList(&amp;<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第03课-链表-下"><a href="#第03课-链表-下" class="headerlink" title="第03课 - - - - - - - 链表(下)"></a>第03课 - - - - - - - 链表(下)</h2><h3 id="一、正确理解指针"><a href="#一、正确理解指针" class="headerlink" title="一、正确理解指针"></a>一、正确理解指针</h3><blockquote><p><strong>指针</strong>就是一个特别一点的变量，其值为一个内存地址。</p></blockquote><h3 id="二、警惕指针丢失和内存泄漏"><a href="#二、警惕指针丢失和内存泄漏" class="headerlink" title="二、警惕指针丢失和内存泄漏"></a>二、警惕指针丢失和内存泄漏</h3><blockquote><p>插入结点时，一定要注意操作的顺序。<br>删除链表结点时，也一定要记得手动释放内存空间</p></blockquote><h3 id="三、利用哨兵简化实现难度"><a href="#三、利用哨兵简化实现难度" class="headerlink" title="三、利用哨兵简化实现难度"></a>三、利用哨兵简化实现难度</h3><h4 id="1-当执行插入操作的时候，如果是一个空链表，需要执行的操作为"><a href="#1-当执行插入操作的时候，如果是一个空链表，需要执行的操作为" class="headerlink" title="1.当执行插入操作的时候，如果是一个空链表，需要执行的操作为:"></a>1.当执行插入操作的时候，如果是一个空链表，需要执行的操作为:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    head = new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-当执行删除操作的时候，如果是一个删除最后一个节点，需要执行的操作为"><a href="#2-当执行删除操作的时候，如果是一个删除最后一个节点，需要执行的操作为" class="headerlink" title="2.当执行删除操作的时候，如果是一个删除最后一个节点，需要执行的操作为:"></a>2.当执行删除操作的时候，如果是一个删除最后一个节点，需要执行的操作为:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。</strong>遇到这两种情况的时候，可以通过引入哨兵节点，来让这两种情况都和普通节点有相同的处理方法。</p></blockquote><h4 id="3-解决问题"><a href="#3-解决问题" class="headerlink" title="3.解决问题"></a>3.解决问题</h4><p>可以通过对链表添加一个具有空数据的哨兵节点，在任何时候，不管链表是不是空，head都会一直指向这个哨兵节点。这种链表就叫<strong>带头链表</strong>。</p><h3 id="四、重点留意边界条件处理"><a href="#四、重点留意边界条件处理" class="headerlink" title="四、重点留意边界条件处理"></a>四、重点留意边界条件处理</h3><blockquote><p>检查逻辑:<br>1.如果链表为空时，代码是否能正常工作?<br>2.如果链表只包含一个结点时，代码是否能正常工作?<br>3.如果链表只包含两个结点时，代码是否能正常工作?<br>4.代码逻辑在处理头结点和尾结点的时候，是否能正常工作?</p></blockquote><h3 id="五、举例画图，辅助思考"><a href="#五、举例画图，辅助思考" class="headerlink" title="五、举例画图，辅助思考"></a>五、举例画图，辅助思考</h3><h3 id="六、多写多练，其义自见"><a href="#六、多写多练，其义自见" class="headerlink" title="六、多写多练，其义自见"></a>六、多写多练，其义自见</h3><p>以下链表需要熟练掌握，可以直接死记硬背，手写:</p><h4 id="基础结构体"><a href="#基础结构体" class="headerlink" title="基础结构体"></a>基础结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Link_Node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Link_Node</span> * <span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Link_List</span> &#123;</span></span><br><span class="line">    Node * head;</span><br><span class="line">&#125;List;</span><br></pre></td></tr></table></figure><h4 id="1-单链表反转"><a href="#1-单链表反转" class="headerlink" title="1.单链表反转"></a>1.单链表反转</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//翻转列表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseList</span> <span class="params">(List * <span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span> || <span class="built_in">list</span>-&gt;head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * currentHead = <span class="literal">NULL</span>; <span class="comment">//反转多出来的列表的头。</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">list</span>-&gt;head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//保存新头</span></span><br><span class="line">        Node * newHead = <span class="built_in">list</span>-&gt;head-&gt;next;</span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;next = currentHead;</span><br><span class="line">        <span class="comment">//赋值多出来的列表头</span></span><br><span class="line">        currentHead = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="comment">//赋值新头</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;head = newHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = currentHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-链表中环的检测"><a href="#2-链表中环的检测" class="headerlink" title="2.链表中环的检测"></a>2.链表中环的检测</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hasCycleInList</span><span class="params">(List * <span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span> || <span class="built_in">list</span>-&gt;head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * fast = <span class="built_in">list</span>-&gt;head;<span class="comment">//快指针</span></span><br><span class="line">    Node * slow = <span class="built_in">list</span>-&gt;head;<span class="comment">//慢指针</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-两个有序的链表合并"><a href="#3-两个有序的链表合并" class="headerlink" title="3.两个有序的链表合并"></a>3.两个有序的链表合并</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List * <span class="title">mergeList</span><span class="params">(List *la,List *lb)</span> </span>&#123;</span><br><span class="line">    List * resultList = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">    resultList-&gt;head = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    Node * node_a = la-&gt;head;</span><br><span class="line">    Node * node_b = lb-&gt;head;</span><br><span class="line">    </span><br><span class="line">    Node * offsetNode = resultList-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (node_a != <span class="literal">NULL</span> &amp;&amp; node_b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node_a-&gt;data &lt; node_b-&gt;data) &#123;</span><br><span class="line">            offsetNode-&gt;next = node_a;</span><br><span class="line">            node_a = node_a-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            offsetNode-&gt;next = node_b;</span><br><span class="line">            node_b = node_b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        offsetNode = offsetNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node_a != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        offsetNode-&gt;next = node_a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node_b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        offsetNode-&gt;next = node_b;</span><br><span class="line">    &#125;</span><br><span class="line">    resultList-&gt;head = resultList-&gt;head-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> resultList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-删除链表倒数第-n-个结点"><a href="#4-删除链表倒数第-n-个结点" class="headerlink" title="4.删除链表倒数第 n 个结点"></a>4.删除链表倒数第 n 个结点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteNode</span><span class="params">(List * <span class="built_in">list</span>,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * fast = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (n-- &amp;&amp; fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * low = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        low = low-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * deleteNode = low-&gt;next;</span><br><span class="line">    low-&gt;next = low-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(deleteNode);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-求链表的中间结点"><a href="#5-求链表的中间结点" class="headerlink" title="5.求链表的中间结点"></a>5.求链表的中间结点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">findMiddleNode</span><span class="params">( List * <span class="built_in">list</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span> ||<span class="built_in">list</span>-&gt;head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * fast = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    Node * slow = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;该系列为学习极客时间王争老师《数据结构与算法之美》课后笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第01课-数组&quot;&gt;&lt;a href=&quot;#第01课-数组&quot; class=&quot;headerlink&quot; title=&quot;第01课 - - - - 
      
    
    </summary>
    
    
      <category term="读书系列" scheme="http://yoursite.com//categories/234/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法之美" scheme="http://yoursite.com//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>排序算法总结</title>
    <link href="http://yoursite.com/2020/04/15/Sort/"/>
    <id>http://yoursite.com/2020/04/15/Sort/</id>
    <published>2020-04-15T01:44:48.053Z</published>
    <updated>2020-04-24T09:56:21.153Z</updated>
    
    <content type="html"><![CDATA[<h4 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h4><blockquote><p>1.基于比较来划分排序算法可以将算法分为两大类：<font color="red">比较</font>和<font color="red">非比较</font>。<br>由于任何通过比较来排序算法至少要进行n*logn次才能排完，并且理论上不存在更快的比较排序算法。所以也用<font color="red">非线性时间比较排序</font>来命名，另一类就是<font color="red">线性的非比较排序</font>。<br>2.在非线性时间比较排序算法中，又通过比较后对数据处理操作的不同分为：<font color="red">交换排序</font>、<font color="red">插入排序</font>、<font color="red">选择排序</font>、<font color="red">归并排序</font>。<br>3.在线性时间非比较排序算法中，可以分为<font color="red">计数排序</font>、<font color="red">桶排序</font>、<font color="red">基数排序</font>。</p></blockquote><h4 id="十大排序算法分类"><a href="#十大排序算法分类" class="headerlink" title="十大排序算法分类"></a>十大排序算法分类</h4><p><img src="/2020/04/15/Sort/sort1.png" alt="排序算法分类"></p><h4 id="十大排序算法时间复杂度"><a href="#十大排序算法时间复杂度" class="headerlink" title="十大排序算法时间复杂度"></a>十大排序算法时间复杂度</h4><p><img src="/2020/04/15/Sort/sort2.png" alt="排序算法时间复杂度"></p><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><blockquote><p>先看一个物理现象：水沸腾时，在水的底部形成的气泡上升，上升过程中体积逐渐变大，到水面破裂开，里面的水蒸气散发到空气中。<br>从这个物理现象可以抽象为气泡从水底上升，过程中提及逐渐变大。<br>两个相邻的数互相比较，如果前一个数大于后一个数，就交换两个数位置，然后继续比较后面两个数的位置。<br>经过一轮比较得到一个最大值，再将剩下的数进行一轮轮比较，就能得到一个有序数列。<br>这个排序的过程一轮就像一次冒泡一样，于是命名了冒泡排序法。</p></blockquote><h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ... array_num.<span class="built_in">count</span>-<span class="number">1</span> &#123;     <span class="comment">//运行N轮</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span> ..&lt; array_num.<span class="built_in">count</span>-<span class="number">1</span>-i &#123; <span class="comment">//每轮比较N-1次</span></span><br><span class="line">        <span class="keyword">if</span> (array_num[j] &gt; array_num[j+<span class="number">1</span>]) &#123; <span class="comment">//每次前面的数比后面的大交换位置 比较n*(n-1)次</span></span><br><span class="line">            <span class="keyword">let</span> temp = array_num[j]</span><br><span class="line">            array_num[j] = array_num[j+<span class="number">1</span>]</span><br><span class="line">            array_num[j+<span class="number">1</span>] = temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;排序算法分类&quot;&gt;&lt;a href=&quot;#排序算法分类&quot; class=&quot;headerlink&quot; title=&quot;排序算法分类&quot;&gt;&lt;/a&gt;排序算法分类&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;1.基于比较来划分排序算法可以将算法分为两大类：&lt;font color=&quot;red&quot;
      
    
    </summary>
    
    
      <category term="算法总结" scheme="http://yoursite.com//categories/234/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法" scheme="http://yoursite.com//tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>H.264码流 MP4封装格式的理解</title>
    <link href="http://yoursite.com/2020/04/14/H264-MP4/"/>
    <id>http://yoursite.com/2020/04/14/H264-MP4/</id>
    <published>2020-04-14T12:58:51.363Z</published>
    <updated>2020-04-15T09:28:13.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="H-264"><a href="#H-264" class="headerlink" title="H.264"></a>H.264</h2><blockquote><p>H.264，又称为MPEG-4第10部分，高级视频编码是一种面向块，基于运动补偿的视频编码标准。H.264/AVC项目的目的是为了创建一个更佳的视频压缩标准，在更低的比特率的情况下依然能够提供良好视频质量的标准。</p></blockquote><h2 id="MP4"><a href="#MP4" class="headerlink" title="MP4"></a>MP4</h2><blockquote><p>MP4或称MPEG-4第14部分是一种标准的数字多媒体容器格式。MPEG-4第14部分的扩展名为.mp4，以存储数字音频及数字视频为主，但也可以存储字幕和静止图像。因其可容纳支持比特流的视频流（如高级视频编码），MP4可以在网络传输时使用流式传输。</p></blockquote><h2 id="MP4封装"><a href="#MP4封装" class="headerlink" title="MP4封装"></a>MP4封装</h2><p>MP4视频其实就是一系列的画面，通过压缩算法压缩以后，通过MP4封装协议打包成一个整体的文件（其后缀名为.mp4）。 MP4的封装打包类似于收纳盒。一个个的box，其中存储不同的数据。大盒子装小盒子，可以多层嵌套。<br>通过<a href="http://mp4parser.com/" target="_blank" rel="noopener">MP4解析网站</a>对MP4视频的盒子进行逐个分析：<br><img src="/2020/04/14/H264-MP4/mp4_1.png" alt><br>可以将整个MP4文件理解为最大的盒子，其中第一层打开以后有四个盒子：分别是ftype、moov、free、mdat。</p><h3 id="一、ftyp"><a href="#一、ftyp" class="headerlink" title="一、ftyp"></a>一、<font color="red">ftyp</font></h3><p>其中的具体存储数据为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">000000206674797069736f6d00000200  69736f6d69736f32617663316d703431</span><br><span class="line">....ftypisom....isomiso2avc1mp41</span><br></pre></td></tr></table></figure><p>具体就是:<br><img src="/2020/04/14/H264-MP4/mp4_2.png" alt><br>ftyp，每个MP4文件只有一个。其中Box type就是盒子的类型，Major brand、Minor version 以及compatible  brands都是这个MP4文件的封装信息。他们共同描述了MP4文件使用了什么样的封装子格式。</p><h3 id="二、moov"><a href="#二、moov" class="headerlink" title="二、moov"></a>二、<font color="red">moov</font></h3><p><img src="/2020/04/14/H264-MP4/mp4_4.png" alt><br>moov即Movie Box，每个MP4文件也只有一个，一般都跟在ftyp之后。moov包含4个box，分别是:mvhd、trak、trak、udta。</p><h4 id="1、mvhd"><a href="#1、mvhd" class="headerlink" title="1、mvhd"></a>1、<font color="red">mvhd</font></h4><p><img src="/2020/04/14/H264-MP4/mp4_6.png" alt><br>mvhd：即Movie Header Box，包含了视频媒体信息，视频时长、创建时间等。</p><h4 id="2、trak"><a href="#2、trak" class="headerlink" title="2、trak"></a>2、<font color="red">trak</font></h4><p><img src="/2020/04/14/H264-MP4/mp4_5.png" alt><br>trak: 即Track Box，包含三个box，分别是tkhd、edts、mdia</p><h5 id="2-1、tkhd"><a href="#2-1、tkhd" class="headerlink" title="2.1、tkhd"></a>2.1、<font color="red">tkhd</font></h5><p><img src="/2020/04/14/H264-MP4/mp4_7.png" alt><br>tkhd:即track header box，包含了track信息，track id、如果是视频track包含视频宽高，如果是音频track则包含音频流长度、等信息。</p><h5 id="2-2、edts"><a href="#2-2、edts" class="headerlink" title="2.2、edts"></a>2.2、<font color="red">edts</font></h5><p><img src="/2020/04/14/H264-MP4/mp4_8.png" alt><br>edts:内部包含一个elst盒子:<br><img src="/2020/04/14/H264-MP4/mp4_9.png" alt><br>用来使track的时间戳产生偏移。是一个可选存在与否的盒子。</p><h5 id="2-3、mdia"><a href="#2-3、mdia" class="headerlink" title="2.3、mdia"></a>2.3、<font color="red">mdia</font></h5><p><img src="/2020/04/14/H264-MP4/mp4_10.png" alt><br>mdia:即Media Box，包含track的sample信息。media包含三个box：分别是mdhd、hdlr、minf。</p><h5 id="mdhd"><a href="#mdhd" class="headerlink" title="mdhd"></a><font color="red">mdhd</font></h5><p><img src="/2020/04/14/H264-MP4/mp4_11.png" alt><br>mdhd:mdhd即为media header box。</p><h5 id="hdlr"><a href="#hdlr" class="headerlink" title="hdlr"></a><font color="red">hdlr</font></h5><p><img src="/2020/04/14/H264-MP4/mp4_12.png" alt><br>hdlr:hdlr即为Handler Reference Box。</p><h5 id="minf"><a href="#minf" class="headerlink" title="minf"></a><font color="red">minf</font></h5><p><img src="/2020/04/14/H264-MP4/mp4_13.png" alt><br>hdlr:hdlr即为Handler Reference Box。</p><h4 id="3、udta"><a href="#3、udta" class="headerlink" title="3、udta"></a>3、<font color="red">udta</font></h4><p><img src="/2020/04/14/H264-MP4/mp4_14.png" alt><br>udta:即User Data Box,用于存放用户自定义的信息。</p><h3 id="三、free"><a href="#三、free" class="headerlink" title="三、free"></a>三、<font color="red">free</font></h3><p>free:和视频音频的解码无关。</p><h3 id="四、mdat"><a href="#四、mdat" class="headerlink" title="四、mdat"></a>四、<font color="red">mdat</font></h3><p>mdat:即Media Data,保存了视频和音频的数据。</p><h2 id="MP4解封装"><a href="#MP4解封装" class="headerlink" title="MP4解封装"></a>MP4解封装</h2><p>先放MP4文件架构图:<br><img src="/2020/04/14/H264-MP4/mp4_15.png" alt><br>那么很明显了。<br>解封装的流程就是先读取trak盒子的Track信息，然后按照Track信息去mdat读取相应的数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;H-264&quot;&gt;&lt;a href=&quot;#H-264&quot; class=&quot;headerlink&quot; title=&quot;H.264&quot;&gt;&lt;/a&gt;H.264&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;H.264，又称为MPEG-4第10部分，高级视频编码是一种面向块，基于运动补偿的视频编码
      
    
    </summary>
    
    
      <category term="个人理解" scheme="http://yoursite.com//categories/234/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com//tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg 学习 03 h264_MP4视频-视频流解码</title>
    <link href="http://yoursite.com/2020/04/14/FFmpeg02/"/>
    <id>http://yoursite.com/2020/04/14/FFmpeg02/</id>
    <published>2020-04-14T10:38:46.855Z</published>
    <updated>2020-04-15T06:28:48.037Z</updated>
    
    <content type="html"><![CDATA[<p><code>FFmpeg 4.2 iOS</code></p><h1 id="解码流程："><a href="#解码流程：" class="headerlink" title="解码流程："></a>解码流程：</h1><h3 id="1-读取文件，从中获得文件的编码信息。"><a href="#1-读取文件，从中获得文件的编码信息。" class="headerlink" title="1.读取文件，从中获得文件的编码信息。"></a>1.读取文件，从中获得文件的编码信息。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取流信息</span></span><br><span class="line">- (<span class="keyword">int</span>)_readfile &#123;</span><br><span class="line">    <span class="comment">//获取文件地址</span></span><br><span class="line">    <span class="built_in">NSString</span> * filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"GalGadot"</span> ofType:<span class="string">@".mp4"</span>];</span><br><span class="line">    <span class="comment">//通过ffmpeg接口读取文件</span></span><br><span class="line">    <span class="keyword">if</span> ( avformat_open_input(&amp;fmt_ctx,filePath.UTF8String, <span class="literal">NULL</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"avformat_open_input error !"</span>);</span><br><span class="line">        avformat_free_context(fmt_ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从文件中读取流信息</span></span><br><span class="line">    <span class="keyword">if</span> ( avformat_find_stream_info(fmt_ctx, <span class="literal">NULL</span>) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"avformat_find_stream_info error !"</span>);</span><br><span class="line">        avformat_close_input(&amp;fmt_ctx);</span><br><span class="line">        avformat_free_context(fmt_ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取所需要的流</span></span><br><span class="line">    video_track_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fmt_ctx-&gt;nb_streams; ++i) &#123;</span><br><span class="line">        <span class="built_in">AVCodecParameters</span> * code_params = fmt_ctx-&gt;streams[i]-&gt;codecpar;</span><br><span class="line">        <span class="comment">//读取到视频track</span></span><br><span class="line">        <span class="keyword">if</span> ( code_params-&gt;codec_type == <span class="built_in">AVMEDIA_TYPE_VIDEO</span> ) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"stream:%d code_type:AVMEDIA_TYPE_VIDEO"</span>,i);</span><br><span class="line">            video_track_index = i;</span><br><span class="line">            video_Codec = avcodec_find_decoder(code_params-&gt;codec_id);</span><br><span class="line">            video_Codec_params = code_params;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (video_track_index &gt; <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="comment">//打印流信息</span></span><br><span class="line">        av_dump_format(fmt_ctx, <span class="number">0</span>, filePath.UTF8String, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"未读取到视频流"</span>);</span><br><span class="line">    avformat_close_input(&amp;fmt_ctx);</span><br><span class="line">    avformat_free_context(fmt_ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-设置相应的解码器。"><a href="#2-设置相应的解码器。" class="headerlink" title="2.设置相应的解码器。"></a>2.设置相应的解码器。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编码器设置</span></span><br><span class="line">- (<span class="keyword">int</span>)_videoCodecSetup &#123;</span><br><span class="line">    <span class="comment">//创建解码器上下文</span></span><br><span class="line">    video_Codec_Ctx = avcodec_alloc_context3(video_Codec);</span><br><span class="line">    <span class="comment">///将解码器信息传入解码器上下文保存</span></span><br><span class="line">    <span class="keyword">if</span> ( avcodec_parameters_to_context(video_Codec_Ctx, video_Codec_params) != <span class="number">0</span>) &#123;</span><br><span class="line">        avcodec_free_context(&amp;video_Codec_Ctx);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"avcodec_parameters_to_context error!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打开解码器</span></span><br><span class="line">    <span class="keyword">if</span> (avcodec_open2(video_Codec_Ctx, video_Codec, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        avcodec_free_context(&amp;video_Codec_Ctx);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"avcodec_parameters_to_context error!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"解码器设置成功"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-读取数据传入解码器，解码器解码，接收解码好的数据。"><a href="#3-读取数据传入解码器，解码器解码，接收解码好的数据。" class="headerlink" title="3.读取数据传入解码器，解码器解码，接收解码好的数据。"></a>3.读取数据传入解码器，解码器解码，接收解码好的数据。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_handleDecode &#123;</span><br><span class="line">    <span class="comment">//创建一个包，用来读取未解码的数据</span></span><br><span class="line">    <span class="built_in">AVPacket</span> * video_packet = av_packet_alloc();</span><br><span class="line">    av_init_packet(video_packet);</span><br><span class="line">    <span class="comment">//创建一个frame，用来接收解码的数据</span></span><br><span class="line">    <span class="built_in">AVFrame</span> * video_frame = av_frame_alloc();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环的读取需要解码的数据包</span></span><br><span class="line">    <span class="keyword">while</span> (av_read_frame(fmt_ctx, video_packet) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//过滤，只处理视频包</span></span><br><span class="line">        <span class="keyword">if</span> (video_packet-&gt;stream_index == video_track_index) &#123;</span><br><span class="line">            <span class="comment">//将视频解码数据送进解码器</span></span><br><span class="line">            <span class="keyword">int</span> ret = avcodec_send_packet(video_Codec_Ctx, video_packet);</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"avcodec_send_packet success"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"avcodec_send_packet error %d"</span>,ret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//接收解码数据</span></span><br><span class="line">            ret = avcodec_receive_frame(video_Codec_Ctx, video_frame);</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//解码成功</span></span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"width:%d height:%d"</span>,video_frame-&gt;width,video_frame-&gt;height);</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"m_frame size :%d"</span>,video_frame-&gt;pkt_size);</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"format:%d"</span>,video_frame-&gt;format);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//只看一帧，然后返回。</span></span><br><span class="line">                av_packet_free(&amp;video_packet);</span><br><span class="line">                av_frame_free(&amp;video_frame);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"avcodec_receive_frame error %d"</span>,ret);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        av_packet_unref(video_packet);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    av_packet_free(&amp;video_packet);</span><br><span class="line">    av_frame_free(&amp;video_frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;FFmpeg 4.2 iOS&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;解码流程：&quot;&gt;&lt;a href=&quot;#解码流程：&quot; class=&quot;headerlink&quot; title=&quot;解码流程：&quot;&gt;&lt;/a&gt;解码流程：&lt;/h1&gt;&lt;h3 id=&quot;1-读取文件，从中获得文件的编码信息
      
    
    </summary>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com//categories/234/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com//tags/FFmpeg/"/>
    
      <category term="音视频" scheme="http://yoursite.com//tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="ios" scheme="http://yoursite.com//tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg 学习 01 编译源码</title>
    <link href="http://yoursite.com/2020/04/13/FFmpeg00/"/>
    <id>http://yoursite.com/2020/04/13/FFmpeg00/</id>
    <published>2020-04-13T06:19:36.075Z</published>
    <updated>2020-04-14T07:35:01.704Z</updated>
    
    <content type="html"><![CDATA[<p><code>编译步骤</code></p><h5 id="1-安装Command-Line-Tools，默认已经安装Xcode就忽略这步。"><a href="#1-安装Command-Line-Tools，默认已经安装Xcode就忽略这步。" class="headerlink" title="1.安装Command Line Tools，默认已经安装Xcode就忽略这步。"></a>1.安装Command Line Tools，默认已经安装Xcode就忽略这步。</h5><h6 id="2-预处理文件安装："><a href="#2-预处理文件安装：" class="headerlink" title="2.预处理文件安装："></a>2.预处理文件安装：</h6><h6 id="2-1-下载文件gas-preprocessor-pl"><a href="#2-1-下载文件gas-preprocessor-pl" class="headerlink" title="2.1 下载文件gas-preprocessor.pl;"></a>2.1 下载文件<a href="https://github.com/libav/gas-preprocessor" target="_blank" rel="noopener"><font color="blue" size="1">gas-preprocessor.pl</font></a>;</h6><h6 id="2-1-解压文件，并放到-usr-local-bin目录下"><a href="#2-1-解压文件，并放到-usr-local-bin目录下" class="headerlink" title="2.1 解压文件，并放到/usr/local/bin目录下;"></a>2.1 解压文件，并放到<code>/usr/local/bin</code>目录下;</h6><h6 id="2-1-添加文件权限"><a href="#2-1-添加文件权限" class="headerlink" title="2.1 添加文件权限:"></a>2.1 添加文件权限:</h6><blockquote><p>chmod 777 xxx/gas-preprocessor.pl</p></blockquote><h5 id="3-编译："><a href="#3-编译：" class="headerlink" title="3.编译："></a>3.编译：</h5><h6 id="3-1这里为了方便编译下载一键脚本"><a href="#3-1这里为了方便编译下载一键脚本" class="headerlink" title="3.1这里为了方便编译下载一键脚本:"></a>3.1这里为了方便编译下载<a href="https://github.com/kewlbear/FFmpeg-iOS-build-script" target="_blank" rel="noopener"><font color="blue" size="1">一键脚本</font></a>:</h6><h6 id="3-2直接执行对应脚本"><a href="#3-2直接执行对应脚本" class="headerlink" title="3.2直接执行对应脚本"></a>3.2直接执行对应脚本</h6><blockquote><p>./build-ffmpeg-iOS-framework.sh</p></blockquote><h4 id="4-编译结果"><a href="#4-编译结果" class="headerlink" title="4.编译结果:"></a>4.编译结果:</h4><blockquote><p><font color="red" size="1">FFmpeg.framework</font></p></blockquote><p>就是我们需要的库以及头文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;编译步骤&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;1-安装Command-Line-Tools，默认已经安装Xcode就忽略这步。&quot;&gt;&lt;a href=&quot;#1-安装Command-Line-Tools，默认已经安装Xcode就忽略这步。&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com//categories/234/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com//tags/FFmpeg/"/>
    
      <category term="音视频" scheme="http://yoursite.com//tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="ios" scheme="http://yoursite.com//tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg 学习 02 h264_MP4视频-iOS项目使用FFmpeg库</title>
    <link href="http://yoursite.com/2020/04/13/FFmpeg01/"/>
    <id>http://yoursite.com/2020/04/13/FFmpeg01/</id>
    <published>2020-04-13T06:19:36.075Z</published>
    <updated>2020-04-15T06:28:29.378Z</updated>
    
    <content type="html"><![CDATA[<p><code>FFmpeg 4.2 iOS</code></p><h1 id="添加过程"><a href="#添加过程" class="headerlink" title="添加过程"></a>添加过程</h1><h4 id="1-直接将编译好的framework拖进工程"><a href="#1-直接将编译好的framework拖进工程" class="headerlink" title="1.直接将编译好的framework拖进工程"></a>1.直接将编译好的framework拖进工程</h4><p><img src="/2020/04/13/FFmpeg01/framework.png" alt="frame"></p><h4 id="2-添加依赖"><a href="#2-添加依赖" class="headerlink" title="2.添加依赖"></a>2.添加依赖</h4><blockquote><p>打开工程设置Build  Phases<br>在Link Binary With Libraries中添加ffmpeg依赖的库<br><img src="/2020/04/13/FFmpeg01/linkBinary.png" alt="frame"></p></blockquote><h4 id="3-设置头文件路径-可不做"><a href="#3-设置头文件路径-可不做" class="headerlink" title="3.设置头文件路径(可不做)"></a>3.设置头文件路径(可不做)</h4><blockquote><p>打开工程设置Build Settings<br>在search栏中输出 header s就可以找到Header Search Paths,设置头文件路径。<br><img src="/2020/04/13/FFmpeg01/setting.png" alt="frame"><br>设置为对应的目录:<br><img src="/2020/04/13/FFmpeg01/path.png" alt="frame"></p></blockquote><h4 id="4-测试是否引入成功"><a href="#4-测试是否引入成功" class="headerlink" title="4.测试是否引入成功"></a>4.测试是否引入成功</h4><blockquote><p>头文件引入<code>#import &quot;avformat.h&quot;</code><br>    然后添加以下内容，并编译xcode工程。</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"GalGadot"</span> ofType:<span class="string">@"mp4"</span>];</span><br><span class="line">avformat_open_input(&amp;fmt_ctx,filePath.UTF8String, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h5 id="如果编译成功，则表示运行正确。"><a href="#如果编译成功，则表示运行正确。" class="headerlink" title="如果编译成功，则表示运行正确。"></a>如果编译成功，则表示运行正确。</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;FFmpeg 4.2 iOS&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;添加过程&quot;&gt;&lt;a href=&quot;#添加过程&quot; class=&quot;headerlink&quot; title=&quot;添加过程&quot;&gt;&lt;/a&gt;添加过程&lt;/h1&gt;&lt;h4 id=&quot;1-直接将编译好的framework拖进工程
      
    
    </summary>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com//categories/234/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com//tags/FFmpeg/"/>
    
      <category term="音视频" scheme="http://yoursite.com//tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="ios" scheme="http://yoursite.com//tags/ios/"/>
    
  </entry>
  
</feed>
